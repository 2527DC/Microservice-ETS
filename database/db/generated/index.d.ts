
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model Route
 * 
 */
export type Route = $Result.DefaultSelection<Prisma.$RoutePayload>
/**
 * Model RouteManagementBooking
 * 
 */
export type RouteManagementBooking = $Result.DefaultSelection<Prisma.$RouteManagementBookingPayload>
/**
 * Model RouteManagement
 * 
 */
export type RouteManagement = $Result.DefaultSelection<Prisma.$RouteManagementPayload>
/**
 * Model Driver
 * 
 */
export type Driver = $Result.DefaultSelection<Prisma.$DriverPayload>
/**
 * Model Vehicle
 * 
 */
export type Vehicle = $Result.DefaultSelection<Prisma.$VehiclePayload>
/**
 * Model VehicleType
 * 
 */
export type VehicleType = $Result.DefaultSelection<Prisma.$VehicleTypePayload>
/**
 * Model Vendor
 * 
 */
export type Vendor = $Result.DefaultSelection<Prisma.$VendorPayload>
/**
 * Model VendorUser
 * 
 */
export type VendorUser = $Result.DefaultSelection<Prisma.$VendorUserPayload>
/**
 * Model Cutoff
 * 
 */
export type Cutoff = $Result.DefaultSelection<Prisma.$CutoffPayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model Shift
 * 
 */
export type Shift = $Result.DefaultSelection<Prisma.$ShiftPayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model WeekoffConfig
 * 
 */
export type WeekoffConfig = $Result.DefaultSelection<Prisma.$WeekoffConfigPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model Policy
 * 
 */
export type Policy = $Result.DefaultSelection<Prisma.$PolicyPayload>
/**
 * Model PolicyPermission
 * 
 */
export type PolicyPermission = $Result.DefaultSelection<Prisma.$PolicyPermissionPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model RolePolicy
 * 
 */
export type RolePolicy = $Result.DefaultSelection<Prisma.$RolePolicyPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const GenderEnum: {
  Male: 'Male',
  Female: 'Female',
  Other: 'Other'
};

export type GenderEnum = (typeof GenderEnum)[keyof typeof GenderEnum]


export const VerificationStatusEnum: {
  Pending: 'Pending',
  Approved: 'Approved',
  Rejected: 'Rejected'
};

export type VerificationStatusEnum = (typeof VerificationStatusEnum)[keyof typeof VerificationStatusEnum]


export const BookingStatusEnum: {
  Pending: 'Pending',
  Confirmed: 'Confirmed',
  Ongoing: 'Ongoing',
  Completed: 'Completed',
  Cancelled: 'Cancelled',
  NoShow: 'NoShow'
};

export type BookingStatusEnum = (typeof BookingStatusEnum)[keyof typeof BookingStatusEnum]


export const ShiftLogTypeEnum: {
  IN: 'IN',
  OUT: 'OUT'
};

export type ShiftLogTypeEnum = (typeof ShiftLogTypeEnum)[keyof typeof ShiftLogTypeEnum]


export const PickupTypeEnum: {
  Pickup: 'Pickup',
  Nodal: 'Nodal'
};

export type PickupTypeEnum = (typeof PickupTypeEnum)[keyof typeof PickupTypeEnum]


export const RouteManagementStatusEnum: {
  Planned: 'Planned',
  Assigned: 'Assigned',
  InProgress: 'InProgress',
  Completed: 'Completed',
  Cancelled: 'Cancelled'
};

export type RouteManagementStatusEnum = (typeof RouteManagementStatusEnum)[keyof typeof RouteManagementStatusEnum]

}

export type GenderEnum = $Enums.GenderEnum

export const GenderEnum: typeof $Enums.GenderEnum

export type VerificationStatusEnum = $Enums.VerificationStatusEnum

export const VerificationStatusEnum: typeof $Enums.VerificationStatusEnum

export type BookingStatusEnum = $Enums.BookingStatusEnum

export const BookingStatusEnum: typeof $Enums.BookingStatusEnum

export type ShiftLogTypeEnum = $Enums.ShiftLogTypeEnum

export const ShiftLogTypeEnum: typeof $Enums.ShiftLogTypeEnum

export type PickupTypeEnum = $Enums.PickupTypeEnum

export const PickupTypeEnum: typeof $Enums.PickupTypeEnum

export type RouteManagementStatusEnum = $Enums.RouteManagementStatusEnum

export const RouteManagementStatusEnum: typeof $Enums.RouteManagementStatusEnum

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Bookings
 * const bookings = await prisma.booking.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Bookings
   * const bookings = await prisma.booking.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.route`: Exposes CRUD operations for the **Route** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Routes
    * const routes = await prisma.route.findMany()
    * ```
    */
  get route(): Prisma.RouteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.routeManagementBooking`: Exposes CRUD operations for the **RouteManagementBooking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RouteManagementBookings
    * const routeManagementBookings = await prisma.routeManagementBooking.findMany()
    * ```
    */
  get routeManagementBooking(): Prisma.RouteManagementBookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.routeManagement`: Exposes CRUD operations for the **RouteManagement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RouteManagements
    * const routeManagements = await prisma.routeManagement.findMany()
    * ```
    */
  get routeManagement(): Prisma.RouteManagementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.driver`: Exposes CRUD operations for the **Driver** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drivers
    * const drivers = await prisma.driver.findMany()
    * ```
    */
  get driver(): Prisma.DriverDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicle`: Exposes CRUD operations for the **Vehicle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicles
    * const vehicles = await prisma.vehicle.findMany()
    * ```
    */
  get vehicle(): Prisma.VehicleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicleType`: Exposes CRUD operations for the **VehicleType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VehicleTypes
    * const vehicleTypes = await prisma.vehicleType.findMany()
    * ```
    */
  get vehicleType(): Prisma.VehicleTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendor`: Exposes CRUD operations for the **Vendor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendors
    * const vendors = await prisma.vendor.findMany()
    * ```
    */
  get vendor(): Prisma.VendorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendorUser`: Exposes CRUD operations for the **VendorUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorUsers
    * const vendorUsers = await prisma.vendorUser.findMany()
    * ```
    */
  get vendorUser(): Prisma.VendorUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cutoff`: Exposes CRUD operations for the **Cutoff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cutoffs
    * const cutoffs = await prisma.cutoff.findMany()
    * ```
    */
  get cutoff(): Prisma.CutoffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shift`: Exposes CRUD operations for the **Shift** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shifts
    * const shifts = await prisma.shift.findMany()
    * ```
    */
  get shift(): Prisma.ShiftDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.weekoffConfig`: Exposes CRUD operations for the **WeekoffConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WeekoffConfigs
    * const weekoffConfigs = await prisma.weekoffConfig.findMany()
    * ```
    */
  get weekoffConfig(): Prisma.WeekoffConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.policy`: Exposes CRUD operations for the **Policy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Policies
    * const policies = await prisma.policy.findMany()
    * ```
    */
  get policy(): Prisma.PolicyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.policyPermission`: Exposes CRUD operations for the **PolicyPermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PolicyPermissions
    * const policyPermissions = await prisma.policyPermission.findMany()
    * ```
    */
  get policyPermission(): Prisma.PolicyPermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rolePolicy`: Exposes CRUD operations for the **RolePolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePolicies
    * const rolePolicies = await prisma.rolePolicy.findMany()
    * ```
    */
  get rolePolicy(): Prisma.RolePolicyDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Booking: 'Booking',
    Route: 'Route',
    RouteManagementBooking: 'RouteManagementBooking',
    RouteManagement: 'RouteManagement',
    Driver: 'Driver',
    Vehicle: 'Vehicle',
    VehicleType: 'VehicleType',
    Vendor: 'Vendor',
    VendorUser: 'VendorUser',
    Cutoff: 'Cutoff',
    Employee: 'Employee',
    Shift: 'Shift',
    Team: 'Team',
    Tenant: 'Tenant',
    WeekoffConfig: 'WeekoffConfig',
    Admin: 'Admin',
    Permission: 'Permission',
    Policy: 'Policy',
    PolicyPermission: 'PolicyPermission',
    Role: 'Role',
    RolePolicy: 'RolePolicy'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "booking" | "route" | "routeManagementBooking" | "routeManagement" | "driver" | "vehicle" | "vehicleType" | "vendor" | "vendorUser" | "cutoff" | "employee" | "shift" | "team" | "tenant" | "weekoffConfig" | "admin" | "permission" | "policy" | "policyPermission" | "role" | "rolePolicy"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      Route: {
        payload: Prisma.$RoutePayload<ExtArgs>
        fields: Prisma.RouteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RouteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RouteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          findFirst: {
            args: Prisma.RouteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RouteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          findMany: {
            args: Prisma.RouteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>[]
          }
          create: {
            args: Prisma.RouteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          createMany: {
            args: Prisma.RouteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RouteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>[]
          }
          delete: {
            args: Prisma.RouteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          update: {
            args: Prisma.RouteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          deleteMany: {
            args: Prisma.RouteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RouteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RouteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>[]
          }
          upsert: {
            args: Prisma.RouteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          aggregate: {
            args: Prisma.RouteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoute>
          }
          groupBy: {
            args: Prisma.RouteGroupByArgs<ExtArgs>
            result: $Utils.Optional<RouteGroupByOutputType>[]
          }
          count: {
            args: Prisma.RouteCountArgs<ExtArgs>
            result: $Utils.Optional<RouteCountAggregateOutputType> | number
          }
        }
      }
      RouteManagementBooking: {
        payload: Prisma.$RouteManagementBookingPayload<ExtArgs>
        fields: Prisma.RouteManagementBookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RouteManagementBookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteManagementBookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RouteManagementBookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteManagementBookingPayload>
          }
          findFirst: {
            args: Prisma.RouteManagementBookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteManagementBookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RouteManagementBookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteManagementBookingPayload>
          }
          findMany: {
            args: Prisma.RouteManagementBookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteManagementBookingPayload>[]
          }
          create: {
            args: Prisma.RouteManagementBookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteManagementBookingPayload>
          }
          createMany: {
            args: Prisma.RouteManagementBookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RouteManagementBookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteManagementBookingPayload>[]
          }
          delete: {
            args: Prisma.RouteManagementBookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteManagementBookingPayload>
          }
          update: {
            args: Prisma.RouteManagementBookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteManagementBookingPayload>
          }
          deleteMany: {
            args: Prisma.RouteManagementBookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RouteManagementBookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RouteManagementBookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteManagementBookingPayload>[]
          }
          upsert: {
            args: Prisma.RouteManagementBookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteManagementBookingPayload>
          }
          aggregate: {
            args: Prisma.RouteManagementBookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRouteManagementBooking>
          }
          groupBy: {
            args: Prisma.RouteManagementBookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<RouteManagementBookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.RouteManagementBookingCountArgs<ExtArgs>
            result: $Utils.Optional<RouteManagementBookingCountAggregateOutputType> | number
          }
        }
      }
      RouteManagement: {
        payload: Prisma.$RouteManagementPayload<ExtArgs>
        fields: Prisma.RouteManagementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RouteManagementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteManagementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RouteManagementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteManagementPayload>
          }
          findFirst: {
            args: Prisma.RouteManagementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteManagementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RouteManagementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteManagementPayload>
          }
          findMany: {
            args: Prisma.RouteManagementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteManagementPayload>[]
          }
          create: {
            args: Prisma.RouteManagementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteManagementPayload>
          }
          createMany: {
            args: Prisma.RouteManagementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RouteManagementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteManagementPayload>[]
          }
          delete: {
            args: Prisma.RouteManagementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteManagementPayload>
          }
          update: {
            args: Prisma.RouteManagementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteManagementPayload>
          }
          deleteMany: {
            args: Prisma.RouteManagementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RouteManagementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RouteManagementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteManagementPayload>[]
          }
          upsert: {
            args: Prisma.RouteManagementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteManagementPayload>
          }
          aggregate: {
            args: Prisma.RouteManagementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRouteManagement>
          }
          groupBy: {
            args: Prisma.RouteManagementGroupByArgs<ExtArgs>
            result: $Utils.Optional<RouteManagementGroupByOutputType>[]
          }
          count: {
            args: Prisma.RouteManagementCountArgs<ExtArgs>
            result: $Utils.Optional<RouteManagementCountAggregateOutputType> | number
          }
        }
      }
      Driver: {
        payload: Prisma.$DriverPayload<ExtArgs>
        fields: Prisma.DriverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DriverFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DriverFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          findFirst: {
            args: Prisma.DriverFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DriverFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          findMany: {
            args: Prisma.DriverFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>[]
          }
          create: {
            args: Prisma.DriverCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          createMany: {
            args: Prisma.DriverCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DriverCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>[]
          }
          delete: {
            args: Prisma.DriverDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          update: {
            args: Prisma.DriverUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          deleteMany: {
            args: Prisma.DriverDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DriverUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DriverUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>[]
          }
          upsert: {
            args: Prisma.DriverUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          aggregate: {
            args: Prisma.DriverAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDriver>
          }
          groupBy: {
            args: Prisma.DriverGroupByArgs<ExtArgs>
            result: $Utils.Optional<DriverGroupByOutputType>[]
          }
          count: {
            args: Prisma.DriverCountArgs<ExtArgs>
            result: $Utils.Optional<DriverCountAggregateOutputType> | number
          }
        }
      }
      Vehicle: {
        payload: Prisma.$VehiclePayload<ExtArgs>
        fields: Prisma.VehicleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findFirst: {
            args: Prisma.VehicleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findMany: {
            args: Prisma.VehicleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          create: {
            args: Prisma.VehicleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          createMany: {
            args: Prisma.VehicleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          delete: {
            args: Prisma.VehicleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          update: {
            args: Prisma.VehicleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          deleteMany: {
            args: Prisma.VehicleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VehicleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          upsert: {
            args: Prisma.VehicleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          aggregate: {
            args: Prisma.VehicleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicle>
          }
          groupBy: {
            args: Prisma.VehicleGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleCountAggregateOutputType> | number
          }
        }
      }
      VehicleType: {
        payload: Prisma.$VehicleTypePayload<ExtArgs>
        fields: Prisma.VehicleTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTypePayload>
          }
          findFirst: {
            args: Prisma.VehicleTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTypePayload>
          }
          findMany: {
            args: Prisma.VehicleTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTypePayload>[]
          }
          create: {
            args: Prisma.VehicleTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTypePayload>
          }
          createMany: {
            args: Prisma.VehicleTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTypePayload>[]
          }
          delete: {
            args: Prisma.VehicleTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTypePayload>
          }
          update: {
            args: Prisma.VehicleTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTypePayload>
          }
          deleteMany: {
            args: Prisma.VehicleTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VehicleTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTypePayload>[]
          }
          upsert: {
            args: Prisma.VehicleTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTypePayload>
          }
          aggregate: {
            args: Prisma.VehicleTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicleType>
          }
          groupBy: {
            args: Prisma.VehicleTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleTypeCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleTypeCountAggregateOutputType> | number
          }
        }
      }
      Vendor: {
        payload: Prisma.$VendorPayload<ExtArgs>
        fields: Prisma.VendorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findFirst: {
            args: Prisma.VendorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findMany: {
            args: Prisma.VendorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          create: {
            args: Prisma.VendorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          createMany: {
            args: Prisma.VendorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          delete: {
            args: Prisma.VendorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          update: {
            args: Prisma.VendorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          deleteMany: {
            args: Prisma.VendorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          upsert: {
            args: Prisma.VendorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          aggregate: {
            args: Prisma.VendorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendor>
          }
          groupBy: {
            args: Prisma.VendorGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorCountArgs<ExtArgs>
            result: $Utils.Optional<VendorCountAggregateOutputType> | number
          }
        }
      }
      VendorUser: {
        payload: Prisma.$VendorUserPayload<ExtArgs>
        fields: Prisma.VendorUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorUserPayload>
          }
          findFirst: {
            args: Prisma.VendorUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorUserPayload>
          }
          findMany: {
            args: Prisma.VendorUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorUserPayload>[]
          }
          create: {
            args: Prisma.VendorUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorUserPayload>
          }
          createMany: {
            args: Prisma.VendorUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorUserPayload>[]
          }
          delete: {
            args: Prisma.VendorUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorUserPayload>
          }
          update: {
            args: Prisma.VendorUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorUserPayload>
          }
          deleteMany: {
            args: Prisma.VendorUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorUserPayload>[]
          }
          upsert: {
            args: Prisma.VendorUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorUserPayload>
          }
          aggregate: {
            args: Prisma.VendorUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendorUser>
          }
          groupBy: {
            args: Prisma.VendorUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorUserCountArgs<ExtArgs>
            result: $Utils.Optional<VendorUserCountAggregateOutputType> | number
          }
        }
      }
      Cutoff: {
        payload: Prisma.$CutoffPayload<ExtArgs>
        fields: Prisma.CutoffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CutoffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CutoffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CutoffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CutoffPayload>
          }
          findFirst: {
            args: Prisma.CutoffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CutoffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CutoffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CutoffPayload>
          }
          findMany: {
            args: Prisma.CutoffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CutoffPayload>[]
          }
          create: {
            args: Prisma.CutoffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CutoffPayload>
          }
          createMany: {
            args: Prisma.CutoffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CutoffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CutoffPayload>[]
          }
          delete: {
            args: Prisma.CutoffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CutoffPayload>
          }
          update: {
            args: Prisma.CutoffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CutoffPayload>
          }
          deleteMany: {
            args: Prisma.CutoffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CutoffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CutoffUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CutoffPayload>[]
          }
          upsert: {
            args: Prisma.CutoffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CutoffPayload>
          }
          aggregate: {
            args: Prisma.CutoffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCutoff>
          }
          groupBy: {
            args: Prisma.CutoffGroupByArgs<ExtArgs>
            result: $Utils.Optional<CutoffGroupByOutputType>[]
          }
          count: {
            args: Prisma.CutoffCountArgs<ExtArgs>
            result: $Utils.Optional<CutoffCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      Shift: {
        payload: Prisma.$ShiftPayload<ExtArgs>
        fields: Prisma.ShiftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShiftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShiftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          findFirst: {
            args: Prisma.ShiftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShiftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          findMany: {
            args: Prisma.ShiftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          create: {
            args: Prisma.ShiftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          createMany: {
            args: Prisma.ShiftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShiftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          delete: {
            args: Prisma.ShiftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          update: {
            args: Prisma.ShiftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          deleteMany: {
            args: Prisma.ShiftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShiftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShiftUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          upsert: {
            args: Prisma.ShiftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          aggregate: {
            args: Prisma.ShiftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShift>
          }
          groupBy: {
            args: Prisma.ShiftGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShiftGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShiftCountArgs<ExtArgs>
            result: $Utils.Optional<ShiftCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      WeekoffConfig: {
        payload: Prisma.$WeekoffConfigPayload<ExtArgs>
        fields: Prisma.WeekoffConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeekoffConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekoffConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeekoffConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekoffConfigPayload>
          }
          findFirst: {
            args: Prisma.WeekoffConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekoffConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeekoffConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekoffConfigPayload>
          }
          findMany: {
            args: Prisma.WeekoffConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekoffConfigPayload>[]
          }
          create: {
            args: Prisma.WeekoffConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekoffConfigPayload>
          }
          createMany: {
            args: Prisma.WeekoffConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeekoffConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekoffConfigPayload>[]
          }
          delete: {
            args: Prisma.WeekoffConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekoffConfigPayload>
          }
          update: {
            args: Prisma.WeekoffConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekoffConfigPayload>
          }
          deleteMany: {
            args: Prisma.WeekoffConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeekoffConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WeekoffConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekoffConfigPayload>[]
          }
          upsert: {
            args: Prisma.WeekoffConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekoffConfigPayload>
          }
          aggregate: {
            args: Prisma.WeekoffConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeekoffConfig>
          }
          groupBy: {
            args: Prisma.WeekoffConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeekoffConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeekoffConfigCountArgs<ExtArgs>
            result: $Utils.Optional<WeekoffConfigCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      Policy: {
        payload: Prisma.$PolicyPayload<ExtArgs>
        fields: Prisma.PolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          findFirst: {
            args: Prisma.PolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          findMany: {
            args: Prisma.PolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>[]
          }
          create: {
            args: Prisma.PolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          createMany: {
            args: Prisma.PolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PolicyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>[]
          }
          delete: {
            args: Prisma.PolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          update: {
            args: Prisma.PolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          deleteMany: {
            args: Prisma.PolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PolicyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>[]
          }
          upsert: {
            args: Prisma.PolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          aggregate: {
            args: Prisma.PolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePolicy>
          }
          groupBy: {
            args: Prisma.PolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PolicyCountArgs<ExtArgs>
            result: $Utils.Optional<PolicyCountAggregateOutputType> | number
          }
        }
      }
      PolicyPermission: {
        payload: Prisma.$PolicyPermissionPayload<ExtArgs>
        fields: Prisma.PolicyPermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PolicyPermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PolicyPermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPermissionPayload>
          }
          findFirst: {
            args: Prisma.PolicyPermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PolicyPermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPermissionPayload>
          }
          findMany: {
            args: Prisma.PolicyPermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPermissionPayload>[]
          }
          create: {
            args: Prisma.PolicyPermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPermissionPayload>
          }
          createMany: {
            args: Prisma.PolicyPermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PolicyPermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPermissionPayload>[]
          }
          delete: {
            args: Prisma.PolicyPermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPermissionPayload>
          }
          update: {
            args: Prisma.PolicyPermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPermissionPayload>
          }
          deleteMany: {
            args: Prisma.PolicyPermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PolicyPermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PolicyPermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPermissionPayload>[]
          }
          upsert: {
            args: Prisma.PolicyPermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPermissionPayload>
          }
          aggregate: {
            args: Prisma.PolicyPermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePolicyPermission>
          }
          groupBy: {
            args: Prisma.PolicyPermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PolicyPermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PolicyPermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PolicyPermissionCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      RolePolicy: {
        payload: Prisma.$RolePolicyPayload<ExtArgs>
        fields: Prisma.RolePolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePolicyPayload>
          }
          findFirst: {
            args: Prisma.RolePolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePolicyPayload>
          }
          findMany: {
            args: Prisma.RolePolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePolicyPayload>[]
          }
          create: {
            args: Prisma.RolePolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePolicyPayload>
          }
          createMany: {
            args: Prisma.RolePolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolePolicyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePolicyPayload>[]
          }
          delete: {
            args: Prisma.RolePolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePolicyPayload>
          }
          update: {
            args: Prisma.RolePolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePolicyPayload>
          }
          deleteMany: {
            args: Prisma.RolePolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RolePolicyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePolicyPayload>[]
          }
          upsert: {
            args: Prisma.RolePolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePolicyPayload>
          }
          aggregate: {
            args: Prisma.RolePolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePolicy>
          }
          groupBy: {
            args: Prisma.RolePolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePolicyCountArgs<ExtArgs>
            result: $Utils.Optional<RolePolicyCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    booking?: BookingOmit
    route?: RouteOmit
    routeManagementBooking?: RouteManagementBookingOmit
    routeManagement?: RouteManagementOmit
    driver?: DriverOmit
    vehicle?: VehicleOmit
    vehicleType?: VehicleTypeOmit
    vendor?: VendorOmit
    vendorUser?: VendorUserOmit
    cutoff?: CutoffOmit
    employee?: EmployeeOmit
    shift?: ShiftOmit
    team?: TeamOmit
    tenant?: TenantOmit
    weekoffConfig?: WeekoffConfigOmit
    admin?: AdminOmit
    permission?: PermissionOmit
    policy?: PolicyOmit
    policyPermission?: PolicyPermissionOmit
    role?: RoleOmit
    rolePolicy?: RolePolicyOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type RouteManagementCountOutputType
   */

  export type RouteManagementCountOutputType = {
    route_management_bookings: number
  }

  export type RouteManagementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    route_management_bookings?: boolean | RouteManagementCountOutputTypeCountRoute_management_bookingsArgs
  }

  // Custom InputTypes
  /**
   * RouteManagementCountOutputType without action
   */
  export type RouteManagementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteManagementCountOutputType
     */
    select?: RouteManagementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RouteManagementCountOutputType without action
   */
  export type RouteManagementCountOutputTypeCountRoute_management_bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteManagementBookingWhereInput
  }


  /**
   * Count Type DriverCountOutputType
   */

  export type DriverCountOutputType = {
    vehicles: number
  }

  export type DriverCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicles?: boolean | DriverCountOutputTypeCountVehiclesArgs
  }

  // Custom InputTypes
  /**
   * DriverCountOutputType without action
   */
  export type DriverCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverCountOutputType
     */
    select?: DriverCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DriverCountOutputType without action
   */
  export type DriverCountOutputTypeCountVehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleWhereInput
  }


  /**
   * Count Type VehicleTypeCountOutputType
   */

  export type VehicleTypeCountOutputType = {
    vehicles: number
  }

  export type VehicleTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicles?: boolean | VehicleTypeCountOutputTypeCountVehiclesArgs
  }

  // Custom InputTypes
  /**
   * VehicleTypeCountOutputType without action
   */
  export type VehicleTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleTypeCountOutputType
     */
    select?: VehicleTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VehicleTypeCountOutputType without action
   */
  export type VehicleTypeCountOutputTypeCountVehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleWhereInput
  }


  /**
   * Count Type VendorCountOutputType
   */

  export type VendorCountOutputType = {
    drivers: number
    vehicle_types: number
    vehicles: number
    vendor_users: number
  }

  export type VendorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    drivers?: boolean | VendorCountOutputTypeCountDriversArgs
    vehicle_types?: boolean | VendorCountOutputTypeCountVehicle_typesArgs
    vehicles?: boolean | VendorCountOutputTypeCountVehiclesArgs
    vendor_users?: boolean | VendorCountOutputTypeCountVendor_usersArgs
  }

  // Custom InputTypes
  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCountOutputType
     */
    select?: VendorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountDriversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountVehicle_typesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleTypeWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountVehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountVendor_usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorUserWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    bookings: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | EmployeeCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }


  /**
   * Count Type ShiftCountOutputType
   */

  export type ShiftCountOutputType = {
    bookings: number
  }

  export type ShiftCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | ShiftCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * ShiftCountOutputType without action
   */
  export type ShiftCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftCountOutputType
     */
    select?: ShiftCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShiftCountOutputType without action
   */
  export type ShiftCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    employees: number
    bookings: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | TeamCountOutputTypeCountEmployeesArgs
    bookings?: boolean | TeamCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    teams: number
    employees: number
    shifts: number
    bookings: number
    policies: number
    vendors: number
    roles: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teams?: boolean | TenantCountOutputTypeCountTeamsArgs
    employees?: boolean | TenantCountOutputTypeCountEmployeesArgs
    shifts?: boolean | TenantCountOutputTypeCountShiftsArgs
    bookings?: boolean | TenantCountOutputTypeCountBookingsArgs
    policies?: boolean | TenantCountOutputTypeCountPoliciesArgs
    vendors?: boolean | TenantCountOutputTypeCountVendorsArgs
    roles?: boolean | TenantCountOutputTypeCountRolesArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountVendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    policy_permissions: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    policy_permissions?: boolean | PermissionCountOutputTypeCountPolicy_permissionsArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountPolicy_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyPermissionWhereInput
  }


  /**
   * Count Type PolicyCountOutputType
   */

  export type PolicyCountOutputType = {
    policy_permissions: number
    role_policies: number
  }

  export type PolicyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    policy_permissions?: boolean | PolicyCountOutputTypeCountPolicy_permissionsArgs
    role_policies?: boolean | PolicyCountOutputTypeCountRole_policiesArgs
  }

  // Custom InputTypes
  /**
   * PolicyCountOutputType without action
   */
  export type PolicyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyCountOutputType
     */
    select?: PolicyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PolicyCountOutputType without action
   */
  export type PolicyCountOutputTypeCountPolicy_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyPermissionWhereInput
  }

  /**
   * PolicyCountOutputType without action
   */
  export type PolicyCountOutputTypeCountRole_policiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePolicyWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    role_policies: number
    admins: number
    vendor_users: number
    employees: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role_policies?: boolean | RoleCountOutputTypeCountRole_policiesArgs
    admins?: boolean | RoleCountOutputTypeCountAdminsArgs
    vendor_users?: boolean | RoleCountOutputTypeCountVendor_usersArgs
    employees?: boolean | RoleCountOutputTypeCountEmployeesArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountRole_policiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePolicyWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountVendor_usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorUserWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    booking_id: number | null
    employee_id: number | null
    shift_id: number | null
    team_id: number | null
    pickup_latitude: number | null
    pickup_longitude: number | null
    drop_latitude: number | null
    drop_longitude: number | null
  }

  export type BookingSumAggregateOutputType = {
    booking_id: number | null
    employee_id: number | null
    shift_id: number | null
    team_id: number | null
    pickup_latitude: number | null
    pickup_longitude: number | null
    drop_latitude: number | null
    drop_longitude: number | null
  }

  export type BookingMinAggregateOutputType = {
    booking_id: number | null
    tenant_id: string | null
    employee_id: number | null
    employee_code: string | null
    shift_id: number | null
    team_id: number | null
    booking_date: Date | null
    pickup_latitude: number | null
    pickup_longitude: number | null
    pickup_location: string | null
    drop_latitude: number | null
    drop_longitude: number | null
    drop_location: string | null
    status: $Enums.BookingStatusEnum | null
    reason: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BookingMaxAggregateOutputType = {
    booking_id: number | null
    tenant_id: string | null
    employee_id: number | null
    employee_code: string | null
    shift_id: number | null
    team_id: number | null
    booking_date: Date | null
    pickup_latitude: number | null
    pickup_longitude: number | null
    pickup_location: string | null
    drop_latitude: number | null
    drop_longitude: number | null
    drop_location: string | null
    status: $Enums.BookingStatusEnum | null
    reason: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BookingCountAggregateOutputType = {
    booking_id: number
    tenant_id: number
    employee_id: number
    employee_code: number
    shift_id: number
    team_id: number
    booking_date: number
    pickup_latitude: number
    pickup_longitude: number
    pickup_location: number
    drop_latitude: number
    drop_longitude: number
    drop_location: number
    status: number
    reason: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    booking_id?: true
    employee_id?: true
    shift_id?: true
    team_id?: true
    pickup_latitude?: true
    pickup_longitude?: true
    drop_latitude?: true
    drop_longitude?: true
  }

  export type BookingSumAggregateInputType = {
    booking_id?: true
    employee_id?: true
    shift_id?: true
    team_id?: true
    pickup_latitude?: true
    pickup_longitude?: true
    drop_latitude?: true
    drop_longitude?: true
  }

  export type BookingMinAggregateInputType = {
    booking_id?: true
    tenant_id?: true
    employee_id?: true
    employee_code?: true
    shift_id?: true
    team_id?: true
    booking_date?: true
    pickup_latitude?: true
    pickup_longitude?: true
    pickup_location?: true
    drop_latitude?: true
    drop_longitude?: true
    drop_location?: true
    status?: true
    reason?: true
    created_at?: true
    updated_at?: true
  }

  export type BookingMaxAggregateInputType = {
    booking_id?: true
    tenant_id?: true
    employee_id?: true
    employee_code?: true
    shift_id?: true
    team_id?: true
    booking_date?: true
    pickup_latitude?: true
    pickup_longitude?: true
    pickup_location?: true
    drop_latitude?: true
    drop_longitude?: true
    drop_location?: true
    status?: true
    reason?: true
    created_at?: true
    updated_at?: true
  }

  export type BookingCountAggregateInputType = {
    booking_id?: true
    tenant_id?: true
    employee_id?: true
    employee_code?: true
    shift_id?: true
    team_id?: true
    booking_date?: true
    pickup_latitude?: true
    pickup_longitude?: true
    pickup_location?: true
    drop_latitude?: true
    drop_longitude?: true
    drop_location?: true
    status?: true
    reason?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    booking_id: number
    tenant_id: string
    employee_id: number
    employee_code: string
    shift_id: number | null
    team_id: number | null
    booking_date: Date
    pickup_latitude: number | null
    pickup_longitude: number | null
    pickup_location: string | null
    drop_latitude: number | null
    drop_longitude: number | null
    drop_location: string | null
    status: $Enums.BookingStatusEnum
    reason: string | null
    created_at: Date
    updated_at: Date
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    booking_id?: boolean
    tenant_id?: boolean
    employee_id?: boolean
    employee_code?: boolean
    shift_id?: boolean
    team_id?: boolean
    booking_date?: boolean
    pickup_latitude?: boolean
    pickup_longitude?: boolean
    pickup_location?: boolean
    drop_latitude?: boolean
    drop_longitude?: boolean
    drop_location?: boolean
    status?: boolean
    reason?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    shift?: boolean | Booking$shiftArgs<ExtArgs>
    team?: boolean | Booking$teamArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    booking_id?: boolean
    tenant_id?: boolean
    employee_id?: boolean
    employee_code?: boolean
    shift_id?: boolean
    team_id?: boolean
    booking_date?: boolean
    pickup_latitude?: boolean
    pickup_longitude?: boolean
    pickup_location?: boolean
    drop_latitude?: boolean
    drop_longitude?: boolean
    drop_location?: boolean
    status?: boolean
    reason?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    shift?: boolean | Booking$shiftArgs<ExtArgs>
    team?: boolean | Booking$teamArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    booking_id?: boolean
    tenant_id?: boolean
    employee_id?: boolean
    employee_code?: boolean
    shift_id?: boolean
    team_id?: boolean
    booking_date?: boolean
    pickup_latitude?: boolean
    pickup_longitude?: boolean
    pickup_location?: boolean
    drop_latitude?: boolean
    drop_longitude?: boolean
    drop_location?: boolean
    status?: boolean
    reason?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    shift?: boolean | Booking$shiftArgs<ExtArgs>
    team?: boolean | Booking$teamArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    booking_id?: boolean
    tenant_id?: boolean
    employee_id?: boolean
    employee_code?: boolean
    shift_id?: boolean
    team_id?: boolean
    booking_date?: boolean
    pickup_latitude?: boolean
    pickup_longitude?: boolean
    pickup_location?: boolean
    drop_latitude?: boolean
    drop_longitude?: boolean
    drop_location?: boolean
    status?: boolean
    reason?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type BookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"booking_id" | "tenant_id" | "employee_id" | "employee_code" | "shift_id" | "team_id" | "booking_date" | "pickup_latitude" | "pickup_longitude" | "pickup_location" | "drop_latitude" | "drop_longitude" | "drop_location" | "status" | "reason" | "created_at" | "updated_at", ExtArgs["result"]["booking"]>
  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    shift?: boolean | Booking$shiftArgs<ExtArgs>
    team?: boolean | Booking$teamArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    shift?: boolean | Booking$shiftArgs<ExtArgs>
    team?: boolean | Booking$teamArgs<ExtArgs>
  }
  export type BookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    shift?: boolean | Booking$shiftArgs<ExtArgs>
    team?: boolean | Booking$teamArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      employee: Prisma.$EmployeePayload<ExtArgs>
      shift: Prisma.$ShiftPayload<ExtArgs> | null
      team: Prisma.$TeamPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      booking_id: number
      tenant_id: string
      employee_id: number
      employee_code: string
      shift_id: number | null
      team_id: number | null
      booking_date: Date
      pickup_latitude: number | null
      pickup_longitude: number | null
      pickup_location: string | null
      drop_latitude: number | null
      drop_longitude: number | null
      drop_location: string | null
      status: $Enums.BookingStatusEnum
      reason: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `booking_id`
     * const bookingWithBooking_idOnly = await prisma.booking.findMany({ select: { booking_id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `booking_id`
     * const bookingWithBooking_idOnly = await prisma.booking.createManyAndReturn({
     *   select: { booking_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings and returns the data updated in the database.
     * @param {BookingUpdateManyAndReturnArgs} args - Arguments to update many Bookings.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bookings and only return the `booking_id`
     * const bookingWithBooking_idOnly = await prisma.booking.updateManyAndReturn({
     *   select: { booking_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shift<T extends Booking$shiftArgs<ExtArgs> = {}>(args?: Subset<T, Booking$shiftArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    team<T extends Booking$teamArgs<ExtArgs> = {}>(args?: Subset<T, Booking$teamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */
  interface BookingFieldRefs {
    readonly booking_id: FieldRef<"Booking", 'Int'>
    readonly tenant_id: FieldRef<"Booking", 'String'>
    readonly employee_id: FieldRef<"Booking", 'Int'>
    readonly employee_code: FieldRef<"Booking", 'String'>
    readonly shift_id: FieldRef<"Booking", 'Int'>
    readonly team_id: FieldRef<"Booking", 'Int'>
    readonly booking_date: FieldRef<"Booking", 'DateTime'>
    readonly pickup_latitude: FieldRef<"Booking", 'Float'>
    readonly pickup_longitude: FieldRef<"Booking", 'Float'>
    readonly pickup_location: FieldRef<"Booking", 'String'>
    readonly drop_latitude: FieldRef<"Booking", 'Float'>
    readonly drop_longitude: FieldRef<"Booking", 'Float'>
    readonly drop_location: FieldRef<"Booking", 'String'>
    readonly status: FieldRef<"Booking", 'BookingStatusEnum'>
    readonly reason: FieldRef<"Booking", 'String'>
    readonly created_at: FieldRef<"Booking", 'DateTime'>
    readonly updated_at: FieldRef<"Booking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
  }

  /**
   * Booking updateManyAndReturn
   */
  export type BookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to delete.
     */
    limit?: number
  }

  /**
   * Booking.shift
   */
  export type Booking$shiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    where?: ShiftWhereInput
  }

  /**
   * Booking.team
   */
  export type Booking$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model Route
   */

  export type AggregateRoute = {
    _count: RouteCountAggregateOutputType | null
    _avg: RouteAvgAggregateOutputType | null
    _sum: RouteSumAggregateOutputType | null
    _min: RouteMinAggregateOutputType | null
    _max: RouteMaxAggregateOutputType | null
  }

  export type RouteAvgAggregateOutputType = {
    id: number | null
  }

  export type RouteSumAggregateOutputType = {
    id: number | null
  }

  export type RouteMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RouteMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RouteCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type RouteAvgAggregateInputType = {
    id?: true
  }

  export type RouteSumAggregateInputType = {
    id?: true
  }

  export type RouteMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type RouteMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type RouteCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type RouteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Route to aggregate.
     */
    where?: RouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routes to fetch.
     */
    orderBy?: RouteOrderByWithRelationInput | RouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Routes
    **/
    _count?: true | RouteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RouteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RouteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RouteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RouteMaxAggregateInputType
  }

  export type GetRouteAggregateType<T extends RouteAggregateArgs> = {
        [P in keyof T & keyof AggregateRoute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoute[P]>
      : GetScalarType<T[P], AggregateRoute[P]>
  }




  export type RouteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteWhereInput
    orderBy?: RouteOrderByWithAggregationInput | RouteOrderByWithAggregationInput[]
    by: RouteScalarFieldEnum[] | RouteScalarFieldEnum
    having?: RouteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RouteCountAggregateInputType | true
    _avg?: RouteAvgAggregateInputType
    _sum?: RouteSumAggregateInputType
    _min?: RouteMinAggregateInputType
    _max?: RouteMaxAggregateInputType
  }

  export type RouteGroupByOutputType = {
    id: number
    created_at: Date
    updated_at: Date
    _count: RouteCountAggregateOutputType | null
    _avg: RouteAvgAggregateOutputType | null
    _sum: RouteSumAggregateOutputType | null
    _min: RouteMinAggregateOutputType | null
    _max: RouteMaxAggregateOutputType | null
  }

  type GetRouteGroupByPayload<T extends RouteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RouteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RouteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RouteGroupByOutputType[P]>
            : GetScalarType<T[P], RouteGroupByOutputType[P]>
        }
      >
    >


  export type RouteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["route"]>

  export type RouteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["route"]>

  export type RouteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["route"]>

  export type RouteSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type RouteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at", ExtArgs["result"]["route"]>

  export type $RoutePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Route"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["route"]>
    composites: {}
  }

  type RouteGetPayload<S extends boolean | null | undefined | RouteDefaultArgs> = $Result.GetResult<Prisma.$RoutePayload, S>

  type RouteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RouteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RouteCountAggregateInputType | true
    }

  export interface RouteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Route'], meta: { name: 'Route' } }
    /**
     * Find zero or one Route that matches the filter.
     * @param {RouteFindUniqueArgs} args - Arguments to find a Route
     * @example
     * // Get one Route
     * const route = await prisma.route.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RouteFindUniqueArgs>(args: SelectSubset<T, RouteFindUniqueArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Route that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RouteFindUniqueOrThrowArgs} args - Arguments to find a Route
     * @example
     * // Get one Route
     * const route = await prisma.route.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RouteFindUniqueOrThrowArgs>(args: SelectSubset<T, RouteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Route that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFindFirstArgs} args - Arguments to find a Route
     * @example
     * // Get one Route
     * const route = await prisma.route.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RouteFindFirstArgs>(args?: SelectSubset<T, RouteFindFirstArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Route that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFindFirstOrThrowArgs} args - Arguments to find a Route
     * @example
     * // Get one Route
     * const route = await prisma.route.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RouteFindFirstOrThrowArgs>(args?: SelectSubset<T, RouteFindFirstOrThrowArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Routes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Routes
     * const routes = await prisma.route.findMany()
     * 
     * // Get first 10 Routes
     * const routes = await prisma.route.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const routeWithIdOnly = await prisma.route.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RouteFindManyArgs>(args?: SelectSubset<T, RouteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Route.
     * @param {RouteCreateArgs} args - Arguments to create a Route.
     * @example
     * // Create one Route
     * const Route = await prisma.route.create({
     *   data: {
     *     // ... data to create a Route
     *   }
     * })
     * 
     */
    create<T extends RouteCreateArgs>(args: SelectSubset<T, RouteCreateArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Routes.
     * @param {RouteCreateManyArgs} args - Arguments to create many Routes.
     * @example
     * // Create many Routes
     * const route = await prisma.route.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RouteCreateManyArgs>(args?: SelectSubset<T, RouteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Routes and returns the data saved in the database.
     * @param {RouteCreateManyAndReturnArgs} args - Arguments to create many Routes.
     * @example
     * // Create many Routes
     * const route = await prisma.route.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Routes and only return the `id`
     * const routeWithIdOnly = await prisma.route.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RouteCreateManyAndReturnArgs>(args?: SelectSubset<T, RouteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Route.
     * @param {RouteDeleteArgs} args - Arguments to delete one Route.
     * @example
     * // Delete one Route
     * const Route = await prisma.route.delete({
     *   where: {
     *     // ... filter to delete one Route
     *   }
     * })
     * 
     */
    delete<T extends RouteDeleteArgs>(args: SelectSubset<T, RouteDeleteArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Route.
     * @param {RouteUpdateArgs} args - Arguments to update one Route.
     * @example
     * // Update one Route
     * const route = await prisma.route.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RouteUpdateArgs>(args: SelectSubset<T, RouteUpdateArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Routes.
     * @param {RouteDeleteManyArgs} args - Arguments to filter Routes to delete.
     * @example
     * // Delete a few Routes
     * const { count } = await prisma.route.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RouteDeleteManyArgs>(args?: SelectSubset<T, RouteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Routes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Routes
     * const route = await prisma.route.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RouteUpdateManyArgs>(args: SelectSubset<T, RouteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Routes and returns the data updated in the database.
     * @param {RouteUpdateManyAndReturnArgs} args - Arguments to update many Routes.
     * @example
     * // Update many Routes
     * const route = await prisma.route.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Routes and only return the `id`
     * const routeWithIdOnly = await prisma.route.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RouteUpdateManyAndReturnArgs>(args: SelectSubset<T, RouteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Route.
     * @param {RouteUpsertArgs} args - Arguments to update or create a Route.
     * @example
     * // Update or create a Route
     * const route = await prisma.route.upsert({
     *   create: {
     *     // ... data to create a Route
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Route we want to update
     *   }
     * })
     */
    upsert<T extends RouteUpsertArgs>(args: SelectSubset<T, RouteUpsertArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Routes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteCountArgs} args - Arguments to filter Routes to count.
     * @example
     * // Count the number of Routes
     * const count = await prisma.route.count({
     *   where: {
     *     // ... the filter for the Routes we want to count
     *   }
     * })
    **/
    count<T extends RouteCountArgs>(
      args?: Subset<T, RouteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RouteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Route.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RouteAggregateArgs>(args: Subset<T, RouteAggregateArgs>): Prisma.PrismaPromise<GetRouteAggregateType<T>>

    /**
     * Group by Route.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RouteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RouteGroupByArgs['orderBy'] }
        : { orderBy?: RouteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RouteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRouteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Route model
   */
  readonly fields: RouteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Route.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RouteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Route model
   */
  interface RouteFieldRefs {
    readonly id: FieldRef<"Route", 'Int'>
    readonly created_at: FieldRef<"Route", 'DateTime'>
    readonly updated_at: FieldRef<"Route", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Route findUnique
   */
  export type RouteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Filter, which Route to fetch.
     */
    where: RouteWhereUniqueInput
  }

  /**
   * Route findUniqueOrThrow
   */
  export type RouteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Filter, which Route to fetch.
     */
    where: RouteWhereUniqueInput
  }

  /**
   * Route findFirst
   */
  export type RouteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Filter, which Route to fetch.
     */
    where?: RouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routes to fetch.
     */
    orderBy?: RouteOrderByWithRelationInput | RouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Routes.
     */
    cursor?: RouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Routes.
     */
    distinct?: RouteScalarFieldEnum | RouteScalarFieldEnum[]
  }

  /**
   * Route findFirstOrThrow
   */
  export type RouteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Filter, which Route to fetch.
     */
    where?: RouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routes to fetch.
     */
    orderBy?: RouteOrderByWithRelationInput | RouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Routes.
     */
    cursor?: RouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Routes.
     */
    distinct?: RouteScalarFieldEnum | RouteScalarFieldEnum[]
  }

  /**
   * Route findMany
   */
  export type RouteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Filter, which Routes to fetch.
     */
    where?: RouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routes to fetch.
     */
    orderBy?: RouteOrderByWithRelationInput | RouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Routes.
     */
    cursor?: RouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routes.
     */
    skip?: number
    distinct?: RouteScalarFieldEnum | RouteScalarFieldEnum[]
  }

  /**
   * Route create
   */
  export type RouteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * The data needed to create a Route.
     */
    data: XOR<RouteCreateInput, RouteUncheckedCreateInput>
  }

  /**
   * Route createMany
   */
  export type RouteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Routes.
     */
    data: RouteCreateManyInput | RouteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Route createManyAndReturn
   */
  export type RouteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * The data used to create many Routes.
     */
    data: RouteCreateManyInput | RouteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Route update
   */
  export type RouteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * The data needed to update a Route.
     */
    data: XOR<RouteUpdateInput, RouteUncheckedUpdateInput>
    /**
     * Choose, which Route to update.
     */
    where: RouteWhereUniqueInput
  }

  /**
   * Route updateMany
   */
  export type RouteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Routes.
     */
    data: XOR<RouteUpdateManyMutationInput, RouteUncheckedUpdateManyInput>
    /**
     * Filter which Routes to update
     */
    where?: RouteWhereInput
    /**
     * Limit how many Routes to update.
     */
    limit?: number
  }

  /**
   * Route updateManyAndReturn
   */
  export type RouteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * The data used to update Routes.
     */
    data: XOR<RouteUpdateManyMutationInput, RouteUncheckedUpdateManyInput>
    /**
     * Filter which Routes to update
     */
    where?: RouteWhereInput
    /**
     * Limit how many Routes to update.
     */
    limit?: number
  }

  /**
   * Route upsert
   */
  export type RouteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * The filter to search for the Route to update in case it exists.
     */
    where: RouteWhereUniqueInput
    /**
     * In case the Route found by the `where` argument doesn't exist, create a new Route with this data.
     */
    create: XOR<RouteCreateInput, RouteUncheckedCreateInput>
    /**
     * In case the Route was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RouteUpdateInput, RouteUncheckedUpdateInput>
  }

  /**
   * Route delete
   */
  export type RouteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Filter which Route to delete.
     */
    where: RouteWhereUniqueInput
  }

  /**
   * Route deleteMany
   */
  export type RouteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Routes to delete
     */
    where?: RouteWhereInput
    /**
     * Limit how many Routes to delete.
     */
    limit?: number
  }

  /**
   * Route without action
   */
  export type RouteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
  }


  /**
   * Model RouteManagementBooking
   */

  export type AggregateRouteManagementBooking = {
    _count: RouteManagementBookingCountAggregateOutputType | null
    _avg: RouteManagementBookingAvgAggregateOutputType | null
    _sum: RouteManagementBookingSumAggregateOutputType | null
    _min: RouteManagementBookingMinAggregateOutputType | null
    _max: RouteManagementBookingMaxAggregateOutputType | null
  }

  export type RouteManagementBookingAvgAggregateOutputType = {
    id: number | null
    booking_id: number | null
    stop_order: number | null
    distance_from_previous: number | null
    cumulative_distance: number | null
  }

  export type RouteManagementBookingSumAggregateOutputType = {
    id: number | null
    booking_id: number | null
    stop_order: number | null
    distance_from_previous: number | null
    cumulative_distance: number | null
  }

  export type RouteManagementBookingMinAggregateOutputType = {
    id: number | null
    route_id: string | null
    booking_id: number | null
    stop_order: number | null
    estimated_pickup_time: string | null
    estimated_drop_time: string | null
    distance_from_previous: number | null
    cumulative_distance: number | null
    created_at: Date | null
  }

  export type RouteManagementBookingMaxAggregateOutputType = {
    id: number | null
    route_id: string | null
    booking_id: number | null
    stop_order: number | null
    estimated_pickup_time: string | null
    estimated_drop_time: string | null
    distance_from_previous: number | null
    cumulative_distance: number | null
    created_at: Date | null
  }

  export type RouteManagementBookingCountAggregateOutputType = {
    id: number
    route_id: number
    booking_id: number
    stop_order: number
    estimated_pickup_time: number
    estimated_drop_time: number
    distance_from_previous: number
    cumulative_distance: number
    created_at: number
    _all: number
  }


  export type RouteManagementBookingAvgAggregateInputType = {
    id?: true
    booking_id?: true
    stop_order?: true
    distance_from_previous?: true
    cumulative_distance?: true
  }

  export type RouteManagementBookingSumAggregateInputType = {
    id?: true
    booking_id?: true
    stop_order?: true
    distance_from_previous?: true
    cumulative_distance?: true
  }

  export type RouteManagementBookingMinAggregateInputType = {
    id?: true
    route_id?: true
    booking_id?: true
    stop_order?: true
    estimated_pickup_time?: true
    estimated_drop_time?: true
    distance_from_previous?: true
    cumulative_distance?: true
    created_at?: true
  }

  export type RouteManagementBookingMaxAggregateInputType = {
    id?: true
    route_id?: true
    booking_id?: true
    stop_order?: true
    estimated_pickup_time?: true
    estimated_drop_time?: true
    distance_from_previous?: true
    cumulative_distance?: true
    created_at?: true
  }

  export type RouteManagementBookingCountAggregateInputType = {
    id?: true
    route_id?: true
    booking_id?: true
    stop_order?: true
    estimated_pickup_time?: true
    estimated_drop_time?: true
    distance_from_previous?: true
    cumulative_distance?: true
    created_at?: true
    _all?: true
  }

  export type RouteManagementBookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RouteManagementBooking to aggregate.
     */
    where?: RouteManagementBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteManagementBookings to fetch.
     */
    orderBy?: RouteManagementBookingOrderByWithRelationInput | RouteManagementBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RouteManagementBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteManagementBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteManagementBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RouteManagementBookings
    **/
    _count?: true | RouteManagementBookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RouteManagementBookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RouteManagementBookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RouteManagementBookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RouteManagementBookingMaxAggregateInputType
  }

  export type GetRouteManagementBookingAggregateType<T extends RouteManagementBookingAggregateArgs> = {
        [P in keyof T & keyof AggregateRouteManagementBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRouteManagementBooking[P]>
      : GetScalarType<T[P], AggregateRouteManagementBooking[P]>
  }




  export type RouteManagementBookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteManagementBookingWhereInput
    orderBy?: RouteManagementBookingOrderByWithAggregationInput | RouteManagementBookingOrderByWithAggregationInput[]
    by: RouteManagementBookingScalarFieldEnum[] | RouteManagementBookingScalarFieldEnum
    having?: RouteManagementBookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RouteManagementBookingCountAggregateInputType | true
    _avg?: RouteManagementBookingAvgAggregateInputType
    _sum?: RouteManagementBookingSumAggregateInputType
    _min?: RouteManagementBookingMinAggregateInputType
    _max?: RouteManagementBookingMaxAggregateInputType
  }

  export type RouteManagementBookingGroupByOutputType = {
    id: number
    route_id: string
    booking_id: number
    stop_order: number
    estimated_pickup_time: string | null
    estimated_drop_time: string | null
    distance_from_previous: number | null
    cumulative_distance: number | null
    created_at: Date
    _count: RouteManagementBookingCountAggregateOutputType | null
    _avg: RouteManagementBookingAvgAggregateOutputType | null
    _sum: RouteManagementBookingSumAggregateOutputType | null
    _min: RouteManagementBookingMinAggregateOutputType | null
    _max: RouteManagementBookingMaxAggregateOutputType | null
  }

  type GetRouteManagementBookingGroupByPayload<T extends RouteManagementBookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RouteManagementBookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RouteManagementBookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RouteManagementBookingGroupByOutputType[P]>
            : GetScalarType<T[P], RouteManagementBookingGroupByOutputType[P]>
        }
      >
    >


  export type RouteManagementBookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    route_id?: boolean
    booking_id?: boolean
    stop_order?: boolean
    estimated_pickup_time?: boolean
    estimated_drop_time?: boolean
    distance_from_previous?: boolean
    cumulative_distance?: boolean
    created_at?: boolean
    route_management?: boolean | RouteManagementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routeManagementBooking"]>

  export type RouteManagementBookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    route_id?: boolean
    booking_id?: boolean
    stop_order?: boolean
    estimated_pickup_time?: boolean
    estimated_drop_time?: boolean
    distance_from_previous?: boolean
    cumulative_distance?: boolean
    created_at?: boolean
    route_management?: boolean | RouteManagementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routeManagementBooking"]>

  export type RouteManagementBookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    route_id?: boolean
    booking_id?: boolean
    stop_order?: boolean
    estimated_pickup_time?: boolean
    estimated_drop_time?: boolean
    distance_from_previous?: boolean
    cumulative_distance?: boolean
    created_at?: boolean
    route_management?: boolean | RouteManagementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routeManagementBooking"]>

  export type RouteManagementBookingSelectScalar = {
    id?: boolean
    route_id?: boolean
    booking_id?: boolean
    stop_order?: boolean
    estimated_pickup_time?: boolean
    estimated_drop_time?: boolean
    distance_from_previous?: boolean
    cumulative_distance?: boolean
    created_at?: boolean
  }

  export type RouteManagementBookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "route_id" | "booking_id" | "stop_order" | "estimated_pickup_time" | "estimated_drop_time" | "distance_from_previous" | "cumulative_distance" | "created_at", ExtArgs["result"]["routeManagementBooking"]>
  export type RouteManagementBookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    route_management?: boolean | RouteManagementDefaultArgs<ExtArgs>
  }
  export type RouteManagementBookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    route_management?: boolean | RouteManagementDefaultArgs<ExtArgs>
  }
  export type RouteManagementBookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    route_management?: boolean | RouteManagementDefaultArgs<ExtArgs>
  }

  export type $RouteManagementBookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RouteManagementBooking"
    objects: {
      route_management: Prisma.$RouteManagementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      route_id: string
      booking_id: number
      stop_order: number
      estimated_pickup_time: string | null
      estimated_drop_time: string | null
      distance_from_previous: number | null
      cumulative_distance: number | null
      created_at: Date
    }, ExtArgs["result"]["routeManagementBooking"]>
    composites: {}
  }

  type RouteManagementBookingGetPayload<S extends boolean | null | undefined | RouteManagementBookingDefaultArgs> = $Result.GetResult<Prisma.$RouteManagementBookingPayload, S>

  type RouteManagementBookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RouteManagementBookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RouteManagementBookingCountAggregateInputType | true
    }

  export interface RouteManagementBookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RouteManagementBooking'], meta: { name: 'RouteManagementBooking' } }
    /**
     * Find zero or one RouteManagementBooking that matches the filter.
     * @param {RouteManagementBookingFindUniqueArgs} args - Arguments to find a RouteManagementBooking
     * @example
     * // Get one RouteManagementBooking
     * const routeManagementBooking = await prisma.routeManagementBooking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RouteManagementBookingFindUniqueArgs>(args: SelectSubset<T, RouteManagementBookingFindUniqueArgs<ExtArgs>>): Prisma__RouteManagementBookingClient<$Result.GetResult<Prisma.$RouteManagementBookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RouteManagementBooking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RouteManagementBookingFindUniqueOrThrowArgs} args - Arguments to find a RouteManagementBooking
     * @example
     * // Get one RouteManagementBooking
     * const routeManagementBooking = await prisma.routeManagementBooking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RouteManagementBookingFindUniqueOrThrowArgs>(args: SelectSubset<T, RouteManagementBookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RouteManagementBookingClient<$Result.GetResult<Prisma.$RouteManagementBookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RouteManagementBooking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteManagementBookingFindFirstArgs} args - Arguments to find a RouteManagementBooking
     * @example
     * // Get one RouteManagementBooking
     * const routeManagementBooking = await prisma.routeManagementBooking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RouteManagementBookingFindFirstArgs>(args?: SelectSubset<T, RouteManagementBookingFindFirstArgs<ExtArgs>>): Prisma__RouteManagementBookingClient<$Result.GetResult<Prisma.$RouteManagementBookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RouteManagementBooking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteManagementBookingFindFirstOrThrowArgs} args - Arguments to find a RouteManagementBooking
     * @example
     * // Get one RouteManagementBooking
     * const routeManagementBooking = await prisma.routeManagementBooking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RouteManagementBookingFindFirstOrThrowArgs>(args?: SelectSubset<T, RouteManagementBookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__RouteManagementBookingClient<$Result.GetResult<Prisma.$RouteManagementBookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RouteManagementBookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteManagementBookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RouteManagementBookings
     * const routeManagementBookings = await prisma.routeManagementBooking.findMany()
     * 
     * // Get first 10 RouteManagementBookings
     * const routeManagementBookings = await prisma.routeManagementBooking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const routeManagementBookingWithIdOnly = await prisma.routeManagementBooking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RouteManagementBookingFindManyArgs>(args?: SelectSubset<T, RouteManagementBookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteManagementBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RouteManagementBooking.
     * @param {RouteManagementBookingCreateArgs} args - Arguments to create a RouteManagementBooking.
     * @example
     * // Create one RouteManagementBooking
     * const RouteManagementBooking = await prisma.routeManagementBooking.create({
     *   data: {
     *     // ... data to create a RouteManagementBooking
     *   }
     * })
     * 
     */
    create<T extends RouteManagementBookingCreateArgs>(args: SelectSubset<T, RouteManagementBookingCreateArgs<ExtArgs>>): Prisma__RouteManagementBookingClient<$Result.GetResult<Prisma.$RouteManagementBookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RouteManagementBookings.
     * @param {RouteManagementBookingCreateManyArgs} args - Arguments to create many RouteManagementBookings.
     * @example
     * // Create many RouteManagementBookings
     * const routeManagementBooking = await prisma.routeManagementBooking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RouteManagementBookingCreateManyArgs>(args?: SelectSubset<T, RouteManagementBookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RouteManagementBookings and returns the data saved in the database.
     * @param {RouteManagementBookingCreateManyAndReturnArgs} args - Arguments to create many RouteManagementBookings.
     * @example
     * // Create many RouteManagementBookings
     * const routeManagementBooking = await prisma.routeManagementBooking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RouteManagementBookings and only return the `id`
     * const routeManagementBookingWithIdOnly = await prisma.routeManagementBooking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RouteManagementBookingCreateManyAndReturnArgs>(args?: SelectSubset<T, RouteManagementBookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteManagementBookingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RouteManagementBooking.
     * @param {RouteManagementBookingDeleteArgs} args - Arguments to delete one RouteManagementBooking.
     * @example
     * // Delete one RouteManagementBooking
     * const RouteManagementBooking = await prisma.routeManagementBooking.delete({
     *   where: {
     *     // ... filter to delete one RouteManagementBooking
     *   }
     * })
     * 
     */
    delete<T extends RouteManagementBookingDeleteArgs>(args: SelectSubset<T, RouteManagementBookingDeleteArgs<ExtArgs>>): Prisma__RouteManagementBookingClient<$Result.GetResult<Prisma.$RouteManagementBookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RouteManagementBooking.
     * @param {RouteManagementBookingUpdateArgs} args - Arguments to update one RouteManagementBooking.
     * @example
     * // Update one RouteManagementBooking
     * const routeManagementBooking = await prisma.routeManagementBooking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RouteManagementBookingUpdateArgs>(args: SelectSubset<T, RouteManagementBookingUpdateArgs<ExtArgs>>): Prisma__RouteManagementBookingClient<$Result.GetResult<Prisma.$RouteManagementBookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RouteManagementBookings.
     * @param {RouteManagementBookingDeleteManyArgs} args - Arguments to filter RouteManagementBookings to delete.
     * @example
     * // Delete a few RouteManagementBookings
     * const { count } = await prisma.routeManagementBooking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RouteManagementBookingDeleteManyArgs>(args?: SelectSubset<T, RouteManagementBookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RouteManagementBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteManagementBookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RouteManagementBookings
     * const routeManagementBooking = await prisma.routeManagementBooking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RouteManagementBookingUpdateManyArgs>(args: SelectSubset<T, RouteManagementBookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RouteManagementBookings and returns the data updated in the database.
     * @param {RouteManagementBookingUpdateManyAndReturnArgs} args - Arguments to update many RouteManagementBookings.
     * @example
     * // Update many RouteManagementBookings
     * const routeManagementBooking = await prisma.routeManagementBooking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RouteManagementBookings and only return the `id`
     * const routeManagementBookingWithIdOnly = await prisma.routeManagementBooking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RouteManagementBookingUpdateManyAndReturnArgs>(args: SelectSubset<T, RouteManagementBookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteManagementBookingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RouteManagementBooking.
     * @param {RouteManagementBookingUpsertArgs} args - Arguments to update or create a RouteManagementBooking.
     * @example
     * // Update or create a RouteManagementBooking
     * const routeManagementBooking = await prisma.routeManagementBooking.upsert({
     *   create: {
     *     // ... data to create a RouteManagementBooking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RouteManagementBooking we want to update
     *   }
     * })
     */
    upsert<T extends RouteManagementBookingUpsertArgs>(args: SelectSubset<T, RouteManagementBookingUpsertArgs<ExtArgs>>): Prisma__RouteManagementBookingClient<$Result.GetResult<Prisma.$RouteManagementBookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RouteManagementBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteManagementBookingCountArgs} args - Arguments to filter RouteManagementBookings to count.
     * @example
     * // Count the number of RouteManagementBookings
     * const count = await prisma.routeManagementBooking.count({
     *   where: {
     *     // ... the filter for the RouteManagementBookings we want to count
     *   }
     * })
    **/
    count<T extends RouteManagementBookingCountArgs>(
      args?: Subset<T, RouteManagementBookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RouteManagementBookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RouteManagementBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteManagementBookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RouteManagementBookingAggregateArgs>(args: Subset<T, RouteManagementBookingAggregateArgs>): Prisma.PrismaPromise<GetRouteManagementBookingAggregateType<T>>

    /**
     * Group by RouteManagementBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteManagementBookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RouteManagementBookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RouteManagementBookingGroupByArgs['orderBy'] }
        : { orderBy?: RouteManagementBookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RouteManagementBookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRouteManagementBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RouteManagementBooking model
   */
  readonly fields: RouteManagementBookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RouteManagementBooking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RouteManagementBookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    route_management<T extends RouteManagementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RouteManagementDefaultArgs<ExtArgs>>): Prisma__RouteManagementClient<$Result.GetResult<Prisma.$RouteManagementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RouteManagementBooking model
   */
  interface RouteManagementBookingFieldRefs {
    readonly id: FieldRef<"RouteManagementBooking", 'Int'>
    readonly route_id: FieldRef<"RouteManagementBooking", 'String'>
    readonly booking_id: FieldRef<"RouteManagementBooking", 'Int'>
    readonly stop_order: FieldRef<"RouteManagementBooking", 'Int'>
    readonly estimated_pickup_time: FieldRef<"RouteManagementBooking", 'String'>
    readonly estimated_drop_time: FieldRef<"RouteManagementBooking", 'String'>
    readonly distance_from_previous: FieldRef<"RouteManagementBooking", 'Float'>
    readonly cumulative_distance: FieldRef<"RouteManagementBooking", 'Float'>
    readonly created_at: FieldRef<"RouteManagementBooking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RouteManagementBooking findUnique
   */
  export type RouteManagementBookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteManagementBooking
     */
    select?: RouteManagementBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteManagementBooking
     */
    omit?: RouteManagementBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteManagementBookingInclude<ExtArgs> | null
    /**
     * Filter, which RouteManagementBooking to fetch.
     */
    where: RouteManagementBookingWhereUniqueInput
  }

  /**
   * RouteManagementBooking findUniqueOrThrow
   */
  export type RouteManagementBookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteManagementBooking
     */
    select?: RouteManagementBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteManagementBooking
     */
    omit?: RouteManagementBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteManagementBookingInclude<ExtArgs> | null
    /**
     * Filter, which RouteManagementBooking to fetch.
     */
    where: RouteManagementBookingWhereUniqueInput
  }

  /**
   * RouteManagementBooking findFirst
   */
  export type RouteManagementBookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteManagementBooking
     */
    select?: RouteManagementBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteManagementBooking
     */
    omit?: RouteManagementBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteManagementBookingInclude<ExtArgs> | null
    /**
     * Filter, which RouteManagementBooking to fetch.
     */
    where?: RouteManagementBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteManagementBookings to fetch.
     */
    orderBy?: RouteManagementBookingOrderByWithRelationInput | RouteManagementBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RouteManagementBookings.
     */
    cursor?: RouteManagementBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteManagementBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteManagementBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RouteManagementBookings.
     */
    distinct?: RouteManagementBookingScalarFieldEnum | RouteManagementBookingScalarFieldEnum[]
  }

  /**
   * RouteManagementBooking findFirstOrThrow
   */
  export type RouteManagementBookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteManagementBooking
     */
    select?: RouteManagementBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteManagementBooking
     */
    omit?: RouteManagementBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteManagementBookingInclude<ExtArgs> | null
    /**
     * Filter, which RouteManagementBooking to fetch.
     */
    where?: RouteManagementBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteManagementBookings to fetch.
     */
    orderBy?: RouteManagementBookingOrderByWithRelationInput | RouteManagementBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RouteManagementBookings.
     */
    cursor?: RouteManagementBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteManagementBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteManagementBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RouteManagementBookings.
     */
    distinct?: RouteManagementBookingScalarFieldEnum | RouteManagementBookingScalarFieldEnum[]
  }

  /**
   * RouteManagementBooking findMany
   */
  export type RouteManagementBookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteManagementBooking
     */
    select?: RouteManagementBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteManagementBooking
     */
    omit?: RouteManagementBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteManagementBookingInclude<ExtArgs> | null
    /**
     * Filter, which RouteManagementBookings to fetch.
     */
    where?: RouteManagementBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteManagementBookings to fetch.
     */
    orderBy?: RouteManagementBookingOrderByWithRelationInput | RouteManagementBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RouteManagementBookings.
     */
    cursor?: RouteManagementBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteManagementBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteManagementBookings.
     */
    skip?: number
    distinct?: RouteManagementBookingScalarFieldEnum | RouteManagementBookingScalarFieldEnum[]
  }

  /**
   * RouteManagementBooking create
   */
  export type RouteManagementBookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteManagementBooking
     */
    select?: RouteManagementBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteManagementBooking
     */
    omit?: RouteManagementBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteManagementBookingInclude<ExtArgs> | null
    /**
     * The data needed to create a RouteManagementBooking.
     */
    data: XOR<RouteManagementBookingCreateInput, RouteManagementBookingUncheckedCreateInput>
  }

  /**
   * RouteManagementBooking createMany
   */
  export type RouteManagementBookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RouteManagementBookings.
     */
    data: RouteManagementBookingCreateManyInput | RouteManagementBookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RouteManagementBooking createManyAndReturn
   */
  export type RouteManagementBookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteManagementBooking
     */
    select?: RouteManagementBookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RouteManagementBooking
     */
    omit?: RouteManagementBookingOmit<ExtArgs> | null
    /**
     * The data used to create many RouteManagementBookings.
     */
    data: RouteManagementBookingCreateManyInput | RouteManagementBookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteManagementBookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RouteManagementBooking update
   */
  export type RouteManagementBookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteManagementBooking
     */
    select?: RouteManagementBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteManagementBooking
     */
    omit?: RouteManagementBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteManagementBookingInclude<ExtArgs> | null
    /**
     * The data needed to update a RouteManagementBooking.
     */
    data: XOR<RouteManagementBookingUpdateInput, RouteManagementBookingUncheckedUpdateInput>
    /**
     * Choose, which RouteManagementBooking to update.
     */
    where: RouteManagementBookingWhereUniqueInput
  }

  /**
   * RouteManagementBooking updateMany
   */
  export type RouteManagementBookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RouteManagementBookings.
     */
    data: XOR<RouteManagementBookingUpdateManyMutationInput, RouteManagementBookingUncheckedUpdateManyInput>
    /**
     * Filter which RouteManagementBookings to update
     */
    where?: RouteManagementBookingWhereInput
    /**
     * Limit how many RouteManagementBookings to update.
     */
    limit?: number
  }

  /**
   * RouteManagementBooking updateManyAndReturn
   */
  export type RouteManagementBookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteManagementBooking
     */
    select?: RouteManagementBookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RouteManagementBooking
     */
    omit?: RouteManagementBookingOmit<ExtArgs> | null
    /**
     * The data used to update RouteManagementBookings.
     */
    data: XOR<RouteManagementBookingUpdateManyMutationInput, RouteManagementBookingUncheckedUpdateManyInput>
    /**
     * Filter which RouteManagementBookings to update
     */
    where?: RouteManagementBookingWhereInput
    /**
     * Limit how many RouteManagementBookings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteManagementBookingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RouteManagementBooking upsert
   */
  export type RouteManagementBookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteManagementBooking
     */
    select?: RouteManagementBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteManagementBooking
     */
    omit?: RouteManagementBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteManagementBookingInclude<ExtArgs> | null
    /**
     * The filter to search for the RouteManagementBooking to update in case it exists.
     */
    where: RouteManagementBookingWhereUniqueInput
    /**
     * In case the RouteManagementBooking found by the `where` argument doesn't exist, create a new RouteManagementBooking with this data.
     */
    create: XOR<RouteManagementBookingCreateInput, RouteManagementBookingUncheckedCreateInput>
    /**
     * In case the RouteManagementBooking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RouteManagementBookingUpdateInput, RouteManagementBookingUncheckedUpdateInput>
  }

  /**
   * RouteManagementBooking delete
   */
  export type RouteManagementBookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteManagementBooking
     */
    select?: RouteManagementBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteManagementBooking
     */
    omit?: RouteManagementBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteManagementBookingInclude<ExtArgs> | null
    /**
     * Filter which RouteManagementBooking to delete.
     */
    where: RouteManagementBookingWhereUniqueInput
  }

  /**
   * RouteManagementBooking deleteMany
   */
  export type RouteManagementBookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RouteManagementBookings to delete
     */
    where?: RouteManagementBookingWhereInput
    /**
     * Limit how many RouteManagementBookings to delete.
     */
    limit?: number
  }

  /**
   * RouteManagementBooking without action
   */
  export type RouteManagementBookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteManagementBooking
     */
    select?: RouteManagementBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteManagementBooking
     */
    omit?: RouteManagementBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteManagementBookingInclude<ExtArgs> | null
  }


  /**
   * Model RouteManagement
   */

  export type AggregateRouteManagement = {
    _count: RouteManagementCountAggregateOutputType | null
    _avg: RouteManagementAvgAggregateOutputType | null
    _sum: RouteManagementSumAggregateOutputType | null
    _min: RouteManagementMinAggregateOutputType | null
    _max: RouteManagementMaxAggregateOutputType | null
  }

  export type RouteManagementAvgAggregateOutputType = {
    shift_id: number | null
    planned_distance_km: number | null
    planned_duration_minutes: number | null
    actual_distance_km: number | null
    actual_duration_minutes: number | null
    assigned_vendor_id: number | null
    assigned_vehicle_id: number | null
    assigned_driver_id: number | null
    total_distance_km: number | null
    total_time_minutes: number | null
    version: number | null
  }

  export type RouteManagementSumAggregateOutputType = {
    shift_id: number | null
    planned_distance_km: number | null
    planned_duration_minutes: number | null
    actual_distance_km: number | null
    actual_duration_minutes: number | null
    assigned_vendor_id: number | null
    assigned_vehicle_id: number | null
    assigned_driver_id: number | null
    total_distance_km: number | null
    total_time_minutes: number | null
    version: number | null
  }

  export type RouteManagementMinAggregateOutputType = {
    route_id: string | null
    tenant_id: string | null
    shift_id: number | null
    route_code: string | null
    status: $Enums.RouteManagementStatusEnum | null
    planned_distance_km: number | null
    planned_duration_minutes: number | null
    actual_distance_km: number | null
    actual_duration_minutes: number | null
    actual_start_time: Date | null
    actual_end_time: Date | null
    optimized_polyline: string | null
    assigned_vendor_id: number | null
    assigned_vehicle_id: number | null
    assigned_driver_id: number | null
    total_distance_km: number | null
    total_time_minutes: number | null
    is_active: boolean | null
    version: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RouteManagementMaxAggregateOutputType = {
    route_id: string | null
    tenant_id: string | null
    shift_id: number | null
    route_code: string | null
    status: $Enums.RouteManagementStatusEnum | null
    planned_distance_km: number | null
    planned_duration_minutes: number | null
    actual_distance_km: number | null
    actual_duration_minutes: number | null
    actual_start_time: Date | null
    actual_end_time: Date | null
    optimized_polyline: string | null
    assigned_vendor_id: number | null
    assigned_vehicle_id: number | null
    assigned_driver_id: number | null
    total_distance_km: number | null
    total_time_minutes: number | null
    is_active: boolean | null
    version: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RouteManagementCountAggregateOutputType = {
    route_id: number
    tenant_id: number
    shift_id: number
    route_code: number
    status: number
    planned_distance_km: number
    planned_duration_minutes: number
    actual_distance_km: number
    actual_duration_minutes: number
    actual_start_time: number
    actual_end_time: number
    optimized_polyline: number
    assigned_vendor_id: number
    assigned_vehicle_id: number
    assigned_driver_id: number
    total_distance_km: number
    total_time_minutes: number
    is_active: number
    version: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type RouteManagementAvgAggregateInputType = {
    shift_id?: true
    planned_distance_km?: true
    planned_duration_minutes?: true
    actual_distance_km?: true
    actual_duration_minutes?: true
    assigned_vendor_id?: true
    assigned_vehicle_id?: true
    assigned_driver_id?: true
    total_distance_km?: true
    total_time_minutes?: true
    version?: true
  }

  export type RouteManagementSumAggregateInputType = {
    shift_id?: true
    planned_distance_km?: true
    planned_duration_minutes?: true
    actual_distance_km?: true
    actual_duration_minutes?: true
    assigned_vendor_id?: true
    assigned_vehicle_id?: true
    assigned_driver_id?: true
    total_distance_km?: true
    total_time_minutes?: true
    version?: true
  }

  export type RouteManagementMinAggregateInputType = {
    route_id?: true
    tenant_id?: true
    shift_id?: true
    route_code?: true
    status?: true
    planned_distance_km?: true
    planned_duration_minutes?: true
    actual_distance_km?: true
    actual_duration_minutes?: true
    actual_start_time?: true
    actual_end_time?: true
    optimized_polyline?: true
    assigned_vendor_id?: true
    assigned_vehicle_id?: true
    assigned_driver_id?: true
    total_distance_km?: true
    total_time_minutes?: true
    is_active?: true
    version?: true
    created_at?: true
    updated_at?: true
  }

  export type RouteManagementMaxAggregateInputType = {
    route_id?: true
    tenant_id?: true
    shift_id?: true
    route_code?: true
    status?: true
    planned_distance_km?: true
    planned_duration_minutes?: true
    actual_distance_km?: true
    actual_duration_minutes?: true
    actual_start_time?: true
    actual_end_time?: true
    optimized_polyline?: true
    assigned_vendor_id?: true
    assigned_vehicle_id?: true
    assigned_driver_id?: true
    total_distance_km?: true
    total_time_minutes?: true
    is_active?: true
    version?: true
    created_at?: true
    updated_at?: true
  }

  export type RouteManagementCountAggregateInputType = {
    route_id?: true
    tenant_id?: true
    shift_id?: true
    route_code?: true
    status?: true
    planned_distance_km?: true
    planned_duration_minutes?: true
    actual_distance_km?: true
    actual_duration_minutes?: true
    actual_start_time?: true
    actual_end_time?: true
    optimized_polyline?: true
    assigned_vendor_id?: true
    assigned_vehicle_id?: true
    assigned_driver_id?: true
    total_distance_km?: true
    total_time_minutes?: true
    is_active?: true
    version?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type RouteManagementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RouteManagement to aggregate.
     */
    where?: RouteManagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteManagements to fetch.
     */
    orderBy?: RouteManagementOrderByWithRelationInput | RouteManagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RouteManagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteManagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteManagements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RouteManagements
    **/
    _count?: true | RouteManagementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RouteManagementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RouteManagementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RouteManagementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RouteManagementMaxAggregateInputType
  }

  export type GetRouteManagementAggregateType<T extends RouteManagementAggregateArgs> = {
        [P in keyof T & keyof AggregateRouteManagement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRouteManagement[P]>
      : GetScalarType<T[P], AggregateRouteManagement[P]>
  }




  export type RouteManagementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteManagementWhereInput
    orderBy?: RouteManagementOrderByWithAggregationInput | RouteManagementOrderByWithAggregationInput[]
    by: RouteManagementScalarFieldEnum[] | RouteManagementScalarFieldEnum
    having?: RouteManagementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RouteManagementCountAggregateInputType | true
    _avg?: RouteManagementAvgAggregateInputType
    _sum?: RouteManagementSumAggregateInputType
    _min?: RouteManagementMinAggregateInputType
    _max?: RouteManagementMaxAggregateInputType
  }

  export type RouteManagementGroupByOutputType = {
    route_id: string
    tenant_id: string
    shift_id: number | null
    route_code: string
    status: $Enums.RouteManagementStatusEnum
    planned_distance_km: number | null
    planned_duration_minutes: number | null
    actual_distance_km: number | null
    actual_duration_minutes: number | null
    actual_start_time: Date | null
    actual_end_time: Date | null
    optimized_polyline: string | null
    assigned_vendor_id: number | null
    assigned_vehicle_id: number | null
    assigned_driver_id: number | null
    total_distance_km: number | null
    total_time_minutes: number | null
    is_active: boolean
    version: number
    created_at: Date
    updated_at: Date
    _count: RouteManagementCountAggregateOutputType | null
    _avg: RouteManagementAvgAggregateOutputType | null
    _sum: RouteManagementSumAggregateOutputType | null
    _min: RouteManagementMinAggregateOutputType | null
    _max: RouteManagementMaxAggregateOutputType | null
  }

  type GetRouteManagementGroupByPayload<T extends RouteManagementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RouteManagementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RouteManagementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RouteManagementGroupByOutputType[P]>
            : GetScalarType<T[P], RouteManagementGroupByOutputType[P]>
        }
      >
    >


  export type RouteManagementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    route_id?: boolean
    tenant_id?: boolean
    shift_id?: boolean
    route_code?: boolean
    status?: boolean
    planned_distance_km?: boolean
    planned_duration_minutes?: boolean
    actual_distance_km?: boolean
    actual_duration_minutes?: boolean
    actual_start_time?: boolean
    actual_end_time?: boolean
    optimized_polyline?: boolean
    assigned_vendor_id?: boolean
    assigned_vehicle_id?: boolean
    assigned_driver_id?: boolean
    total_distance_km?: boolean
    total_time_minutes?: boolean
    is_active?: boolean
    version?: boolean
    created_at?: boolean
    updated_at?: boolean
    route_management_bookings?: boolean | RouteManagement$route_management_bookingsArgs<ExtArgs>
    _count?: boolean | RouteManagementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routeManagement"]>

  export type RouteManagementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    route_id?: boolean
    tenant_id?: boolean
    shift_id?: boolean
    route_code?: boolean
    status?: boolean
    planned_distance_km?: boolean
    planned_duration_minutes?: boolean
    actual_distance_km?: boolean
    actual_duration_minutes?: boolean
    actual_start_time?: boolean
    actual_end_time?: boolean
    optimized_polyline?: boolean
    assigned_vendor_id?: boolean
    assigned_vehicle_id?: boolean
    assigned_driver_id?: boolean
    total_distance_km?: boolean
    total_time_minutes?: boolean
    is_active?: boolean
    version?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["routeManagement"]>

  export type RouteManagementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    route_id?: boolean
    tenant_id?: boolean
    shift_id?: boolean
    route_code?: boolean
    status?: boolean
    planned_distance_km?: boolean
    planned_duration_minutes?: boolean
    actual_distance_km?: boolean
    actual_duration_minutes?: boolean
    actual_start_time?: boolean
    actual_end_time?: boolean
    optimized_polyline?: boolean
    assigned_vendor_id?: boolean
    assigned_vehicle_id?: boolean
    assigned_driver_id?: boolean
    total_distance_km?: boolean
    total_time_minutes?: boolean
    is_active?: boolean
    version?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["routeManagement"]>

  export type RouteManagementSelectScalar = {
    route_id?: boolean
    tenant_id?: boolean
    shift_id?: boolean
    route_code?: boolean
    status?: boolean
    planned_distance_km?: boolean
    planned_duration_minutes?: boolean
    actual_distance_km?: boolean
    actual_duration_minutes?: boolean
    actual_start_time?: boolean
    actual_end_time?: boolean
    optimized_polyline?: boolean
    assigned_vendor_id?: boolean
    assigned_vehicle_id?: boolean
    assigned_driver_id?: boolean
    total_distance_km?: boolean
    total_time_minutes?: boolean
    is_active?: boolean
    version?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type RouteManagementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"route_id" | "tenant_id" | "shift_id" | "route_code" | "status" | "planned_distance_km" | "planned_duration_minutes" | "actual_distance_km" | "actual_duration_minutes" | "actual_start_time" | "actual_end_time" | "optimized_polyline" | "assigned_vendor_id" | "assigned_vehicle_id" | "assigned_driver_id" | "total_distance_km" | "total_time_minutes" | "is_active" | "version" | "created_at" | "updated_at", ExtArgs["result"]["routeManagement"]>
  export type RouteManagementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    route_management_bookings?: boolean | RouteManagement$route_management_bookingsArgs<ExtArgs>
    _count?: boolean | RouteManagementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RouteManagementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RouteManagementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RouteManagementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RouteManagement"
    objects: {
      route_management_bookings: Prisma.$RouteManagementBookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      route_id: string
      tenant_id: string
      shift_id: number | null
      route_code: string
      status: $Enums.RouteManagementStatusEnum
      planned_distance_km: number | null
      planned_duration_minutes: number | null
      actual_distance_km: number | null
      actual_duration_minutes: number | null
      actual_start_time: Date | null
      actual_end_time: Date | null
      optimized_polyline: string | null
      assigned_vendor_id: number | null
      assigned_vehicle_id: number | null
      assigned_driver_id: number | null
      total_distance_km: number | null
      total_time_minutes: number | null
      is_active: boolean
      version: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["routeManagement"]>
    composites: {}
  }

  type RouteManagementGetPayload<S extends boolean | null | undefined | RouteManagementDefaultArgs> = $Result.GetResult<Prisma.$RouteManagementPayload, S>

  type RouteManagementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RouteManagementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RouteManagementCountAggregateInputType | true
    }

  export interface RouteManagementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RouteManagement'], meta: { name: 'RouteManagement' } }
    /**
     * Find zero or one RouteManagement that matches the filter.
     * @param {RouteManagementFindUniqueArgs} args - Arguments to find a RouteManagement
     * @example
     * // Get one RouteManagement
     * const routeManagement = await prisma.routeManagement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RouteManagementFindUniqueArgs>(args: SelectSubset<T, RouteManagementFindUniqueArgs<ExtArgs>>): Prisma__RouteManagementClient<$Result.GetResult<Prisma.$RouteManagementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RouteManagement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RouteManagementFindUniqueOrThrowArgs} args - Arguments to find a RouteManagement
     * @example
     * // Get one RouteManagement
     * const routeManagement = await prisma.routeManagement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RouteManagementFindUniqueOrThrowArgs>(args: SelectSubset<T, RouteManagementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RouteManagementClient<$Result.GetResult<Prisma.$RouteManagementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RouteManagement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteManagementFindFirstArgs} args - Arguments to find a RouteManagement
     * @example
     * // Get one RouteManagement
     * const routeManagement = await prisma.routeManagement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RouteManagementFindFirstArgs>(args?: SelectSubset<T, RouteManagementFindFirstArgs<ExtArgs>>): Prisma__RouteManagementClient<$Result.GetResult<Prisma.$RouteManagementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RouteManagement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteManagementFindFirstOrThrowArgs} args - Arguments to find a RouteManagement
     * @example
     * // Get one RouteManagement
     * const routeManagement = await prisma.routeManagement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RouteManagementFindFirstOrThrowArgs>(args?: SelectSubset<T, RouteManagementFindFirstOrThrowArgs<ExtArgs>>): Prisma__RouteManagementClient<$Result.GetResult<Prisma.$RouteManagementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RouteManagements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteManagementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RouteManagements
     * const routeManagements = await prisma.routeManagement.findMany()
     * 
     * // Get first 10 RouteManagements
     * const routeManagements = await prisma.routeManagement.findMany({ take: 10 })
     * 
     * // Only select the `route_id`
     * const routeManagementWithRoute_idOnly = await prisma.routeManagement.findMany({ select: { route_id: true } })
     * 
     */
    findMany<T extends RouteManagementFindManyArgs>(args?: SelectSubset<T, RouteManagementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteManagementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RouteManagement.
     * @param {RouteManagementCreateArgs} args - Arguments to create a RouteManagement.
     * @example
     * // Create one RouteManagement
     * const RouteManagement = await prisma.routeManagement.create({
     *   data: {
     *     // ... data to create a RouteManagement
     *   }
     * })
     * 
     */
    create<T extends RouteManagementCreateArgs>(args: SelectSubset<T, RouteManagementCreateArgs<ExtArgs>>): Prisma__RouteManagementClient<$Result.GetResult<Prisma.$RouteManagementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RouteManagements.
     * @param {RouteManagementCreateManyArgs} args - Arguments to create many RouteManagements.
     * @example
     * // Create many RouteManagements
     * const routeManagement = await prisma.routeManagement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RouteManagementCreateManyArgs>(args?: SelectSubset<T, RouteManagementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RouteManagements and returns the data saved in the database.
     * @param {RouteManagementCreateManyAndReturnArgs} args - Arguments to create many RouteManagements.
     * @example
     * // Create many RouteManagements
     * const routeManagement = await prisma.routeManagement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RouteManagements and only return the `route_id`
     * const routeManagementWithRoute_idOnly = await prisma.routeManagement.createManyAndReturn({
     *   select: { route_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RouteManagementCreateManyAndReturnArgs>(args?: SelectSubset<T, RouteManagementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteManagementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RouteManagement.
     * @param {RouteManagementDeleteArgs} args - Arguments to delete one RouteManagement.
     * @example
     * // Delete one RouteManagement
     * const RouteManagement = await prisma.routeManagement.delete({
     *   where: {
     *     // ... filter to delete one RouteManagement
     *   }
     * })
     * 
     */
    delete<T extends RouteManagementDeleteArgs>(args: SelectSubset<T, RouteManagementDeleteArgs<ExtArgs>>): Prisma__RouteManagementClient<$Result.GetResult<Prisma.$RouteManagementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RouteManagement.
     * @param {RouteManagementUpdateArgs} args - Arguments to update one RouteManagement.
     * @example
     * // Update one RouteManagement
     * const routeManagement = await prisma.routeManagement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RouteManagementUpdateArgs>(args: SelectSubset<T, RouteManagementUpdateArgs<ExtArgs>>): Prisma__RouteManagementClient<$Result.GetResult<Prisma.$RouteManagementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RouteManagements.
     * @param {RouteManagementDeleteManyArgs} args - Arguments to filter RouteManagements to delete.
     * @example
     * // Delete a few RouteManagements
     * const { count } = await prisma.routeManagement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RouteManagementDeleteManyArgs>(args?: SelectSubset<T, RouteManagementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RouteManagements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteManagementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RouteManagements
     * const routeManagement = await prisma.routeManagement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RouteManagementUpdateManyArgs>(args: SelectSubset<T, RouteManagementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RouteManagements and returns the data updated in the database.
     * @param {RouteManagementUpdateManyAndReturnArgs} args - Arguments to update many RouteManagements.
     * @example
     * // Update many RouteManagements
     * const routeManagement = await prisma.routeManagement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RouteManagements and only return the `route_id`
     * const routeManagementWithRoute_idOnly = await prisma.routeManagement.updateManyAndReturn({
     *   select: { route_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RouteManagementUpdateManyAndReturnArgs>(args: SelectSubset<T, RouteManagementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteManagementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RouteManagement.
     * @param {RouteManagementUpsertArgs} args - Arguments to update or create a RouteManagement.
     * @example
     * // Update or create a RouteManagement
     * const routeManagement = await prisma.routeManagement.upsert({
     *   create: {
     *     // ... data to create a RouteManagement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RouteManagement we want to update
     *   }
     * })
     */
    upsert<T extends RouteManagementUpsertArgs>(args: SelectSubset<T, RouteManagementUpsertArgs<ExtArgs>>): Prisma__RouteManagementClient<$Result.GetResult<Prisma.$RouteManagementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RouteManagements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteManagementCountArgs} args - Arguments to filter RouteManagements to count.
     * @example
     * // Count the number of RouteManagements
     * const count = await prisma.routeManagement.count({
     *   where: {
     *     // ... the filter for the RouteManagements we want to count
     *   }
     * })
    **/
    count<T extends RouteManagementCountArgs>(
      args?: Subset<T, RouteManagementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RouteManagementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RouteManagement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteManagementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RouteManagementAggregateArgs>(args: Subset<T, RouteManagementAggregateArgs>): Prisma.PrismaPromise<GetRouteManagementAggregateType<T>>

    /**
     * Group by RouteManagement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteManagementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RouteManagementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RouteManagementGroupByArgs['orderBy'] }
        : { orderBy?: RouteManagementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RouteManagementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRouteManagementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RouteManagement model
   */
  readonly fields: RouteManagementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RouteManagement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RouteManagementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    route_management_bookings<T extends RouteManagement$route_management_bookingsArgs<ExtArgs> = {}>(args?: Subset<T, RouteManagement$route_management_bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteManagementBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RouteManagement model
   */
  interface RouteManagementFieldRefs {
    readonly route_id: FieldRef<"RouteManagement", 'String'>
    readonly tenant_id: FieldRef<"RouteManagement", 'String'>
    readonly shift_id: FieldRef<"RouteManagement", 'Int'>
    readonly route_code: FieldRef<"RouteManagement", 'String'>
    readonly status: FieldRef<"RouteManagement", 'RouteManagementStatusEnum'>
    readonly planned_distance_km: FieldRef<"RouteManagement", 'Float'>
    readonly planned_duration_minutes: FieldRef<"RouteManagement", 'Int'>
    readonly actual_distance_km: FieldRef<"RouteManagement", 'Float'>
    readonly actual_duration_minutes: FieldRef<"RouteManagement", 'Int'>
    readonly actual_start_time: FieldRef<"RouteManagement", 'DateTime'>
    readonly actual_end_time: FieldRef<"RouteManagement", 'DateTime'>
    readonly optimized_polyline: FieldRef<"RouteManagement", 'String'>
    readonly assigned_vendor_id: FieldRef<"RouteManagement", 'Int'>
    readonly assigned_vehicle_id: FieldRef<"RouteManagement", 'Int'>
    readonly assigned_driver_id: FieldRef<"RouteManagement", 'Int'>
    readonly total_distance_km: FieldRef<"RouteManagement", 'Float'>
    readonly total_time_minutes: FieldRef<"RouteManagement", 'Float'>
    readonly is_active: FieldRef<"RouteManagement", 'Boolean'>
    readonly version: FieldRef<"RouteManagement", 'Int'>
    readonly created_at: FieldRef<"RouteManagement", 'DateTime'>
    readonly updated_at: FieldRef<"RouteManagement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RouteManagement findUnique
   */
  export type RouteManagementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteManagement
     */
    select?: RouteManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteManagement
     */
    omit?: RouteManagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteManagementInclude<ExtArgs> | null
    /**
     * Filter, which RouteManagement to fetch.
     */
    where: RouteManagementWhereUniqueInput
  }

  /**
   * RouteManagement findUniqueOrThrow
   */
  export type RouteManagementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteManagement
     */
    select?: RouteManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteManagement
     */
    omit?: RouteManagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteManagementInclude<ExtArgs> | null
    /**
     * Filter, which RouteManagement to fetch.
     */
    where: RouteManagementWhereUniqueInput
  }

  /**
   * RouteManagement findFirst
   */
  export type RouteManagementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteManagement
     */
    select?: RouteManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteManagement
     */
    omit?: RouteManagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteManagementInclude<ExtArgs> | null
    /**
     * Filter, which RouteManagement to fetch.
     */
    where?: RouteManagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteManagements to fetch.
     */
    orderBy?: RouteManagementOrderByWithRelationInput | RouteManagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RouteManagements.
     */
    cursor?: RouteManagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteManagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteManagements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RouteManagements.
     */
    distinct?: RouteManagementScalarFieldEnum | RouteManagementScalarFieldEnum[]
  }

  /**
   * RouteManagement findFirstOrThrow
   */
  export type RouteManagementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteManagement
     */
    select?: RouteManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteManagement
     */
    omit?: RouteManagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteManagementInclude<ExtArgs> | null
    /**
     * Filter, which RouteManagement to fetch.
     */
    where?: RouteManagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteManagements to fetch.
     */
    orderBy?: RouteManagementOrderByWithRelationInput | RouteManagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RouteManagements.
     */
    cursor?: RouteManagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteManagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteManagements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RouteManagements.
     */
    distinct?: RouteManagementScalarFieldEnum | RouteManagementScalarFieldEnum[]
  }

  /**
   * RouteManagement findMany
   */
  export type RouteManagementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteManagement
     */
    select?: RouteManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteManagement
     */
    omit?: RouteManagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteManagementInclude<ExtArgs> | null
    /**
     * Filter, which RouteManagements to fetch.
     */
    where?: RouteManagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteManagements to fetch.
     */
    orderBy?: RouteManagementOrderByWithRelationInput | RouteManagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RouteManagements.
     */
    cursor?: RouteManagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteManagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteManagements.
     */
    skip?: number
    distinct?: RouteManagementScalarFieldEnum | RouteManagementScalarFieldEnum[]
  }

  /**
   * RouteManagement create
   */
  export type RouteManagementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteManagement
     */
    select?: RouteManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteManagement
     */
    omit?: RouteManagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteManagementInclude<ExtArgs> | null
    /**
     * The data needed to create a RouteManagement.
     */
    data: XOR<RouteManagementCreateInput, RouteManagementUncheckedCreateInput>
  }

  /**
   * RouteManagement createMany
   */
  export type RouteManagementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RouteManagements.
     */
    data: RouteManagementCreateManyInput | RouteManagementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RouteManagement createManyAndReturn
   */
  export type RouteManagementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteManagement
     */
    select?: RouteManagementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RouteManagement
     */
    omit?: RouteManagementOmit<ExtArgs> | null
    /**
     * The data used to create many RouteManagements.
     */
    data: RouteManagementCreateManyInput | RouteManagementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RouteManagement update
   */
  export type RouteManagementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteManagement
     */
    select?: RouteManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteManagement
     */
    omit?: RouteManagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteManagementInclude<ExtArgs> | null
    /**
     * The data needed to update a RouteManagement.
     */
    data: XOR<RouteManagementUpdateInput, RouteManagementUncheckedUpdateInput>
    /**
     * Choose, which RouteManagement to update.
     */
    where: RouteManagementWhereUniqueInput
  }

  /**
   * RouteManagement updateMany
   */
  export type RouteManagementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RouteManagements.
     */
    data: XOR<RouteManagementUpdateManyMutationInput, RouteManagementUncheckedUpdateManyInput>
    /**
     * Filter which RouteManagements to update
     */
    where?: RouteManagementWhereInput
    /**
     * Limit how many RouteManagements to update.
     */
    limit?: number
  }

  /**
   * RouteManagement updateManyAndReturn
   */
  export type RouteManagementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteManagement
     */
    select?: RouteManagementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RouteManagement
     */
    omit?: RouteManagementOmit<ExtArgs> | null
    /**
     * The data used to update RouteManagements.
     */
    data: XOR<RouteManagementUpdateManyMutationInput, RouteManagementUncheckedUpdateManyInput>
    /**
     * Filter which RouteManagements to update
     */
    where?: RouteManagementWhereInput
    /**
     * Limit how many RouteManagements to update.
     */
    limit?: number
  }

  /**
   * RouteManagement upsert
   */
  export type RouteManagementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteManagement
     */
    select?: RouteManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteManagement
     */
    omit?: RouteManagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteManagementInclude<ExtArgs> | null
    /**
     * The filter to search for the RouteManagement to update in case it exists.
     */
    where: RouteManagementWhereUniqueInput
    /**
     * In case the RouteManagement found by the `where` argument doesn't exist, create a new RouteManagement with this data.
     */
    create: XOR<RouteManagementCreateInput, RouteManagementUncheckedCreateInput>
    /**
     * In case the RouteManagement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RouteManagementUpdateInput, RouteManagementUncheckedUpdateInput>
  }

  /**
   * RouteManagement delete
   */
  export type RouteManagementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteManagement
     */
    select?: RouteManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteManagement
     */
    omit?: RouteManagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteManagementInclude<ExtArgs> | null
    /**
     * Filter which RouteManagement to delete.
     */
    where: RouteManagementWhereUniqueInput
  }

  /**
   * RouteManagement deleteMany
   */
  export type RouteManagementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RouteManagements to delete
     */
    where?: RouteManagementWhereInput
    /**
     * Limit how many RouteManagements to delete.
     */
    limit?: number
  }

  /**
   * RouteManagement.route_management_bookings
   */
  export type RouteManagement$route_management_bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteManagementBooking
     */
    select?: RouteManagementBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteManagementBooking
     */
    omit?: RouteManagementBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteManagementBookingInclude<ExtArgs> | null
    where?: RouteManagementBookingWhereInput
    orderBy?: RouteManagementBookingOrderByWithRelationInput | RouteManagementBookingOrderByWithRelationInput[]
    cursor?: RouteManagementBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RouteManagementBookingScalarFieldEnum | RouteManagementBookingScalarFieldEnum[]
  }

  /**
   * RouteManagement without action
   */
  export type RouteManagementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteManagement
     */
    select?: RouteManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteManagement
     */
    omit?: RouteManagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteManagementInclude<ExtArgs> | null
  }


  /**
   * Model Driver
   */

  export type AggregateDriver = {
    _count: DriverCountAggregateOutputType | null
    _avg: DriverAvgAggregateOutputType | null
    _sum: DriverSumAggregateOutputType | null
    _min: DriverMinAggregateOutputType | null
    _max: DriverMaxAggregateOutputType | null
  }

  export type DriverAvgAggregateOutputType = {
    driver_id: number | null
    vendor_id: number | null
  }

  export type DriverSumAggregateOutputType = {
    driver_id: number | null
    vendor_id: number | null
  }

  export type DriverMinAggregateOutputType = {
    driver_id: number | null
    vendor_id: number | null
    name: string | null
    code: string | null
    email: string | null
    phone: string | null
    gender: $Enums.GenderEnum | null
    password: string | null
    date_of_birth: Date | null
    date_of_joining: Date | null
    permanent_address: string | null
    current_address: string | null
    photo_url: string | null
    bg_verify_status: $Enums.VerificationStatusEnum | null
    bg_expiry_date: Date | null
    bg_verify_url: string | null
    police_verify_status: $Enums.VerificationStatusEnum | null
    police_expiry_date: Date | null
    police_verify_url: string | null
    medical_verify_status: $Enums.VerificationStatusEnum | null
    medical_expiry_date: Date | null
    medical_verify_url: string | null
    training_verify_status: $Enums.VerificationStatusEnum | null
    training_expiry_date: Date | null
    training_verify_url: string | null
    eye_verify_status: $Enums.VerificationStatusEnum | null
    eye_expiry_date: Date | null
    eye_verify_url: string | null
    license_number: string | null
    license_expiry_date: Date | null
    license_url: string | null
    badge_number: string | null
    badge_expiry_date: Date | null
    badge_url: string | null
    alt_govt_id_number: string | null
    alt_govt_id_type: string | null
    alt_govt_id_url: string | null
    induction_date: Date | null
    induction_url: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DriverMaxAggregateOutputType = {
    driver_id: number | null
    vendor_id: number | null
    name: string | null
    code: string | null
    email: string | null
    phone: string | null
    gender: $Enums.GenderEnum | null
    password: string | null
    date_of_birth: Date | null
    date_of_joining: Date | null
    permanent_address: string | null
    current_address: string | null
    photo_url: string | null
    bg_verify_status: $Enums.VerificationStatusEnum | null
    bg_expiry_date: Date | null
    bg_verify_url: string | null
    police_verify_status: $Enums.VerificationStatusEnum | null
    police_expiry_date: Date | null
    police_verify_url: string | null
    medical_verify_status: $Enums.VerificationStatusEnum | null
    medical_expiry_date: Date | null
    medical_verify_url: string | null
    training_verify_status: $Enums.VerificationStatusEnum | null
    training_expiry_date: Date | null
    training_verify_url: string | null
    eye_verify_status: $Enums.VerificationStatusEnum | null
    eye_expiry_date: Date | null
    eye_verify_url: string | null
    license_number: string | null
    license_expiry_date: Date | null
    license_url: string | null
    badge_number: string | null
    badge_expiry_date: Date | null
    badge_url: string | null
    alt_govt_id_number: string | null
    alt_govt_id_type: string | null
    alt_govt_id_url: string | null
    induction_date: Date | null
    induction_url: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DriverCountAggregateOutputType = {
    driver_id: number
    vendor_id: number
    name: number
    code: number
    email: number
    phone: number
    gender: number
    password: number
    date_of_birth: number
    date_of_joining: number
    permanent_address: number
    current_address: number
    photo_url: number
    bg_verify_status: number
    bg_expiry_date: number
    bg_verify_url: number
    police_verify_status: number
    police_expiry_date: number
    police_verify_url: number
    medical_verify_status: number
    medical_expiry_date: number
    medical_verify_url: number
    training_verify_status: number
    training_expiry_date: number
    training_verify_url: number
    eye_verify_status: number
    eye_expiry_date: number
    eye_verify_url: number
    license_number: number
    license_expiry_date: number
    license_url: number
    badge_number: number
    badge_expiry_date: number
    badge_url: number
    alt_govt_id_number: number
    alt_govt_id_type: number
    alt_govt_id_url: number
    induction_date: number
    induction_url: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type DriverAvgAggregateInputType = {
    driver_id?: true
    vendor_id?: true
  }

  export type DriverSumAggregateInputType = {
    driver_id?: true
    vendor_id?: true
  }

  export type DriverMinAggregateInputType = {
    driver_id?: true
    vendor_id?: true
    name?: true
    code?: true
    email?: true
    phone?: true
    gender?: true
    password?: true
    date_of_birth?: true
    date_of_joining?: true
    permanent_address?: true
    current_address?: true
    photo_url?: true
    bg_verify_status?: true
    bg_expiry_date?: true
    bg_verify_url?: true
    police_verify_status?: true
    police_expiry_date?: true
    police_verify_url?: true
    medical_verify_status?: true
    medical_expiry_date?: true
    medical_verify_url?: true
    training_verify_status?: true
    training_expiry_date?: true
    training_verify_url?: true
    eye_verify_status?: true
    eye_expiry_date?: true
    eye_verify_url?: true
    license_number?: true
    license_expiry_date?: true
    license_url?: true
    badge_number?: true
    badge_expiry_date?: true
    badge_url?: true
    alt_govt_id_number?: true
    alt_govt_id_type?: true
    alt_govt_id_url?: true
    induction_date?: true
    induction_url?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type DriverMaxAggregateInputType = {
    driver_id?: true
    vendor_id?: true
    name?: true
    code?: true
    email?: true
    phone?: true
    gender?: true
    password?: true
    date_of_birth?: true
    date_of_joining?: true
    permanent_address?: true
    current_address?: true
    photo_url?: true
    bg_verify_status?: true
    bg_expiry_date?: true
    bg_verify_url?: true
    police_verify_status?: true
    police_expiry_date?: true
    police_verify_url?: true
    medical_verify_status?: true
    medical_expiry_date?: true
    medical_verify_url?: true
    training_verify_status?: true
    training_expiry_date?: true
    training_verify_url?: true
    eye_verify_status?: true
    eye_expiry_date?: true
    eye_verify_url?: true
    license_number?: true
    license_expiry_date?: true
    license_url?: true
    badge_number?: true
    badge_expiry_date?: true
    badge_url?: true
    alt_govt_id_number?: true
    alt_govt_id_type?: true
    alt_govt_id_url?: true
    induction_date?: true
    induction_url?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type DriverCountAggregateInputType = {
    driver_id?: true
    vendor_id?: true
    name?: true
    code?: true
    email?: true
    phone?: true
    gender?: true
    password?: true
    date_of_birth?: true
    date_of_joining?: true
    permanent_address?: true
    current_address?: true
    photo_url?: true
    bg_verify_status?: true
    bg_expiry_date?: true
    bg_verify_url?: true
    police_verify_status?: true
    police_expiry_date?: true
    police_verify_url?: true
    medical_verify_status?: true
    medical_expiry_date?: true
    medical_verify_url?: true
    training_verify_status?: true
    training_expiry_date?: true
    training_verify_url?: true
    eye_verify_status?: true
    eye_expiry_date?: true
    eye_verify_url?: true
    license_number?: true
    license_expiry_date?: true
    license_url?: true
    badge_number?: true
    badge_expiry_date?: true
    badge_url?: true
    alt_govt_id_number?: true
    alt_govt_id_type?: true
    alt_govt_id_url?: true
    induction_date?: true
    induction_url?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type DriverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Driver to aggregate.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Drivers
    **/
    _count?: true | DriverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DriverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DriverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DriverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DriverMaxAggregateInputType
  }

  export type GetDriverAggregateType<T extends DriverAggregateArgs> = {
        [P in keyof T & keyof AggregateDriver]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDriver[P]>
      : GetScalarType<T[P], AggregateDriver[P]>
  }




  export type DriverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverWhereInput
    orderBy?: DriverOrderByWithAggregationInput | DriverOrderByWithAggregationInput[]
    by: DriverScalarFieldEnum[] | DriverScalarFieldEnum
    having?: DriverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DriverCountAggregateInputType | true
    _avg?: DriverAvgAggregateInputType
    _sum?: DriverSumAggregateInputType
    _min?: DriverMinAggregateInputType
    _max?: DriverMaxAggregateInputType
  }

  export type DriverGroupByOutputType = {
    driver_id: number
    vendor_id: number
    name: string
    code: string
    email: string
    phone: string
    gender: $Enums.GenderEnum | null
    password: string
    date_of_birth: Date | null
    date_of_joining: Date | null
    permanent_address: string | null
    current_address: string | null
    photo_url: string | null
    bg_verify_status: $Enums.VerificationStatusEnum | null
    bg_expiry_date: Date | null
    bg_verify_url: string | null
    police_verify_status: $Enums.VerificationStatusEnum | null
    police_expiry_date: Date | null
    police_verify_url: string | null
    medical_verify_status: $Enums.VerificationStatusEnum | null
    medical_expiry_date: Date | null
    medical_verify_url: string | null
    training_verify_status: $Enums.VerificationStatusEnum | null
    training_expiry_date: Date | null
    training_verify_url: string | null
    eye_verify_status: $Enums.VerificationStatusEnum | null
    eye_expiry_date: Date | null
    eye_verify_url: string | null
    license_number: string | null
    license_expiry_date: Date | null
    license_url: string | null
    badge_number: string | null
    badge_expiry_date: Date | null
    badge_url: string | null
    alt_govt_id_number: string | null
    alt_govt_id_type: string | null
    alt_govt_id_url: string | null
    induction_date: Date | null
    induction_url: string | null
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: DriverCountAggregateOutputType | null
    _avg: DriverAvgAggregateOutputType | null
    _sum: DriverSumAggregateOutputType | null
    _min: DriverMinAggregateOutputType | null
    _max: DriverMaxAggregateOutputType | null
  }

  type GetDriverGroupByPayload<T extends DriverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DriverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DriverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DriverGroupByOutputType[P]>
            : GetScalarType<T[P], DriverGroupByOutputType[P]>
        }
      >
    >


  export type DriverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    driver_id?: boolean
    vendor_id?: boolean
    name?: boolean
    code?: boolean
    email?: boolean
    phone?: boolean
    gender?: boolean
    password?: boolean
    date_of_birth?: boolean
    date_of_joining?: boolean
    permanent_address?: boolean
    current_address?: boolean
    photo_url?: boolean
    bg_verify_status?: boolean
    bg_expiry_date?: boolean
    bg_verify_url?: boolean
    police_verify_status?: boolean
    police_expiry_date?: boolean
    police_verify_url?: boolean
    medical_verify_status?: boolean
    medical_expiry_date?: boolean
    medical_verify_url?: boolean
    training_verify_status?: boolean
    training_expiry_date?: boolean
    training_verify_url?: boolean
    eye_verify_status?: boolean
    eye_expiry_date?: boolean
    eye_verify_url?: boolean
    license_number?: boolean
    license_expiry_date?: boolean
    license_url?: boolean
    badge_number?: boolean
    badge_expiry_date?: boolean
    badge_url?: boolean
    alt_govt_id_number?: boolean
    alt_govt_id_type?: boolean
    alt_govt_id_url?: boolean
    induction_date?: boolean
    induction_url?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    vehicles?: boolean | Driver$vehiclesArgs<ExtArgs>
    _count?: boolean | DriverCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driver"]>

  export type DriverSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    driver_id?: boolean
    vendor_id?: boolean
    name?: boolean
    code?: boolean
    email?: boolean
    phone?: boolean
    gender?: boolean
    password?: boolean
    date_of_birth?: boolean
    date_of_joining?: boolean
    permanent_address?: boolean
    current_address?: boolean
    photo_url?: boolean
    bg_verify_status?: boolean
    bg_expiry_date?: boolean
    bg_verify_url?: boolean
    police_verify_status?: boolean
    police_expiry_date?: boolean
    police_verify_url?: boolean
    medical_verify_status?: boolean
    medical_expiry_date?: boolean
    medical_verify_url?: boolean
    training_verify_status?: boolean
    training_expiry_date?: boolean
    training_verify_url?: boolean
    eye_verify_status?: boolean
    eye_expiry_date?: boolean
    eye_verify_url?: boolean
    license_number?: boolean
    license_expiry_date?: boolean
    license_url?: boolean
    badge_number?: boolean
    badge_expiry_date?: boolean
    badge_url?: boolean
    alt_govt_id_number?: boolean
    alt_govt_id_type?: boolean
    alt_govt_id_url?: boolean
    induction_date?: boolean
    induction_url?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driver"]>

  export type DriverSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    driver_id?: boolean
    vendor_id?: boolean
    name?: boolean
    code?: boolean
    email?: boolean
    phone?: boolean
    gender?: boolean
    password?: boolean
    date_of_birth?: boolean
    date_of_joining?: boolean
    permanent_address?: boolean
    current_address?: boolean
    photo_url?: boolean
    bg_verify_status?: boolean
    bg_expiry_date?: boolean
    bg_verify_url?: boolean
    police_verify_status?: boolean
    police_expiry_date?: boolean
    police_verify_url?: boolean
    medical_verify_status?: boolean
    medical_expiry_date?: boolean
    medical_verify_url?: boolean
    training_verify_status?: boolean
    training_expiry_date?: boolean
    training_verify_url?: boolean
    eye_verify_status?: boolean
    eye_expiry_date?: boolean
    eye_verify_url?: boolean
    license_number?: boolean
    license_expiry_date?: boolean
    license_url?: boolean
    badge_number?: boolean
    badge_expiry_date?: boolean
    badge_url?: boolean
    alt_govt_id_number?: boolean
    alt_govt_id_type?: boolean
    alt_govt_id_url?: boolean
    induction_date?: boolean
    induction_url?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driver"]>

  export type DriverSelectScalar = {
    driver_id?: boolean
    vendor_id?: boolean
    name?: boolean
    code?: boolean
    email?: boolean
    phone?: boolean
    gender?: boolean
    password?: boolean
    date_of_birth?: boolean
    date_of_joining?: boolean
    permanent_address?: boolean
    current_address?: boolean
    photo_url?: boolean
    bg_verify_status?: boolean
    bg_expiry_date?: boolean
    bg_verify_url?: boolean
    police_verify_status?: boolean
    police_expiry_date?: boolean
    police_verify_url?: boolean
    medical_verify_status?: boolean
    medical_expiry_date?: boolean
    medical_verify_url?: boolean
    training_verify_status?: boolean
    training_expiry_date?: boolean
    training_verify_url?: boolean
    eye_verify_status?: boolean
    eye_expiry_date?: boolean
    eye_verify_url?: boolean
    license_number?: boolean
    license_expiry_date?: boolean
    license_url?: boolean
    badge_number?: boolean
    badge_expiry_date?: boolean
    badge_url?: boolean
    alt_govt_id_number?: boolean
    alt_govt_id_type?: boolean
    alt_govt_id_url?: boolean
    induction_date?: boolean
    induction_url?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type DriverOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"driver_id" | "vendor_id" | "name" | "code" | "email" | "phone" | "gender" | "password" | "date_of_birth" | "date_of_joining" | "permanent_address" | "current_address" | "photo_url" | "bg_verify_status" | "bg_expiry_date" | "bg_verify_url" | "police_verify_status" | "police_expiry_date" | "police_verify_url" | "medical_verify_status" | "medical_expiry_date" | "medical_verify_url" | "training_verify_status" | "training_expiry_date" | "training_verify_url" | "eye_verify_status" | "eye_expiry_date" | "eye_verify_url" | "license_number" | "license_expiry_date" | "license_url" | "badge_number" | "badge_expiry_date" | "badge_url" | "alt_govt_id_number" | "alt_govt_id_type" | "alt_govt_id_url" | "induction_date" | "induction_url" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["driver"]>
  export type DriverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    vehicles?: boolean | Driver$vehiclesArgs<ExtArgs>
    _count?: boolean | DriverCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DriverIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type DriverIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $DriverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Driver"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
      vehicles: Prisma.$VehiclePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      driver_id: number
      vendor_id: number
      name: string
      code: string
      email: string
      phone: string
      gender: $Enums.GenderEnum | null
      password: string
      date_of_birth: Date | null
      date_of_joining: Date | null
      permanent_address: string | null
      current_address: string | null
      photo_url: string | null
      bg_verify_status: $Enums.VerificationStatusEnum | null
      bg_expiry_date: Date | null
      bg_verify_url: string | null
      police_verify_status: $Enums.VerificationStatusEnum | null
      police_expiry_date: Date | null
      police_verify_url: string | null
      medical_verify_status: $Enums.VerificationStatusEnum | null
      medical_expiry_date: Date | null
      medical_verify_url: string | null
      training_verify_status: $Enums.VerificationStatusEnum | null
      training_expiry_date: Date | null
      training_verify_url: string | null
      eye_verify_status: $Enums.VerificationStatusEnum | null
      eye_expiry_date: Date | null
      eye_verify_url: string | null
      license_number: string | null
      license_expiry_date: Date | null
      license_url: string | null
      badge_number: string | null
      badge_expiry_date: Date | null
      badge_url: string | null
      alt_govt_id_number: string | null
      alt_govt_id_type: string | null
      alt_govt_id_url: string | null
      induction_date: Date | null
      induction_url: string | null
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["driver"]>
    composites: {}
  }

  type DriverGetPayload<S extends boolean | null | undefined | DriverDefaultArgs> = $Result.GetResult<Prisma.$DriverPayload, S>

  type DriverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DriverFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DriverCountAggregateInputType | true
    }

  export interface DriverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Driver'], meta: { name: 'Driver' } }
    /**
     * Find zero or one Driver that matches the filter.
     * @param {DriverFindUniqueArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DriverFindUniqueArgs>(args: SelectSubset<T, DriverFindUniqueArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Driver that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DriverFindUniqueOrThrowArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DriverFindUniqueOrThrowArgs>(args: SelectSubset<T, DriverFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Driver that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindFirstArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DriverFindFirstArgs>(args?: SelectSubset<T, DriverFindFirstArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Driver that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindFirstOrThrowArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DriverFindFirstOrThrowArgs>(args?: SelectSubset<T, DriverFindFirstOrThrowArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Drivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drivers
     * const drivers = await prisma.driver.findMany()
     * 
     * // Get first 10 Drivers
     * const drivers = await prisma.driver.findMany({ take: 10 })
     * 
     * // Only select the `driver_id`
     * const driverWithDriver_idOnly = await prisma.driver.findMany({ select: { driver_id: true } })
     * 
     */
    findMany<T extends DriverFindManyArgs>(args?: SelectSubset<T, DriverFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Driver.
     * @param {DriverCreateArgs} args - Arguments to create a Driver.
     * @example
     * // Create one Driver
     * const Driver = await prisma.driver.create({
     *   data: {
     *     // ... data to create a Driver
     *   }
     * })
     * 
     */
    create<T extends DriverCreateArgs>(args: SelectSubset<T, DriverCreateArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Drivers.
     * @param {DriverCreateManyArgs} args - Arguments to create many Drivers.
     * @example
     * // Create many Drivers
     * const driver = await prisma.driver.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DriverCreateManyArgs>(args?: SelectSubset<T, DriverCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Drivers and returns the data saved in the database.
     * @param {DriverCreateManyAndReturnArgs} args - Arguments to create many Drivers.
     * @example
     * // Create many Drivers
     * const driver = await prisma.driver.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Drivers and only return the `driver_id`
     * const driverWithDriver_idOnly = await prisma.driver.createManyAndReturn({
     *   select: { driver_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DriverCreateManyAndReturnArgs>(args?: SelectSubset<T, DriverCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Driver.
     * @param {DriverDeleteArgs} args - Arguments to delete one Driver.
     * @example
     * // Delete one Driver
     * const Driver = await prisma.driver.delete({
     *   where: {
     *     // ... filter to delete one Driver
     *   }
     * })
     * 
     */
    delete<T extends DriverDeleteArgs>(args: SelectSubset<T, DriverDeleteArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Driver.
     * @param {DriverUpdateArgs} args - Arguments to update one Driver.
     * @example
     * // Update one Driver
     * const driver = await prisma.driver.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DriverUpdateArgs>(args: SelectSubset<T, DriverUpdateArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Drivers.
     * @param {DriverDeleteManyArgs} args - Arguments to filter Drivers to delete.
     * @example
     * // Delete a few Drivers
     * const { count } = await prisma.driver.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DriverDeleteManyArgs>(args?: SelectSubset<T, DriverDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drivers
     * const driver = await prisma.driver.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DriverUpdateManyArgs>(args: SelectSubset<T, DriverUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drivers and returns the data updated in the database.
     * @param {DriverUpdateManyAndReturnArgs} args - Arguments to update many Drivers.
     * @example
     * // Update many Drivers
     * const driver = await prisma.driver.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Drivers and only return the `driver_id`
     * const driverWithDriver_idOnly = await prisma.driver.updateManyAndReturn({
     *   select: { driver_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DriverUpdateManyAndReturnArgs>(args: SelectSubset<T, DriverUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Driver.
     * @param {DriverUpsertArgs} args - Arguments to update or create a Driver.
     * @example
     * // Update or create a Driver
     * const driver = await prisma.driver.upsert({
     *   create: {
     *     // ... data to create a Driver
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Driver we want to update
     *   }
     * })
     */
    upsert<T extends DriverUpsertArgs>(args: SelectSubset<T, DriverUpsertArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverCountArgs} args - Arguments to filter Drivers to count.
     * @example
     * // Count the number of Drivers
     * const count = await prisma.driver.count({
     *   where: {
     *     // ... the filter for the Drivers we want to count
     *   }
     * })
    **/
    count<T extends DriverCountArgs>(
      args?: Subset<T, DriverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Driver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DriverAggregateArgs>(args: Subset<T, DriverAggregateArgs>): Prisma.PrismaPromise<GetDriverAggregateType<T>>

    /**
     * Group by Driver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DriverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DriverGroupByArgs['orderBy'] }
        : { orderBy?: DriverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DriverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDriverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Driver model
   */
  readonly fields: DriverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Driver.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DriverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vehicles<T extends Driver$vehiclesArgs<ExtArgs> = {}>(args?: Subset<T, Driver$vehiclesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Driver model
   */
  interface DriverFieldRefs {
    readonly driver_id: FieldRef<"Driver", 'Int'>
    readonly vendor_id: FieldRef<"Driver", 'Int'>
    readonly name: FieldRef<"Driver", 'String'>
    readonly code: FieldRef<"Driver", 'String'>
    readonly email: FieldRef<"Driver", 'String'>
    readonly phone: FieldRef<"Driver", 'String'>
    readonly gender: FieldRef<"Driver", 'GenderEnum'>
    readonly password: FieldRef<"Driver", 'String'>
    readonly date_of_birth: FieldRef<"Driver", 'DateTime'>
    readonly date_of_joining: FieldRef<"Driver", 'DateTime'>
    readonly permanent_address: FieldRef<"Driver", 'String'>
    readonly current_address: FieldRef<"Driver", 'String'>
    readonly photo_url: FieldRef<"Driver", 'String'>
    readonly bg_verify_status: FieldRef<"Driver", 'VerificationStatusEnum'>
    readonly bg_expiry_date: FieldRef<"Driver", 'DateTime'>
    readonly bg_verify_url: FieldRef<"Driver", 'String'>
    readonly police_verify_status: FieldRef<"Driver", 'VerificationStatusEnum'>
    readonly police_expiry_date: FieldRef<"Driver", 'DateTime'>
    readonly police_verify_url: FieldRef<"Driver", 'String'>
    readonly medical_verify_status: FieldRef<"Driver", 'VerificationStatusEnum'>
    readonly medical_expiry_date: FieldRef<"Driver", 'DateTime'>
    readonly medical_verify_url: FieldRef<"Driver", 'String'>
    readonly training_verify_status: FieldRef<"Driver", 'VerificationStatusEnum'>
    readonly training_expiry_date: FieldRef<"Driver", 'DateTime'>
    readonly training_verify_url: FieldRef<"Driver", 'String'>
    readonly eye_verify_status: FieldRef<"Driver", 'VerificationStatusEnum'>
    readonly eye_expiry_date: FieldRef<"Driver", 'DateTime'>
    readonly eye_verify_url: FieldRef<"Driver", 'String'>
    readonly license_number: FieldRef<"Driver", 'String'>
    readonly license_expiry_date: FieldRef<"Driver", 'DateTime'>
    readonly license_url: FieldRef<"Driver", 'String'>
    readonly badge_number: FieldRef<"Driver", 'String'>
    readonly badge_expiry_date: FieldRef<"Driver", 'DateTime'>
    readonly badge_url: FieldRef<"Driver", 'String'>
    readonly alt_govt_id_number: FieldRef<"Driver", 'String'>
    readonly alt_govt_id_type: FieldRef<"Driver", 'String'>
    readonly alt_govt_id_url: FieldRef<"Driver", 'String'>
    readonly induction_date: FieldRef<"Driver", 'DateTime'>
    readonly induction_url: FieldRef<"Driver", 'String'>
    readonly is_active: FieldRef<"Driver", 'Boolean'>
    readonly created_at: FieldRef<"Driver", 'DateTime'>
    readonly updated_at: FieldRef<"Driver", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Driver findUnique
   */
  export type DriverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver findUniqueOrThrow
   */
  export type DriverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver findFirst
   */
  export type DriverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drivers.
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drivers.
     */
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Driver findFirstOrThrow
   */
  export type DriverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drivers.
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drivers.
     */
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Driver findMany
   */
  export type DriverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Drivers to fetch.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Drivers.
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Driver create
   */
  export type DriverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * The data needed to create a Driver.
     */
    data: XOR<DriverCreateInput, DriverUncheckedCreateInput>
  }

  /**
   * Driver createMany
   */
  export type DriverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Drivers.
     */
    data: DriverCreateManyInput | DriverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Driver createManyAndReturn
   */
  export type DriverCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * The data used to create many Drivers.
     */
    data: DriverCreateManyInput | DriverCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Driver update
   */
  export type DriverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * The data needed to update a Driver.
     */
    data: XOR<DriverUpdateInput, DriverUncheckedUpdateInput>
    /**
     * Choose, which Driver to update.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver updateMany
   */
  export type DriverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Drivers.
     */
    data: XOR<DriverUpdateManyMutationInput, DriverUncheckedUpdateManyInput>
    /**
     * Filter which Drivers to update
     */
    where?: DriverWhereInput
    /**
     * Limit how many Drivers to update.
     */
    limit?: number
  }

  /**
   * Driver updateManyAndReturn
   */
  export type DriverUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * The data used to update Drivers.
     */
    data: XOR<DriverUpdateManyMutationInput, DriverUncheckedUpdateManyInput>
    /**
     * Filter which Drivers to update
     */
    where?: DriverWhereInput
    /**
     * Limit how many Drivers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Driver upsert
   */
  export type DriverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * The filter to search for the Driver to update in case it exists.
     */
    where: DriverWhereUniqueInput
    /**
     * In case the Driver found by the `where` argument doesn't exist, create a new Driver with this data.
     */
    create: XOR<DriverCreateInput, DriverUncheckedCreateInput>
    /**
     * In case the Driver was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DriverUpdateInput, DriverUncheckedUpdateInput>
  }

  /**
   * Driver delete
   */
  export type DriverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter which Driver to delete.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver deleteMany
   */
  export type DriverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Drivers to delete
     */
    where?: DriverWhereInput
    /**
     * Limit how many Drivers to delete.
     */
    limit?: number
  }

  /**
   * Driver.vehicles
   */
  export type Driver$vehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    where?: VehicleWhereInput
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    cursor?: VehicleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Driver without action
   */
  export type DriverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
  }


  /**
   * Model Vehicle
   */

  export type AggregateVehicle = {
    _count: VehicleCountAggregateOutputType | null
    _avg: VehicleAvgAggregateOutputType | null
    _sum: VehicleSumAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  export type VehicleAvgAggregateOutputType = {
    vehicle_id: number | null
    vehicle_type_id: number | null
    vendor_id: number | null
    driver_id: number | null
  }

  export type VehicleSumAggregateOutputType = {
    vehicle_id: number | null
    vehicle_type_id: number | null
    vendor_id: number | null
    driver_id: number | null
  }

  export type VehicleMinAggregateOutputType = {
    vehicle_id: number | null
    vehicle_type_id: number | null
    vendor_id: number | null
    driver_id: number | null
    rc_number: string | null
    rc_expiry_date: Date | null
    description: string | null
    puc_number: string | null
    puc_expiry_date: Date | null
    puc_url: string | null
    fitness_number: string | null
    fitness_expiry_date: Date | null
    fitness_url: string | null
    tax_receipt_number: string | null
    tax_receipt_date: Date | null
    tax_receipt_url: string | null
    insurance_number: string | null
    insurance_expiry_date: Date | null
    insurance_url: string | null
    permit_number: string | null
    permit_expiry_date: Date | null
    permit_url: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VehicleMaxAggregateOutputType = {
    vehicle_id: number | null
    vehicle_type_id: number | null
    vendor_id: number | null
    driver_id: number | null
    rc_number: string | null
    rc_expiry_date: Date | null
    description: string | null
    puc_number: string | null
    puc_expiry_date: Date | null
    puc_url: string | null
    fitness_number: string | null
    fitness_expiry_date: Date | null
    fitness_url: string | null
    tax_receipt_number: string | null
    tax_receipt_date: Date | null
    tax_receipt_url: string | null
    insurance_number: string | null
    insurance_expiry_date: Date | null
    insurance_url: string | null
    permit_number: string | null
    permit_expiry_date: Date | null
    permit_url: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VehicleCountAggregateOutputType = {
    vehicle_id: number
    vehicle_type_id: number
    vendor_id: number
    driver_id: number
    rc_number: number
    rc_expiry_date: number
    description: number
    puc_number: number
    puc_expiry_date: number
    puc_url: number
    fitness_number: number
    fitness_expiry_date: number
    fitness_url: number
    tax_receipt_number: number
    tax_receipt_date: number
    tax_receipt_url: number
    insurance_number: number
    insurance_expiry_date: number
    insurance_url: number
    permit_number: number
    permit_expiry_date: number
    permit_url: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type VehicleAvgAggregateInputType = {
    vehicle_id?: true
    vehicle_type_id?: true
    vendor_id?: true
    driver_id?: true
  }

  export type VehicleSumAggregateInputType = {
    vehicle_id?: true
    vehicle_type_id?: true
    vendor_id?: true
    driver_id?: true
  }

  export type VehicleMinAggregateInputType = {
    vehicle_id?: true
    vehicle_type_id?: true
    vendor_id?: true
    driver_id?: true
    rc_number?: true
    rc_expiry_date?: true
    description?: true
    puc_number?: true
    puc_expiry_date?: true
    puc_url?: true
    fitness_number?: true
    fitness_expiry_date?: true
    fitness_url?: true
    tax_receipt_number?: true
    tax_receipt_date?: true
    tax_receipt_url?: true
    insurance_number?: true
    insurance_expiry_date?: true
    insurance_url?: true
    permit_number?: true
    permit_expiry_date?: true
    permit_url?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type VehicleMaxAggregateInputType = {
    vehicle_id?: true
    vehicle_type_id?: true
    vendor_id?: true
    driver_id?: true
    rc_number?: true
    rc_expiry_date?: true
    description?: true
    puc_number?: true
    puc_expiry_date?: true
    puc_url?: true
    fitness_number?: true
    fitness_expiry_date?: true
    fitness_url?: true
    tax_receipt_number?: true
    tax_receipt_date?: true
    tax_receipt_url?: true
    insurance_number?: true
    insurance_expiry_date?: true
    insurance_url?: true
    permit_number?: true
    permit_expiry_date?: true
    permit_url?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type VehicleCountAggregateInputType = {
    vehicle_id?: true
    vehicle_type_id?: true
    vendor_id?: true
    driver_id?: true
    rc_number?: true
    rc_expiry_date?: true
    description?: true
    puc_number?: true
    puc_expiry_date?: true
    puc_url?: true
    fitness_number?: true
    fitness_expiry_date?: true
    fitness_url?: true
    tax_receipt_number?: true
    tax_receipt_date?: true
    tax_receipt_url?: true
    insurance_number?: true
    insurance_expiry_date?: true
    insurance_url?: true
    permit_number?: true
    permit_expiry_date?: true
    permit_url?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type VehicleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicle to aggregate.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vehicles
    **/
    _count?: true | VehicleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleMaxAggregateInputType
  }

  export type GetVehicleAggregateType<T extends VehicleAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle[P]>
      : GetScalarType<T[P], AggregateVehicle[P]>
  }




  export type VehicleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleWhereInput
    orderBy?: VehicleOrderByWithAggregationInput | VehicleOrderByWithAggregationInput[]
    by: VehicleScalarFieldEnum[] | VehicleScalarFieldEnum
    having?: VehicleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleCountAggregateInputType | true
    _avg?: VehicleAvgAggregateInputType
    _sum?: VehicleSumAggregateInputType
    _min?: VehicleMinAggregateInputType
    _max?: VehicleMaxAggregateInputType
  }

  export type VehicleGroupByOutputType = {
    vehicle_id: number
    vehicle_type_id: number
    vendor_id: number
    driver_id: number | null
    rc_number: string
    rc_expiry_date: Date | null
    description: string | null
    puc_number: string | null
    puc_expiry_date: Date | null
    puc_url: string | null
    fitness_number: string | null
    fitness_expiry_date: Date | null
    fitness_url: string | null
    tax_receipt_number: string | null
    tax_receipt_date: Date | null
    tax_receipt_url: string | null
    insurance_number: string | null
    insurance_expiry_date: Date | null
    insurance_url: string | null
    permit_number: string | null
    permit_expiry_date: Date | null
    permit_url: string | null
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: VehicleCountAggregateOutputType | null
    _avg: VehicleAvgAggregateOutputType | null
    _sum: VehicleSumAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  type GetVehicleGroupByPayload<T extends VehicleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleGroupByOutputType[P]>
        }
      >
    >


  export type VehicleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    vehicle_id?: boolean
    vehicle_type_id?: boolean
    vendor_id?: boolean
    driver_id?: boolean
    rc_number?: boolean
    rc_expiry_date?: boolean
    description?: boolean
    puc_number?: boolean
    puc_expiry_date?: boolean
    puc_url?: boolean
    fitness_number?: boolean
    fitness_expiry_date?: boolean
    fitness_url?: boolean
    tax_receipt_number?: boolean
    tax_receipt_date?: boolean
    tax_receipt_url?: boolean
    insurance_number?: boolean
    insurance_expiry_date?: boolean
    insurance_url?: boolean
    permit_number?: boolean
    permit_expiry_date?: boolean
    permit_url?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    vehicle_type?: boolean | VehicleTypeDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    driver?: boolean | Vehicle$driverArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    vehicle_id?: boolean
    vehicle_type_id?: boolean
    vendor_id?: boolean
    driver_id?: boolean
    rc_number?: boolean
    rc_expiry_date?: boolean
    description?: boolean
    puc_number?: boolean
    puc_expiry_date?: boolean
    puc_url?: boolean
    fitness_number?: boolean
    fitness_expiry_date?: boolean
    fitness_url?: boolean
    tax_receipt_number?: boolean
    tax_receipt_date?: boolean
    tax_receipt_url?: boolean
    insurance_number?: boolean
    insurance_expiry_date?: boolean
    insurance_url?: boolean
    permit_number?: boolean
    permit_expiry_date?: boolean
    permit_url?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    vehicle_type?: boolean | VehicleTypeDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    driver?: boolean | Vehicle$driverArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    vehicle_id?: boolean
    vehicle_type_id?: boolean
    vendor_id?: boolean
    driver_id?: boolean
    rc_number?: boolean
    rc_expiry_date?: boolean
    description?: boolean
    puc_number?: boolean
    puc_expiry_date?: boolean
    puc_url?: boolean
    fitness_number?: boolean
    fitness_expiry_date?: boolean
    fitness_url?: boolean
    tax_receipt_number?: boolean
    tax_receipt_date?: boolean
    tax_receipt_url?: boolean
    insurance_number?: boolean
    insurance_expiry_date?: boolean
    insurance_url?: boolean
    permit_number?: boolean
    permit_expiry_date?: boolean
    permit_url?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    vehicle_type?: boolean | VehicleTypeDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    driver?: boolean | Vehicle$driverArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectScalar = {
    vehicle_id?: boolean
    vehicle_type_id?: boolean
    vendor_id?: boolean
    driver_id?: boolean
    rc_number?: boolean
    rc_expiry_date?: boolean
    description?: boolean
    puc_number?: boolean
    puc_expiry_date?: boolean
    puc_url?: boolean
    fitness_number?: boolean
    fitness_expiry_date?: boolean
    fitness_url?: boolean
    tax_receipt_number?: boolean
    tax_receipt_date?: boolean
    tax_receipt_url?: boolean
    insurance_number?: boolean
    insurance_expiry_date?: boolean
    insurance_url?: boolean
    permit_number?: boolean
    permit_expiry_date?: boolean
    permit_url?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type VehicleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"vehicle_id" | "vehicle_type_id" | "vendor_id" | "driver_id" | "rc_number" | "rc_expiry_date" | "description" | "puc_number" | "puc_expiry_date" | "puc_url" | "fitness_number" | "fitness_expiry_date" | "fitness_url" | "tax_receipt_number" | "tax_receipt_date" | "tax_receipt_url" | "insurance_number" | "insurance_expiry_date" | "insurance_url" | "permit_number" | "permit_expiry_date" | "permit_url" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["vehicle"]>
  export type VehicleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle_type?: boolean | VehicleTypeDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    driver?: boolean | Vehicle$driverArgs<ExtArgs>
  }
  export type VehicleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle_type?: boolean | VehicleTypeDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    driver?: boolean | Vehicle$driverArgs<ExtArgs>
  }
  export type VehicleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle_type?: boolean | VehicleTypeDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    driver?: boolean | Vehicle$driverArgs<ExtArgs>
  }

  export type $VehiclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vehicle"
    objects: {
      vehicle_type: Prisma.$VehicleTypePayload<ExtArgs>
      vendor: Prisma.$VendorPayload<ExtArgs>
      driver: Prisma.$DriverPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      vehicle_id: number
      vehicle_type_id: number
      vendor_id: number
      driver_id: number | null
      rc_number: string
      rc_expiry_date: Date | null
      description: string | null
      puc_number: string | null
      puc_expiry_date: Date | null
      puc_url: string | null
      fitness_number: string | null
      fitness_expiry_date: Date | null
      fitness_url: string | null
      tax_receipt_number: string | null
      tax_receipt_date: Date | null
      tax_receipt_url: string | null
      insurance_number: string | null
      insurance_expiry_date: Date | null
      insurance_url: string | null
      permit_number: string | null
      permit_expiry_date: Date | null
      permit_url: string | null
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["vehicle"]>
    composites: {}
  }

  type VehicleGetPayload<S extends boolean | null | undefined | VehicleDefaultArgs> = $Result.GetResult<Prisma.$VehiclePayload, S>

  type VehicleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VehicleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VehicleCountAggregateInputType | true
    }

  export interface VehicleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vehicle'], meta: { name: 'Vehicle' } }
    /**
     * Find zero or one Vehicle that matches the filter.
     * @param {VehicleFindUniqueArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleFindUniqueArgs>(args: SelectSubset<T, VehicleFindUniqueArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vehicle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VehicleFindUniqueOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleFindFirstArgs>(args?: SelectSubset<T, VehicleFindFirstArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicles
     * const vehicles = await prisma.vehicle.findMany()
     * 
     * // Get first 10 Vehicles
     * const vehicles = await prisma.vehicle.findMany({ take: 10 })
     * 
     * // Only select the `vehicle_id`
     * const vehicleWithVehicle_idOnly = await prisma.vehicle.findMany({ select: { vehicle_id: true } })
     * 
     */
    findMany<T extends VehicleFindManyArgs>(args?: SelectSubset<T, VehicleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vehicle.
     * @param {VehicleCreateArgs} args - Arguments to create a Vehicle.
     * @example
     * // Create one Vehicle
     * const Vehicle = await prisma.vehicle.create({
     *   data: {
     *     // ... data to create a Vehicle
     *   }
     * })
     * 
     */
    create<T extends VehicleCreateArgs>(args: SelectSubset<T, VehicleCreateArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vehicles.
     * @param {VehicleCreateManyArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicle = await prisma.vehicle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleCreateManyArgs>(args?: SelectSubset<T, VehicleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vehicles and returns the data saved in the database.
     * @param {VehicleCreateManyAndReturnArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicle = await prisma.vehicle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vehicles and only return the `vehicle_id`
     * const vehicleWithVehicle_idOnly = await prisma.vehicle.createManyAndReturn({
     *   select: { vehicle_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vehicle.
     * @param {VehicleDeleteArgs} args - Arguments to delete one Vehicle.
     * @example
     * // Delete one Vehicle
     * const Vehicle = await prisma.vehicle.delete({
     *   where: {
     *     // ... filter to delete one Vehicle
     *   }
     * })
     * 
     */
    delete<T extends VehicleDeleteArgs>(args: SelectSubset<T, VehicleDeleteArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vehicle.
     * @param {VehicleUpdateArgs} args - Arguments to update one Vehicle.
     * @example
     * // Update one Vehicle
     * const vehicle = await prisma.vehicle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleUpdateArgs>(args: SelectSubset<T, VehicleUpdateArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vehicles.
     * @param {VehicleDeleteManyArgs} args - Arguments to filter Vehicles to delete.
     * @example
     * // Delete a few Vehicles
     * const { count } = await prisma.vehicle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleDeleteManyArgs>(args?: SelectSubset<T, VehicleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicles
     * const vehicle = await prisma.vehicle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleUpdateManyArgs>(args: SelectSubset<T, VehicleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles and returns the data updated in the database.
     * @param {VehicleUpdateManyAndReturnArgs} args - Arguments to update many Vehicles.
     * @example
     * // Update many Vehicles
     * const vehicle = await prisma.vehicle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vehicles and only return the `vehicle_id`
     * const vehicleWithVehicle_idOnly = await prisma.vehicle.updateManyAndReturn({
     *   select: { vehicle_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VehicleUpdateManyAndReturnArgs>(args: SelectSubset<T, VehicleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vehicle.
     * @param {VehicleUpsertArgs} args - Arguments to update or create a Vehicle.
     * @example
     * // Update or create a Vehicle
     * const vehicle = await prisma.vehicle.upsert({
     *   create: {
     *     // ... data to create a Vehicle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle we want to update
     *   }
     * })
     */
    upsert<T extends VehicleUpsertArgs>(args: SelectSubset<T, VehicleUpsertArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleCountArgs} args - Arguments to filter Vehicles to count.
     * @example
     * // Count the number of Vehicles
     * const count = await prisma.vehicle.count({
     *   where: {
     *     // ... the filter for the Vehicles we want to count
     *   }
     * })
    **/
    count<T extends VehicleCountArgs>(
      args?: Subset<T, VehicleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleAggregateArgs>(args: Subset<T, VehicleAggregateArgs>): Prisma.PrismaPromise<GetVehicleAggregateType<T>>

    /**
     * Group by Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleGroupByArgs['orderBy'] }
        : { orderBy?: VehicleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vehicle model
   */
  readonly fields: VehicleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vehicle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicle_type<T extends VehicleTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleTypeDefaultArgs<ExtArgs>>): Prisma__VehicleTypeClient<$Result.GetResult<Prisma.$VehicleTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    driver<T extends Vehicle$driverArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$driverArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vehicle model
   */
  interface VehicleFieldRefs {
    readonly vehicle_id: FieldRef<"Vehicle", 'Int'>
    readonly vehicle_type_id: FieldRef<"Vehicle", 'Int'>
    readonly vendor_id: FieldRef<"Vehicle", 'Int'>
    readonly driver_id: FieldRef<"Vehicle", 'Int'>
    readonly rc_number: FieldRef<"Vehicle", 'String'>
    readonly rc_expiry_date: FieldRef<"Vehicle", 'DateTime'>
    readonly description: FieldRef<"Vehicle", 'String'>
    readonly puc_number: FieldRef<"Vehicle", 'String'>
    readonly puc_expiry_date: FieldRef<"Vehicle", 'DateTime'>
    readonly puc_url: FieldRef<"Vehicle", 'String'>
    readonly fitness_number: FieldRef<"Vehicle", 'String'>
    readonly fitness_expiry_date: FieldRef<"Vehicle", 'DateTime'>
    readonly fitness_url: FieldRef<"Vehicle", 'String'>
    readonly tax_receipt_number: FieldRef<"Vehicle", 'String'>
    readonly tax_receipt_date: FieldRef<"Vehicle", 'DateTime'>
    readonly tax_receipt_url: FieldRef<"Vehicle", 'String'>
    readonly insurance_number: FieldRef<"Vehicle", 'String'>
    readonly insurance_expiry_date: FieldRef<"Vehicle", 'DateTime'>
    readonly insurance_url: FieldRef<"Vehicle", 'String'>
    readonly permit_number: FieldRef<"Vehicle", 'String'>
    readonly permit_expiry_date: FieldRef<"Vehicle", 'DateTime'>
    readonly permit_url: FieldRef<"Vehicle", 'String'>
    readonly is_active: FieldRef<"Vehicle", 'Boolean'>
    readonly created_at: FieldRef<"Vehicle", 'DateTime'>
    readonly updated_at: FieldRef<"Vehicle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vehicle findUnique
   */
  export type VehicleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle findUniqueOrThrow
   */
  export type VehicleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle findFirst
   */
  export type VehicleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle findFirstOrThrow
   */
  export type VehicleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle findMany
   */
  export type VehicleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicles to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle create
   */
  export type VehicleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to create a Vehicle.
     */
    data: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
  }

  /**
   * Vehicle createMany
   */
  export type VehicleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vehicle createManyAndReturn
   */
  export type VehicleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vehicle update
   */
  export type VehicleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to update a Vehicle.
     */
    data: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
    /**
     * Choose, which Vehicle to update.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle updateMany
   */
  export type VehicleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vehicles.
     */
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyInput>
    /**
     * Filter which Vehicles to update
     */
    where?: VehicleWhereInput
    /**
     * Limit how many Vehicles to update.
     */
    limit?: number
  }

  /**
   * Vehicle updateManyAndReturn
   */
  export type VehicleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * The data used to update Vehicles.
     */
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyInput>
    /**
     * Filter which Vehicles to update
     */
    where?: VehicleWhereInput
    /**
     * Limit how many Vehicles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vehicle upsert
   */
  export type VehicleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The filter to search for the Vehicle to update in case it exists.
     */
    where: VehicleWhereUniqueInput
    /**
     * In case the Vehicle found by the `where` argument doesn't exist, create a new Vehicle with this data.
     */
    create: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
    /**
     * In case the Vehicle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
  }

  /**
   * Vehicle delete
   */
  export type VehicleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter which Vehicle to delete.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle deleteMany
   */
  export type VehicleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicles to delete
     */
    where?: VehicleWhereInput
    /**
     * Limit how many Vehicles to delete.
     */
    limit?: number
  }

  /**
   * Vehicle.driver
   */
  export type Vehicle$driverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    where?: DriverWhereInput
  }

  /**
   * Vehicle without action
   */
  export type VehicleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
  }


  /**
   * Model VehicleType
   */

  export type AggregateVehicleType = {
    _count: VehicleTypeCountAggregateOutputType | null
    _avg: VehicleTypeAvgAggregateOutputType | null
    _sum: VehicleTypeSumAggregateOutputType | null
    _min: VehicleTypeMinAggregateOutputType | null
    _max: VehicleTypeMaxAggregateOutputType | null
  }

  export type VehicleTypeAvgAggregateOutputType = {
    vehicle_type_id: number | null
    vendor_id: number | null
    seats: number | null
  }

  export type VehicleTypeSumAggregateOutputType = {
    vehicle_type_id: number | null
    vendor_id: number | null
    seats: number | null
  }

  export type VehicleTypeMinAggregateOutputType = {
    vehicle_type_id: number | null
    vendor_id: number | null
    name: string | null
    description: string | null
    seats: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VehicleTypeMaxAggregateOutputType = {
    vehicle_type_id: number | null
    vendor_id: number | null
    name: string | null
    description: string | null
    seats: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VehicleTypeCountAggregateOutputType = {
    vehicle_type_id: number
    vendor_id: number
    name: number
    description: number
    seats: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type VehicleTypeAvgAggregateInputType = {
    vehicle_type_id?: true
    vendor_id?: true
    seats?: true
  }

  export type VehicleTypeSumAggregateInputType = {
    vehicle_type_id?: true
    vendor_id?: true
    seats?: true
  }

  export type VehicleTypeMinAggregateInputType = {
    vehicle_type_id?: true
    vendor_id?: true
    name?: true
    description?: true
    seats?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type VehicleTypeMaxAggregateInputType = {
    vehicle_type_id?: true
    vendor_id?: true
    name?: true
    description?: true
    seats?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type VehicleTypeCountAggregateInputType = {
    vehicle_type_id?: true
    vendor_id?: true
    name?: true
    description?: true
    seats?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type VehicleTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleType to aggregate.
     */
    where?: VehicleTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleTypes to fetch.
     */
    orderBy?: VehicleTypeOrderByWithRelationInput | VehicleTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VehicleTypes
    **/
    _count?: true | VehicleTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleTypeMaxAggregateInputType
  }

  export type GetVehicleTypeAggregateType<T extends VehicleTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicleType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicleType[P]>
      : GetScalarType<T[P], AggregateVehicleType[P]>
  }




  export type VehicleTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleTypeWhereInput
    orderBy?: VehicleTypeOrderByWithAggregationInput | VehicleTypeOrderByWithAggregationInput[]
    by: VehicleTypeScalarFieldEnum[] | VehicleTypeScalarFieldEnum
    having?: VehicleTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleTypeCountAggregateInputType | true
    _avg?: VehicleTypeAvgAggregateInputType
    _sum?: VehicleTypeSumAggregateInputType
    _min?: VehicleTypeMinAggregateInputType
    _max?: VehicleTypeMaxAggregateInputType
  }

  export type VehicleTypeGroupByOutputType = {
    vehicle_type_id: number
    vendor_id: number
    name: string
    description: string | null
    seats: number
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: VehicleTypeCountAggregateOutputType | null
    _avg: VehicleTypeAvgAggregateOutputType | null
    _sum: VehicleTypeSumAggregateOutputType | null
    _min: VehicleTypeMinAggregateOutputType | null
    _max: VehicleTypeMaxAggregateOutputType | null
  }

  type GetVehicleTypeGroupByPayload<T extends VehicleTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleTypeGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleTypeGroupByOutputType[P]>
        }
      >
    >


  export type VehicleTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    vehicle_type_id?: boolean
    vendor_id?: boolean
    name?: boolean
    description?: boolean
    seats?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    vehicles?: boolean | VehicleType$vehiclesArgs<ExtArgs>
    _count?: boolean | VehicleTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleType"]>

  export type VehicleTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    vehicle_type_id?: boolean
    vendor_id?: boolean
    name?: boolean
    description?: boolean
    seats?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleType"]>

  export type VehicleTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    vehicle_type_id?: boolean
    vendor_id?: boolean
    name?: boolean
    description?: boolean
    seats?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleType"]>

  export type VehicleTypeSelectScalar = {
    vehicle_type_id?: boolean
    vendor_id?: boolean
    name?: boolean
    description?: boolean
    seats?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type VehicleTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"vehicle_type_id" | "vendor_id" | "name" | "description" | "seats" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["vehicleType"]>
  export type VehicleTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    vehicles?: boolean | VehicleType$vehiclesArgs<ExtArgs>
    _count?: boolean | VehicleTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VehicleTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type VehicleTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $VehicleTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VehicleType"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
      vehicles: Prisma.$VehiclePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      vehicle_type_id: number
      vendor_id: number
      name: string
      description: string | null
      seats: number
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["vehicleType"]>
    composites: {}
  }

  type VehicleTypeGetPayload<S extends boolean | null | undefined | VehicleTypeDefaultArgs> = $Result.GetResult<Prisma.$VehicleTypePayload, S>

  type VehicleTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VehicleTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VehicleTypeCountAggregateInputType | true
    }

  export interface VehicleTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VehicleType'], meta: { name: 'VehicleType' } }
    /**
     * Find zero or one VehicleType that matches the filter.
     * @param {VehicleTypeFindUniqueArgs} args - Arguments to find a VehicleType
     * @example
     * // Get one VehicleType
     * const vehicleType = await prisma.vehicleType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleTypeFindUniqueArgs>(args: SelectSubset<T, VehicleTypeFindUniqueArgs<ExtArgs>>): Prisma__VehicleTypeClient<$Result.GetResult<Prisma.$VehicleTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VehicleType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VehicleTypeFindUniqueOrThrowArgs} args - Arguments to find a VehicleType
     * @example
     * // Get one VehicleType
     * const vehicleType = await prisma.vehicleType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleTypeClient<$Result.GetResult<Prisma.$VehicleTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VehicleType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleTypeFindFirstArgs} args - Arguments to find a VehicleType
     * @example
     * // Get one VehicleType
     * const vehicleType = await prisma.vehicleType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleTypeFindFirstArgs>(args?: SelectSubset<T, VehicleTypeFindFirstArgs<ExtArgs>>): Prisma__VehicleTypeClient<$Result.GetResult<Prisma.$VehicleTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VehicleType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleTypeFindFirstOrThrowArgs} args - Arguments to find a VehicleType
     * @example
     * // Get one VehicleType
     * const vehicleType = await prisma.vehicleType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleTypeClient<$Result.GetResult<Prisma.$VehicleTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VehicleTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VehicleTypes
     * const vehicleTypes = await prisma.vehicleType.findMany()
     * 
     * // Get first 10 VehicleTypes
     * const vehicleTypes = await prisma.vehicleType.findMany({ take: 10 })
     * 
     * // Only select the `vehicle_type_id`
     * const vehicleTypeWithVehicle_type_idOnly = await prisma.vehicleType.findMany({ select: { vehicle_type_id: true } })
     * 
     */
    findMany<T extends VehicleTypeFindManyArgs>(args?: SelectSubset<T, VehicleTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VehicleType.
     * @param {VehicleTypeCreateArgs} args - Arguments to create a VehicleType.
     * @example
     * // Create one VehicleType
     * const VehicleType = await prisma.vehicleType.create({
     *   data: {
     *     // ... data to create a VehicleType
     *   }
     * })
     * 
     */
    create<T extends VehicleTypeCreateArgs>(args: SelectSubset<T, VehicleTypeCreateArgs<ExtArgs>>): Prisma__VehicleTypeClient<$Result.GetResult<Prisma.$VehicleTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VehicleTypes.
     * @param {VehicleTypeCreateManyArgs} args - Arguments to create many VehicleTypes.
     * @example
     * // Create many VehicleTypes
     * const vehicleType = await prisma.vehicleType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleTypeCreateManyArgs>(args?: SelectSubset<T, VehicleTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VehicleTypes and returns the data saved in the database.
     * @param {VehicleTypeCreateManyAndReturnArgs} args - Arguments to create many VehicleTypes.
     * @example
     * // Create many VehicleTypes
     * const vehicleType = await prisma.vehicleType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VehicleTypes and only return the `vehicle_type_id`
     * const vehicleTypeWithVehicle_type_idOnly = await prisma.vehicleType.createManyAndReturn({
     *   select: { vehicle_type_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VehicleType.
     * @param {VehicleTypeDeleteArgs} args - Arguments to delete one VehicleType.
     * @example
     * // Delete one VehicleType
     * const VehicleType = await prisma.vehicleType.delete({
     *   where: {
     *     // ... filter to delete one VehicleType
     *   }
     * })
     * 
     */
    delete<T extends VehicleTypeDeleteArgs>(args: SelectSubset<T, VehicleTypeDeleteArgs<ExtArgs>>): Prisma__VehicleTypeClient<$Result.GetResult<Prisma.$VehicleTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VehicleType.
     * @param {VehicleTypeUpdateArgs} args - Arguments to update one VehicleType.
     * @example
     * // Update one VehicleType
     * const vehicleType = await prisma.vehicleType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleTypeUpdateArgs>(args: SelectSubset<T, VehicleTypeUpdateArgs<ExtArgs>>): Prisma__VehicleTypeClient<$Result.GetResult<Prisma.$VehicleTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VehicleTypes.
     * @param {VehicleTypeDeleteManyArgs} args - Arguments to filter VehicleTypes to delete.
     * @example
     * // Delete a few VehicleTypes
     * const { count } = await prisma.vehicleType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleTypeDeleteManyArgs>(args?: SelectSubset<T, VehicleTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VehicleTypes
     * const vehicleType = await prisma.vehicleType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleTypeUpdateManyArgs>(args: SelectSubset<T, VehicleTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleTypes and returns the data updated in the database.
     * @param {VehicleTypeUpdateManyAndReturnArgs} args - Arguments to update many VehicleTypes.
     * @example
     * // Update many VehicleTypes
     * const vehicleType = await prisma.vehicleType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VehicleTypes and only return the `vehicle_type_id`
     * const vehicleTypeWithVehicle_type_idOnly = await prisma.vehicleType.updateManyAndReturn({
     *   select: { vehicle_type_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VehicleTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, VehicleTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VehicleType.
     * @param {VehicleTypeUpsertArgs} args - Arguments to update or create a VehicleType.
     * @example
     * // Update or create a VehicleType
     * const vehicleType = await prisma.vehicleType.upsert({
     *   create: {
     *     // ... data to create a VehicleType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VehicleType we want to update
     *   }
     * })
     */
    upsert<T extends VehicleTypeUpsertArgs>(args: SelectSubset<T, VehicleTypeUpsertArgs<ExtArgs>>): Prisma__VehicleTypeClient<$Result.GetResult<Prisma.$VehicleTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VehicleTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleTypeCountArgs} args - Arguments to filter VehicleTypes to count.
     * @example
     * // Count the number of VehicleTypes
     * const count = await prisma.vehicleType.count({
     *   where: {
     *     // ... the filter for the VehicleTypes we want to count
     *   }
     * })
    **/
    count<T extends VehicleTypeCountArgs>(
      args?: Subset<T, VehicleTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VehicleType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleTypeAggregateArgs>(args: Subset<T, VehicleTypeAggregateArgs>): Prisma.PrismaPromise<GetVehicleTypeAggregateType<T>>

    /**
     * Group by VehicleType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleTypeGroupByArgs['orderBy'] }
        : { orderBy?: VehicleTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VehicleType model
   */
  readonly fields: VehicleTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VehicleType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vehicles<T extends VehicleType$vehiclesArgs<ExtArgs> = {}>(args?: Subset<T, VehicleType$vehiclesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VehicleType model
   */
  interface VehicleTypeFieldRefs {
    readonly vehicle_type_id: FieldRef<"VehicleType", 'Int'>
    readonly vendor_id: FieldRef<"VehicleType", 'Int'>
    readonly name: FieldRef<"VehicleType", 'String'>
    readonly description: FieldRef<"VehicleType", 'String'>
    readonly seats: FieldRef<"VehicleType", 'Int'>
    readonly is_active: FieldRef<"VehicleType", 'Boolean'>
    readonly created_at: FieldRef<"VehicleType", 'DateTime'>
    readonly updated_at: FieldRef<"VehicleType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VehicleType findUnique
   */
  export type VehicleTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleType
     */
    select?: VehicleTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleType
     */
    omit?: VehicleTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTypeInclude<ExtArgs> | null
    /**
     * Filter, which VehicleType to fetch.
     */
    where: VehicleTypeWhereUniqueInput
  }

  /**
   * VehicleType findUniqueOrThrow
   */
  export type VehicleTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleType
     */
    select?: VehicleTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleType
     */
    omit?: VehicleTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTypeInclude<ExtArgs> | null
    /**
     * Filter, which VehicleType to fetch.
     */
    where: VehicleTypeWhereUniqueInput
  }

  /**
   * VehicleType findFirst
   */
  export type VehicleTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleType
     */
    select?: VehicleTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleType
     */
    omit?: VehicleTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTypeInclude<ExtArgs> | null
    /**
     * Filter, which VehicleType to fetch.
     */
    where?: VehicleTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleTypes to fetch.
     */
    orderBy?: VehicleTypeOrderByWithRelationInput | VehicleTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleTypes.
     */
    cursor?: VehicleTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleTypes.
     */
    distinct?: VehicleTypeScalarFieldEnum | VehicleTypeScalarFieldEnum[]
  }

  /**
   * VehicleType findFirstOrThrow
   */
  export type VehicleTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleType
     */
    select?: VehicleTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleType
     */
    omit?: VehicleTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTypeInclude<ExtArgs> | null
    /**
     * Filter, which VehicleType to fetch.
     */
    where?: VehicleTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleTypes to fetch.
     */
    orderBy?: VehicleTypeOrderByWithRelationInput | VehicleTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleTypes.
     */
    cursor?: VehicleTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleTypes.
     */
    distinct?: VehicleTypeScalarFieldEnum | VehicleTypeScalarFieldEnum[]
  }

  /**
   * VehicleType findMany
   */
  export type VehicleTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleType
     */
    select?: VehicleTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleType
     */
    omit?: VehicleTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTypeInclude<ExtArgs> | null
    /**
     * Filter, which VehicleTypes to fetch.
     */
    where?: VehicleTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleTypes to fetch.
     */
    orderBy?: VehicleTypeOrderByWithRelationInput | VehicleTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VehicleTypes.
     */
    cursor?: VehicleTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleTypes.
     */
    skip?: number
    distinct?: VehicleTypeScalarFieldEnum | VehicleTypeScalarFieldEnum[]
  }

  /**
   * VehicleType create
   */
  export type VehicleTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleType
     */
    select?: VehicleTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleType
     */
    omit?: VehicleTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a VehicleType.
     */
    data: XOR<VehicleTypeCreateInput, VehicleTypeUncheckedCreateInput>
  }

  /**
   * VehicleType createMany
   */
  export type VehicleTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VehicleTypes.
     */
    data: VehicleTypeCreateManyInput | VehicleTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VehicleType createManyAndReturn
   */
  export type VehicleTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleType
     */
    select?: VehicleTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleType
     */
    omit?: VehicleTypeOmit<ExtArgs> | null
    /**
     * The data used to create many VehicleTypes.
     */
    data: VehicleTypeCreateManyInput | VehicleTypeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VehicleType update
   */
  export type VehicleTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleType
     */
    select?: VehicleTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleType
     */
    omit?: VehicleTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a VehicleType.
     */
    data: XOR<VehicleTypeUpdateInput, VehicleTypeUncheckedUpdateInput>
    /**
     * Choose, which VehicleType to update.
     */
    where: VehicleTypeWhereUniqueInput
  }

  /**
   * VehicleType updateMany
   */
  export type VehicleTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VehicleTypes.
     */
    data: XOR<VehicleTypeUpdateManyMutationInput, VehicleTypeUncheckedUpdateManyInput>
    /**
     * Filter which VehicleTypes to update
     */
    where?: VehicleTypeWhereInput
    /**
     * Limit how many VehicleTypes to update.
     */
    limit?: number
  }

  /**
   * VehicleType updateManyAndReturn
   */
  export type VehicleTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleType
     */
    select?: VehicleTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleType
     */
    omit?: VehicleTypeOmit<ExtArgs> | null
    /**
     * The data used to update VehicleTypes.
     */
    data: XOR<VehicleTypeUpdateManyMutationInput, VehicleTypeUncheckedUpdateManyInput>
    /**
     * Filter which VehicleTypes to update
     */
    where?: VehicleTypeWhereInput
    /**
     * Limit how many VehicleTypes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTypeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VehicleType upsert
   */
  export type VehicleTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleType
     */
    select?: VehicleTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleType
     */
    omit?: VehicleTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the VehicleType to update in case it exists.
     */
    where: VehicleTypeWhereUniqueInput
    /**
     * In case the VehicleType found by the `where` argument doesn't exist, create a new VehicleType with this data.
     */
    create: XOR<VehicleTypeCreateInput, VehicleTypeUncheckedCreateInput>
    /**
     * In case the VehicleType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleTypeUpdateInput, VehicleTypeUncheckedUpdateInput>
  }

  /**
   * VehicleType delete
   */
  export type VehicleTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleType
     */
    select?: VehicleTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleType
     */
    omit?: VehicleTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTypeInclude<ExtArgs> | null
    /**
     * Filter which VehicleType to delete.
     */
    where: VehicleTypeWhereUniqueInput
  }

  /**
   * VehicleType deleteMany
   */
  export type VehicleTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleTypes to delete
     */
    where?: VehicleTypeWhereInput
    /**
     * Limit how many VehicleTypes to delete.
     */
    limit?: number
  }

  /**
   * VehicleType.vehicles
   */
  export type VehicleType$vehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    where?: VehicleWhereInput
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    cursor?: VehicleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * VehicleType without action
   */
  export type VehicleTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleType
     */
    select?: VehicleTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleType
     */
    omit?: VehicleTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTypeInclude<ExtArgs> | null
  }


  /**
   * Model Vendor
   */

  export type AggregateVendor = {
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  export type VendorAvgAggregateOutputType = {
    vendor_id: number | null
  }

  export type VendorSumAggregateOutputType = {
    vendor_id: number | null
  }

  export type VendorMinAggregateOutputType = {
    vendor_id: number | null
    tenant_id: string | null
    name: string | null
    vendor_code: string | null
    email: string | null
    phone: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VendorMaxAggregateOutputType = {
    vendor_id: number | null
    tenant_id: string | null
    name: string | null
    vendor_code: string | null
    email: string | null
    phone: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VendorCountAggregateOutputType = {
    vendor_id: number
    tenant_id: number
    name: number
    vendor_code: number
    email: number
    phone: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type VendorAvgAggregateInputType = {
    vendor_id?: true
  }

  export type VendorSumAggregateInputType = {
    vendor_id?: true
  }

  export type VendorMinAggregateInputType = {
    vendor_id?: true
    tenant_id?: true
    name?: true
    vendor_code?: true
    email?: true
    phone?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type VendorMaxAggregateInputType = {
    vendor_id?: true
    tenant_id?: true
    name?: true
    vendor_code?: true
    email?: true
    phone?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type VendorCountAggregateInputType = {
    vendor_id?: true
    tenant_id?: true
    name?: true
    vendor_code?: true
    email?: true
    phone?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type VendorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendor to aggregate.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vendors
    **/
    _count?: true | VendorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorMaxAggregateInputType
  }

  export type GetVendorAggregateType<T extends VendorAggregateArgs> = {
        [P in keyof T & keyof AggregateVendor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendor[P]>
      : GetScalarType<T[P], AggregateVendor[P]>
  }




  export type VendorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
    orderBy?: VendorOrderByWithAggregationInput | VendorOrderByWithAggregationInput[]
    by: VendorScalarFieldEnum[] | VendorScalarFieldEnum
    having?: VendorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorCountAggregateInputType | true
    _avg?: VendorAvgAggregateInputType
    _sum?: VendorSumAggregateInputType
    _min?: VendorMinAggregateInputType
    _max?: VendorMaxAggregateInputType
  }

  export type VendorGroupByOutputType = {
    vendor_id: number
    tenant_id: string
    name: string
    vendor_code: string
    email: string | null
    phone: string | null
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  type GetVendorGroupByPayload<T extends VendorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorGroupByOutputType[P]>
            : GetScalarType<T[P], VendorGroupByOutputType[P]>
        }
      >
    >


  export type VendorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    vendor_id?: boolean
    tenant_id?: boolean
    name?: boolean
    vendor_code?: boolean
    email?: boolean
    phone?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    drivers?: boolean | Vendor$driversArgs<ExtArgs>
    vehicle_types?: boolean | Vendor$vehicle_typesArgs<ExtArgs>
    vehicles?: boolean | Vendor$vehiclesArgs<ExtArgs>
    vendor_users?: boolean | Vendor$vendor_usersArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    vendor_id?: boolean
    tenant_id?: boolean
    name?: boolean
    vendor_code?: boolean
    email?: boolean
    phone?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    vendor_id?: boolean
    tenant_id?: boolean
    name?: boolean
    vendor_code?: boolean
    email?: boolean
    phone?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectScalar = {
    vendor_id?: boolean
    tenant_id?: boolean
    name?: boolean
    vendor_code?: boolean
    email?: boolean
    phone?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type VendorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"vendor_id" | "tenant_id" | "name" | "vendor_code" | "email" | "phone" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["vendor"]>
  export type VendorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    drivers?: boolean | Vendor$driversArgs<ExtArgs>
    vehicle_types?: boolean | Vendor$vehicle_typesArgs<ExtArgs>
    vehicles?: boolean | Vendor$vehiclesArgs<ExtArgs>
    vendor_users?: boolean | Vendor$vendor_usersArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VendorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type VendorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $VendorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vendor"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      drivers: Prisma.$DriverPayload<ExtArgs>[]
      vehicle_types: Prisma.$VehicleTypePayload<ExtArgs>[]
      vehicles: Prisma.$VehiclePayload<ExtArgs>[]
      vendor_users: Prisma.$VendorUserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      vendor_id: number
      tenant_id: string
      name: string
      vendor_code: string
      email: string | null
      phone: string | null
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["vendor"]>
    composites: {}
  }

  type VendorGetPayload<S extends boolean | null | undefined | VendorDefaultArgs> = $Result.GetResult<Prisma.$VendorPayload, S>

  type VendorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorCountAggregateInputType | true
    }

  export interface VendorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vendor'], meta: { name: 'Vendor' } }
    /**
     * Find zero or one Vendor that matches the filter.
     * @param {VendorFindUniqueArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorFindUniqueArgs>(args: SelectSubset<T, VendorFindUniqueArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vendor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorFindUniqueOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vendor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorFindFirstArgs>(args?: SelectSubset<T, VendorFindFirstArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vendor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendors
     * const vendors = await prisma.vendor.findMany()
     * 
     * // Get first 10 Vendors
     * const vendors = await prisma.vendor.findMany({ take: 10 })
     * 
     * // Only select the `vendor_id`
     * const vendorWithVendor_idOnly = await prisma.vendor.findMany({ select: { vendor_id: true } })
     * 
     */
    findMany<T extends VendorFindManyArgs>(args?: SelectSubset<T, VendorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vendor.
     * @param {VendorCreateArgs} args - Arguments to create a Vendor.
     * @example
     * // Create one Vendor
     * const Vendor = await prisma.vendor.create({
     *   data: {
     *     // ... data to create a Vendor
     *   }
     * })
     * 
     */
    create<T extends VendorCreateArgs>(args: SelectSubset<T, VendorCreateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vendors.
     * @param {VendorCreateManyArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorCreateManyArgs>(args?: SelectSubset<T, VendorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vendors and returns the data saved in the database.
     * @param {VendorCreateManyAndReturnArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vendors and only return the `vendor_id`
     * const vendorWithVendor_idOnly = await prisma.vendor.createManyAndReturn({
     *   select: { vendor_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vendor.
     * @param {VendorDeleteArgs} args - Arguments to delete one Vendor.
     * @example
     * // Delete one Vendor
     * const Vendor = await prisma.vendor.delete({
     *   where: {
     *     // ... filter to delete one Vendor
     *   }
     * })
     * 
     */
    delete<T extends VendorDeleteArgs>(args: SelectSubset<T, VendorDeleteArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vendor.
     * @param {VendorUpdateArgs} args - Arguments to update one Vendor.
     * @example
     * // Update one Vendor
     * const vendor = await prisma.vendor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorUpdateArgs>(args: SelectSubset<T, VendorUpdateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vendors.
     * @param {VendorDeleteManyArgs} args - Arguments to filter Vendors to delete.
     * @example
     * // Delete a few Vendors
     * const { count } = await prisma.vendor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorDeleteManyArgs>(args?: SelectSubset<T, VendorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorUpdateManyArgs>(args: SelectSubset<T, VendorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors and returns the data updated in the database.
     * @param {VendorUpdateManyAndReturnArgs} args - Arguments to update many Vendors.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vendors and only return the `vendor_id`
     * const vendorWithVendor_idOnly = await prisma.vendor.updateManyAndReturn({
     *   select: { vendor_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vendor.
     * @param {VendorUpsertArgs} args - Arguments to update or create a Vendor.
     * @example
     * // Update or create a Vendor
     * const vendor = await prisma.vendor.upsert({
     *   create: {
     *     // ... data to create a Vendor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendor we want to update
     *   }
     * })
     */
    upsert<T extends VendorUpsertArgs>(args: SelectSubset<T, VendorUpsertArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCountArgs} args - Arguments to filter Vendors to count.
     * @example
     * // Count the number of Vendors
     * const count = await prisma.vendor.count({
     *   where: {
     *     // ... the filter for the Vendors we want to count
     *   }
     * })
    **/
    count<T extends VendorCountArgs>(
      args?: Subset<T, VendorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorAggregateArgs>(args: Subset<T, VendorAggregateArgs>): Prisma.PrismaPromise<GetVendorAggregateType<T>>

    /**
     * Group by Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorGroupByArgs['orderBy'] }
        : { orderBy?: VendorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vendor model
   */
  readonly fields: VendorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vendor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    drivers<T extends Vendor$driversArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$driversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vehicle_types<T extends Vendor$vehicle_typesArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$vehicle_typesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vehicles<T extends Vendor$vehiclesArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$vehiclesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vendor_users<T extends Vendor$vendor_usersArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$vendor_usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vendor model
   */
  interface VendorFieldRefs {
    readonly vendor_id: FieldRef<"Vendor", 'Int'>
    readonly tenant_id: FieldRef<"Vendor", 'String'>
    readonly name: FieldRef<"Vendor", 'String'>
    readonly vendor_code: FieldRef<"Vendor", 'String'>
    readonly email: FieldRef<"Vendor", 'String'>
    readonly phone: FieldRef<"Vendor", 'String'>
    readonly is_active: FieldRef<"Vendor", 'Boolean'>
    readonly created_at: FieldRef<"Vendor", 'DateTime'>
    readonly updated_at: FieldRef<"Vendor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vendor findUnique
   */
  export type VendorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findUniqueOrThrow
   */
  export type VendorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findFirst
   */
  export type VendorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findFirstOrThrow
   */
  export type VendorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findMany
   */
  export type VendorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendors to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor create
   */
  export type VendorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to create a Vendor.
     */
    data: XOR<VendorCreateInput, VendorUncheckedCreateInput>
  }

  /**
   * Vendor createMany
   */
  export type VendorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vendor createManyAndReturn
   */
  export type VendorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vendor update
   */
  export type VendorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to update a Vendor.
     */
    data: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
    /**
     * Choose, which Vendor to update.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor updateMany
   */
  export type VendorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to update.
     */
    limit?: number
  }

  /**
   * Vendor updateManyAndReturn
   */
  export type VendorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vendor upsert
   */
  export type VendorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The filter to search for the Vendor to update in case it exists.
     */
    where: VendorWhereUniqueInput
    /**
     * In case the Vendor found by the `where` argument doesn't exist, create a new Vendor with this data.
     */
    create: XOR<VendorCreateInput, VendorUncheckedCreateInput>
    /**
     * In case the Vendor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
  }

  /**
   * Vendor delete
   */
  export type VendorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter which Vendor to delete.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor deleteMany
   */
  export type VendorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendors to delete
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to delete.
     */
    limit?: number
  }

  /**
   * Vendor.drivers
   */
  export type Vendor$driversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    where?: DriverWhereInput
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    cursor?: DriverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Vendor.vehicle_types
   */
  export type Vendor$vehicle_typesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleType
     */
    select?: VehicleTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleType
     */
    omit?: VehicleTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTypeInclude<ExtArgs> | null
    where?: VehicleTypeWhereInput
    orderBy?: VehicleTypeOrderByWithRelationInput | VehicleTypeOrderByWithRelationInput[]
    cursor?: VehicleTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleTypeScalarFieldEnum | VehicleTypeScalarFieldEnum[]
  }

  /**
   * Vendor.vehicles
   */
  export type Vendor$vehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    where?: VehicleWhereInput
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    cursor?: VehicleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vendor.vendor_users
   */
  export type Vendor$vendor_usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorUser
     */
    select?: VendorUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorUser
     */
    omit?: VendorUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorUserInclude<ExtArgs> | null
    where?: VendorUserWhereInput
    orderBy?: VendorUserOrderByWithRelationInput | VendorUserOrderByWithRelationInput[]
    cursor?: VendorUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorUserScalarFieldEnum | VendorUserScalarFieldEnum[]
  }

  /**
   * Vendor without action
   */
  export type VendorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
  }


  /**
   * Model VendorUser
   */

  export type AggregateVendorUser = {
    _count: VendorUserCountAggregateOutputType | null
    _avg: VendorUserAvgAggregateOutputType | null
    _sum: VendorUserSumAggregateOutputType | null
    _min: VendorUserMinAggregateOutputType | null
    _max: VendorUserMaxAggregateOutputType | null
  }

  export type VendorUserAvgAggregateOutputType = {
    vendor_user_id: number | null
    vendor_id: number | null
    role_id: number | null
  }

  export type VendorUserSumAggregateOutputType = {
    vendor_user_id: number | null
    vendor_id: number | null
    role_id: number | null
  }

  export type VendorUserMinAggregateOutputType = {
    vendor_user_id: number | null
    tenant_id: string | null
    vendor_id: number | null
    name: string | null
    email: string | null
    phone: string | null
    password: string | null
    role_id: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VendorUserMaxAggregateOutputType = {
    vendor_user_id: number | null
    tenant_id: string | null
    vendor_id: number | null
    name: string | null
    email: string | null
    phone: string | null
    password: string | null
    role_id: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VendorUserCountAggregateOutputType = {
    vendor_user_id: number
    tenant_id: number
    vendor_id: number
    name: number
    email: number
    phone: number
    password: number
    role_id: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type VendorUserAvgAggregateInputType = {
    vendor_user_id?: true
    vendor_id?: true
    role_id?: true
  }

  export type VendorUserSumAggregateInputType = {
    vendor_user_id?: true
    vendor_id?: true
    role_id?: true
  }

  export type VendorUserMinAggregateInputType = {
    vendor_user_id?: true
    tenant_id?: true
    vendor_id?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    role_id?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type VendorUserMaxAggregateInputType = {
    vendor_user_id?: true
    tenant_id?: true
    vendor_id?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    role_id?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type VendorUserCountAggregateInputType = {
    vendor_user_id?: true
    tenant_id?: true
    vendor_id?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    role_id?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type VendorUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorUser to aggregate.
     */
    where?: VendorUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorUsers to fetch.
     */
    orderBy?: VendorUserOrderByWithRelationInput | VendorUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VendorUsers
    **/
    _count?: true | VendorUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorUserMaxAggregateInputType
  }

  export type GetVendorUserAggregateType<T extends VendorUserAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorUser[P]>
      : GetScalarType<T[P], AggregateVendorUser[P]>
  }




  export type VendorUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorUserWhereInput
    orderBy?: VendorUserOrderByWithAggregationInput | VendorUserOrderByWithAggregationInput[]
    by: VendorUserScalarFieldEnum[] | VendorUserScalarFieldEnum
    having?: VendorUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorUserCountAggregateInputType | true
    _avg?: VendorUserAvgAggregateInputType
    _sum?: VendorUserSumAggregateInputType
    _min?: VendorUserMinAggregateInputType
    _max?: VendorUserMaxAggregateInputType
  }

  export type VendorUserGroupByOutputType = {
    vendor_user_id: number
    tenant_id: string
    vendor_id: number
    name: string
    email: string
    phone: string
    password: string
    role_id: number
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: VendorUserCountAggregateOutputType | null
    _avg: VendorUserAvgAggregateOutputType | null
    _sum: VendorUserSumAggregateOutputType | null
    _min: VendorUserMinAggregateOutputType | null
    _max: VendorUserMaxAggregateOutputType | null
  }

  type GetVendorUserGroupByPayload<T extends VendorUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorUserGroupByOutputType[P]>
            : GetScalarType<T[P], VendorUserGroupByOutputType[P]>
        }
      >
    >


  export type VendorUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    vendor_user_id?: boolean
    tenant_id?: boolean
    vendor_id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    role_id?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorUser"]>

  export type VendorUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    vendor_user_id?: boolean
    tenant_id?: boolean
    vendor_id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    role_id?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorUser"]>

  export type VendorUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    vendor_user_id?: boolean
    tenant_id?: boolean
    vendor_id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    role_id?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorUser"]>

  export type VendorUserSelectScalar = {
    vendor_user_id?: boolean
    tenant_id?: boolean
    vendor_id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    role_id?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type VendorUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"vendor_user_id" | "tenant_id" | "vendor_id" | "name" | "email" | "phone" | "password" | "role_id" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["vendorUser"]>
  export type VendorUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type VendorUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type VendorUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $VendorUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VendorUser"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      vendor_user_id: number
      tenant_id: string
      vendor_id: number
      name: string
      email: string
      phone: string
      password: string
      role_id: number
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["vendorUser"]>
    composites: {}
  }

  type VendorUserGetPayload<S extends boolean | null | undefined | VendorUserDefaultArgs> = $Result.GetResult<Prisma.$VendorUserPayload, S>

  type VendorUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorUserCountAggregateInputType | true
    }

  export interface VendorUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VendorUser'], meta: { name: 'VendorUser' } }
    /**
     * Find zero or one VendorUser that matches the filter.
     * @param {VendorUserFindUniqueArgs} args - Arguments to find a VendorUser
     * @example
     * // Get one VendorUser
     * const vendorUser = await prisma.vendorUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorUserFindUniqueArgs>(args: SelectSubset<T, VendorUserFindUniqueArgs<ExtArgs>>): Prisma__VendorUserClient<$Result.GetResult<Prisma.$VendorUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VendorUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorUserFindUniqueOrThrowArgs} args - Arguments to find a VendorUser
     * @example
     * // Get one VendorUser
     * const vendorUser = await prisma.vendorUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorUserFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorUserClient<$Result.GetResult<Prisma.$VendorUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUserFindFirstArgs} args - Arguments to find a VendorUser
     * @example
     * // Get one VendorUser
     * const vendorUser = await prisma.vendorUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorUserFindFirstArgs>(args?: SelectSubset<T, VendorUserFindFirstArgs<ExtArgs>>): Prisma__VendorUserClient<$Result.GetResult<Prisma.$VendorUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUserFindFirstOrThrowArgs} args - Arguments to find a VendorUser
     * @example
     * // Get one VendorUser
     * const vendorUser = await prisma.vendorUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorUserFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorUserClient<$Result.GetResult<Prisma.$VendorUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VendorUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorUsers
     * const vendorUsers = await prisma.vendorUser.findMany()
     * 
     * // Get first 10 VendorUsers
     * const vendorUsers = await prisma.vendorUser.findMany({ take: 10 })
     * 
     * // Only select the `vendor_user_id`
     * const vendorUserWithVendor_user_idOnly = await prisma.vendorUser.findMany({ select: { vendor_user_id: true } })
     * 
     */
    findMany<T extends VendorUserFindManyArgs>(args?: SelectSubset<T, VendorUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VendorUser.
     * @param {VendorUserCreateArgs} args - Arguments to create a VendorUser.
     * @example
     * // Create one VendorUser
     * const VendorUser = await prisma.vendorUser.create({
     *   data: {
     *     // ... data to create a VendorUser
     *   }
     * })
     * 
     */
    create<T extends VendorUserCreateArgs>(args: SelectSubset<T, VendorUserCreateArgs<ExtArgs>>): Prisma__VendorUserClient<$Result.GetResult<Prisma.$VendorUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VendorUsers.
     * @param {VendorUserCreateManyArgs} args - Arguments to create many VendorUsers.
     * @example
     * // Create many VendorUsers
     * const vendorUser = await prisma.vendorUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorUserCreateManyArgs>(args?: SelectSubset<T, VendorUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VendorUsers and returns the data saved in the database.
     * @param {VendorUserCreateManyAndReturnArgs} args - Arguments to create many VendorUsers.
     * @example
     * // Create many VendorUsers
     * const vendorUser = await prisma.vendorUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VendorUsers and only return the `vendor_user_id`
     * const vendorUserWithVendor_user_idOnly = await prisma.vendorUser.createManyAndReturn({
     *   select: { vendor_user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorUserCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VendorUser.
     * @param {VendorUserDeleteArgs} args - Arguments to delete one VendorUser.
     * @example
     * // Delete one VendorUser
     * const VendorUser = await prisma.vendorUser.delete({
     *   where: {
     *     // ... filter to delete one VendorUser
     *   }
     * })
     * 
     */
    delete<T extends VendorUserDeleteArgs>(args: SelectSubset<T, VendorUserDeleteArgs<ExtArgs>>): Prisma__VendorUserClient<$Result.GetResult<Prisma.$VendorUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VendorUser.
     * @param {VendorUserUpdateArgs} args - Arguments to update one VendorUser.
     * @example
     * // Update one VendorUser
     * const vendorUser = await prisma.vendorUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorUserUpdateArgs>(args: SelectSubset<T, VendorUserUpdateArgs<ExtArgs>>): Prisma__VendorUserClient<$Result.GetResult<Prisma.$VendorUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VendorUsers.
     * @param {VendorUserDeleteManyArgs} args - Arguments to filter VendorUsers to delete.
     * @example
     * // Delete a few VendorUsers
     * const { count } = await prisma.vendorUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorUserDeleteManyArgs>(args?: SelectSubset<T, VendorUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorUsers
     * const vendorUser = await prisma.vendorUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorUserUpdateManyArgs>(args: SelectSubset<T, VendorUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorUsers and returns the data updated in the database.
     * @param {VendorUserUpdateManyAndReturnArgs} args - Arguments to update many VendorUsers.
     * @example
     * // Update many VendorUsers
     * const vendorUser = await prisma.vendorUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VendorUsers and only return the `vendor_user_id`
     * const vendorUserWithVendor_user_idOnly = await prisma.vendorUser.updateManyAndReturn({
     *   select: { vendor_user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorUserUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VendorUser.
     * @param {VendorUserUpsertArgs} args - Arguments to update or create a VendorUser.
     * @example
     * // Update or create a VendorUser
     * const vendorUser = await prisma.vendorUser.upsert({
     *   create: {
     *     // ... data to create a VendorUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorUser we want to update
     *   }
     * })
     */
    upsert<T extends VendorUserUpsertArgs>(args: SelectSubset<T, VendorUserUpsertArgs<ExtArgs>>): Prisma__VendorUserClient<$Result.GetResult<Prisma.$VendorUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VendorUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUserCountArgs} args - Arguments to filter VendorUsers to count.
     * @example
     * // Count the number of VendorUsers
     * const count = await prisma.vendorUser.count({
     *   where: {
     *     // ... the filter for the VendorUsers we want to count
     *   }
     * })
    **/
    count<T extends VendorUserCountArgs>(
      args?: Subset<T, VendorUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorUserAggregateArgs>(args: Subset<T, VendorUserAggregateArgs>): Prisma.PrismaPromise<GetVendorUserAggregateType<T>>

    /**
     * Group by VendorUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorUserGroupByArgs['orderBy'] }
        : { orderBy?: VendorUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VendorUser model
   */
  readonly fields: VendorUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VendorUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VendorUser model
   */
  interface VendorUserFieldRefs {
    readonly vendor_user_id: FieldRef<"VendorUser", 'Int'>
    readonly tenant_id: FieldRef<"VendorUser", 'String'>
    readonly vendor_id: FieldRef<"VendorUser", 'Int'>
    readonly name: FieldRef<"VendorUser", 'String'>
    readonly email: FieldRef<"VendorUser", 'String'>
    readonly phone: FieldRef<"VendorUser", 'String'>
    readonly password: FieldRef<"VendorUser", 'String'>
    readonly role_id: FieldRef<"VendorUser", 'Int'>
    readonly is_active: FieldRef<"VendorUser", 'Boolean'>
    readonly created_at: FieldRef<"VendorUser", 'DateTime'>
    readonly updated_at: FieldRef<"VendorUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VendorUser findUnique
   */
  export type VendorUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorUser
     */
    select?: VendorUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorUser
     */
    omit?: VendorUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorUserInclude<ExtArgs> | null
    /**
     * Filter, which VendorUser to fetch.
     */
    where: VendorUserWhereUniqueInput
  }

  /**
   * VendorUser findUniqueOrThrow
   */
  export type VendorUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorUser
     */
    select?: VendorUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorUser
     */
    omit?: VendorUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorUserInclude<ExtArgs> | null
    /**
     * Filter, which VendorUser to fetch.
     */
    where: VendorUserWhereUniqueInput
  }

  /**
   * VendorUser findFirst
   */
  export type VendorUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorUser
     */
    select?: VendorUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorUser
     */
    omit?: VendorUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorUserInclude<ExtArgs> | null
    /**
     * Filter, which VendorUser to fetch.
     */
    where?: VendorUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorUsers to fetch.
     */
    orderBy?: VendorUserOrderByWithRelationInput | VendorUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorUsers.
     */
    cursor?: VendorUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorUsers.
     */
    distinct?: VendorUserScalarFieldEnum | VendorUserScalarFieldEnum[]
  }

  /**
   * VendorUser findFirstOrThrow
   */
  export type VendorUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorUser
     */
    select?: VendorUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorUser
     */
    omit?: VendorUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorUserInclude<ExtArgs> | null
    /**
     * Filter, which VendorUser to fetch.
     */
    where?: VendorUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorUsers to fetch.
     */
    orderBy?: VendorUserOrderByWithRelationInput | VendorUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorUsers.
     */
    cursor?: VendorUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorUsers.
     */
    distinct?: VendorUserScalarFieldEnum | VendorUserScalarFieldEnum[]
  }

  /**
   * VendorUser findMany
   */
  export type VendorUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorUser
     */
    select?: VendorUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorUser
     */
    omit?: VendorUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorUserInclude<ExtArgs> | null
    /**
     * Filter, which VendorUsers to fetch.
     */
    where?: VendorUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorUsers to fetch.
     */
    orderBy?: VendorUserOrderByWithRelationInput | VendorUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VendorUsers.
     */
    cursor?: VendorUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorUsers.
     */
    skip?: number
    distinct?: VendorUserScalarFieldEnum | VendorUserScalarFieldEnum[]
  }

  /**
   * VendorUser create
   */
  export type VendorUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorUser
     */
    select?: VendorUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorUser
     */
    omit?: VendorUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorUserInclude<ExtArgs> | null
    /**
     * The data needed to create a VendorUser.
     */
    data: XOR<VendorUserCreateInput, VendorUserUncheckedCreateInput>
  }

  /**
   * VendorUser createMany
   */
  export type VendorUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VendorUsers.
     */
    data: VendorUserCreateManyInput | VendorUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VendorUser createManyAndReturn
   */
  export type VendorUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorUser
     */
    select?: VendorUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorUser
     */
    omit?: VendorUserOmit<ExtArgs> | null
    /**
     * The data used to create many VendorUsers.
     */
    data: VendorUserCreateManyInput | VendorUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorUser update
   */
  export type VendorUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorUser
     */
    select?: VendorUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorUser
     */
    omit?: VendorUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorUserInclude<ExtArgs> | null
    /**
     * The data needed to update a VendorUser.
     */
    data: XOR<VendorUserUpdateInput, VendorUserUncheckedUpdateInput>
    /**
     * Choose, which VendorUser to update.
     */
    where: VendorUserWhereUniqueInput
  }

  /**
   * VendorUser updateMany
   */
  export type VendorUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VendorUsers.
     */
    data: XOR<VendorUserUpdateManyMutationInput, VendorUserUncheckedUpdateManyInput>
    /**
     * Filter which VendorUsers to update
     */
    where?: VendorUserWhereInput
    /**
     * Limit how many VendorUsers to update.
     */
    limit?: number
  }

  /**
   * VendorUser updateManyAndReturn
   */
  export type VendorUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorUser
     */
    select?: VendorUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorUser
     */
    omit?: VendorUserOmit<ExtArgs> | null
    /**
     * The data used to update VendorUsers.
     */
    data: XOR<VendorUserUpdateManyMutationInput, VendorUserUncheckedUpdateManyInput>
    /**
     * Filter which VendorUsers to update
     */
    where?: VendorUserWhereInput
    /**
     * Limit how many VendorUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorUser upsert
   */
  export type VendorUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorUser
     */
    select?: VendorUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorUser
     */
    omit?: VendorUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorUserInclude<ExtArgs> | null
    /**
     * The filter to search for the VendorUser to update in case it exists.
     */
    where: VendorUserWhereUniqueInput
    /**
     * In case the VendorUser found by the `where` argument doesn't exist, create a new VendorUser with this data.
     */
    create: XOR<VendorUserCreateInput, VendorUserUncheckedCreateInput>
    /**
     * In case the VendorUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorUserUpdateInput, VendorUserUncheckedUpdateInput>
  }

  /**
   * VendorUser delete
   */
  export type VendorUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorUser
     */
    select?: VendorUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorUser
     */
    omit?: VendorUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorUserInclude<ExtArgs> | null
    /**
     * Filter which VendorUser to delete.
     */
    where: VendorUserWhereUniqueInput
  }

  /**
   * VendorUser deleteMany
   */
  export type VendorUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorUsers to delete
     */
    where?: VendorUserWhereInput
    /**
     * Limit how many VendorUsers to delete.
     */
    limit?: number
  }

  /**
   * VendorUser without action
   */
  export type VendorUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorUser
     */
    select?: VendorUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorUser
     */
    omit?: VendorUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorUserInclude<ExtArgs> | null
  }


  /**
   * Model Cutoff
   */

  export type AggregateCutoff = {
    _count: CutoffCountAggregateOutputType | null
    _avg: CutoffAvgAggregateOutputType | null
    _sum: CutoffSumAggregateOutputType | null
    _min: CutoffMinAggregateOutputType | null
    _max: CutoffMaxAggregateOutputType | null
  }

  export type CutoffAvgAggregateOutputType = {
    booking_cutoff: number | null
    cancel_cutoff: number | null
  }

  export type CutoffSumAggregateOutputType = {
    booking_cutoff: number | null
    cancel_cutoff: number | null
  }

  export type CutoffMinAggregateOutputType = {
    tenant_id: string | null
    booking_cutoff: number | null
    cancel_cutoff: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CutoffMaxAggregateOutputType = {
    tenant_id: string | null
    booking_cutoff: number | null
    cancel_cutoff: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CutoffCountAggregateOutputType = {
    tenant_id: number
    booking_cutoff: number
    cancel_cutoff: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CutoffAvgAggregateInputType = {
    booking_cutoff?: true
    cancel_cutoff?: true
  }

  export type CutoffSumAggregateInputType = {
    booking_cutoff?: true
    cancel_cutoff?: true
  }

  export type CutoffMinAggregateInputType = {
    tenant_id?: true
    booking_cutoff?: true
    cancel_cutoff?: true
    created_at?: true
    updated_at?: true
  }

  export type CutoffMaxAggregateInputType = {
    tenant_id?: true
    booking_cutoff?: true
    cancel_cutoff?: true
    created_at?: true
    updated_at?: true
  }

  export type CutoffCountAggregateInputType = {
    tenant_id?: true
    booking_cutoff?: true
    cancel_cutoff?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CutoffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cutoff to aggregate.
     */
    where?: CutoffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cutoffs to fetch.
     */
    orderBy?: CutoffOrderByWithRelationInput | CutoffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CutoffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cutoffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cutoffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cutoffs
    **/
    _count?: true | CutoffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CutoffAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CutoffSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CutoffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CutoffMaxAggregateInputType
  }

  export type GetCutoffAggregateType<T extends CutoffAggregateArgs> = {
        [P in keyof T & keyof AggregateCutoff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCutoff[P]>
      : GetScalarType<T[P], AggregateCutoff[P]>
  }




  export type CutoffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CutoffWhereInput
    orderBy?: CutoffOrderByWithAggregationInput | CutoffOrderByWithAggregationInput[]
    by: CutoffScalarFieldEnum[] | CutoffScalarFieldEnum
    having?: CutoffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CutoffCountAggregateInputType | true
    _avg?: CutoffAvgAggregateInputType
    _sum?: CutoffSumAggregateInputType
    _min?: CutoffMinAggregateInputType
    _max?: CutoffMaxAggregateInputType
  }

  export type CutoffGroupByOutputType = {
    tenant_id: string
    booking_cutoff: number
    cancel_cutoff: number
    created_at: Date
    updated_at: Date
    _count: CutoffCountAggregateOutputType | null
    _avg: CutoffAvgAggregateOutputType | null
    _sum: CutoffSumAggregateOutputType | null
    _min: CutoffMinAggregateOutputType | null
    _max: CutoffMaxAggregateOutputType | null
  }

  type GetCutoffGroupByPayload<T extends CutoffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CutoffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CutoffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CutoffGroupByOutputType[P]>
            : GetScalarType<T[P], CutoffGroupByOutputType[P]>
        }
      >
    >


  export type CutoffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tenant_id?: boolean
    booking_cutoff?: boolean
    cancel_cutoff?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cutoff"]>

  export type CutoffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tenant_id?: boolean
    booking_cutoff?: boolean
    cancel_cutoff?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cutoff"]>

  export type CutoffSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tenant_id?: boolean
    booking_cutoff?: boolean
    cancel_cutoff?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cutoff"]>

  export type CutoffSelectScalar = {
    tenant_id?: boolean
    booking_cutoff?: boolean
    cancel_cutoff?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type CutoffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"tenant_id" | "booking_cutoff" | "cancel_cutoff" | "created_at" | "updated_at", ExtArgs["result"]["cutoff"]>
  export type CutoffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type CutoffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type CutoffIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $CutoffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cutoff"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      tenant_id: string
      booking_cutoff: number
      cancel_cutoff: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["cutoff"]>
    composites: {}
  }

  type CutoffGetPayload<S extends boolean | null | undefined | CutoffDefaultArgs> = $Result.GetResult<Prisma.$CutoffPayload, S>

  type CutoffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CutoffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CutoffCountAggregateInputType | true
    }

  export interface CutoffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cutoff'], meta: { name: 'Cutoff' } }
    /**
     * Find zero or one Cutoff that matches the filter.
     * @param {CutoffFindUniqueArgs} args - Arguments to find a Cutoff
     * @example
     * // Get one Cutoff
     * const cutoff = await prisma.cutoff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CutoffFindUniqueArgs>(args: SelectSubset<T, CutoffFindUniqueArgs<ExtArgs>>): Prisma__CutoffClient<$Result.GetResult<Prisma.$CutoffPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cutoff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CutoffFindUniqueOrThrowArgs} args - Arguments to find a Cutoff
     * @example
     * // Get one Cutoff
     * const cutoff = await prisma.cutoff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CutoffFindUniqueOrThrowArgs>(args: SelectSubset<T, CutoffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CutoffClient<$Result.GetResult<Prisma.$CutoffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cutoff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CutoffFindFirstArgs} args - Arguments to find a Cutoff
     * @example
     * // Get one Cutoff
     * const cutoff = await prisma.cutoff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CutoffFindFirstArgs>(args?: SelectSubset<T, CutoffFindFirstArgs<ExtArgs>>): Prisma__CutoffClient<$Result.GetResult<Prisma.$CutoffPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cutoff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CutoffFindFirstOrThrowArgs} args - Arguments to find a Cutoff
     * @example
     * // Get one Cutoff
     * const cutoff = await prisma.cutoff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CutoffFindFirstOrThrowArgs>(args?: SelectSubset<T, CutoffFindFirstOrThrowArgs<ExtArgs>>): Prisma__CutoffClient<$Result.GetResult<Prisma.$CutoffPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cutoffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CutoffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cutoffs
     * const cutoffs = await prisma.cutoff.findMany()
     * 
     * // Get first 10 Cutoffs
     * const cutoffs = await prisma.cutoff.findMany({ take: 10 })
     * 
     * // Only select the `tenant_id`
     * const cutoffWithTenant_idOnly = await prisma.cutoff.findMany({ select: { tenant_id: true } })
     * 
     */
    findMany<T extends CutoffFindManyArgs>(args?: SelectSubset<T, CutoffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CutoffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cutoff.
     * @param {CutoffCreateArgs} args - Arguments to create a Cutoff.
     * @example
     * // Create one Cutoff
     * const Cutoff = await prisma.cutoff.create({
     *   data: {
     *     // ... data to create a Cutoff
     *   }
     * })
     * 
     */
    create<T extends CutoffCreateArgs>(args: SelectSubset<T, CutoffCreateArgs<ExtArgs>>): Prisma__CutoffClient<$Result.GetResult<Prisma.$CutoffPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cutoffs.
     * @param {CutoffCreateManyArgs} args - Arguments to create many Cutoffs.
     * @example
     * // Create many Cutoffs
     * const cutoff = await prisma.cutoff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CutoffCreateManyArgs>(args?: SelectSubset<T, CutoffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cutoffs and returns the data saved in the database.
     * @param {CutoffCreateManyAndReturnArgs} args - Arguments to create many Cutoffs.
     * @example
     * // Create many Cutoffs
     * const cutoff = await prisma.cutoff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cutoffs and only return the `tenant_id`
     * const cutoffWithTenant_idOnly = await prisma.cutoff.createManyAndReturn({
     *   select: { tenant_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CutoffCreateManyAndReturnArgs>(args?: SelectSubset<T, CutoffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CutoffPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cutoff.
     * @param {CutoffDeleteArgs} args - Arguments to delete one Cutoff.
     * @example
     * // Delete one Cutoff
     * const Cutoff = await prisma.cutoff.delete({
     *   where: {
     *     // ... filter to delete one Cutoff
     *   }
     * })
     * 
     */
    delete<T extends CutoffDeleteArgs>(args: SelectSubset<T, CutoffDeleteArgs<ExtArgs>>): Prisma__CutoffClient<$Result.GetResult<Prisma.$CutoffPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cutoff.
     * @param {CutoffUpdateArgs} args - Arguments to update one Cutoff.
     * @example
     * // Update one Cutoff
     * const cutoff = await prisma.cutoff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CutoffUpdateArgs>(args: SelectSubset<T, CutoffUpdateArgs<ExtArgs>>): Prisma__CutoffClient<$Result.GetResult<Prisma.$CutoffPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cutoffs.
     * @param {CutoffDeleteManyArgs} args - Arguments to filter Cutoffs to delete.
     * @example
     * // Delete a few Cutoffs
     * const { count } = await prisma.cutoff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CutoffDeleteManyArgs>(args?: SelectSubset<T, CutoffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cutoffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CutoffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cutoffs
     * const cutoff = await prisma.cutoff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CutoffUpdateManyArgs>(args: SelectSubset<T, CutoffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cutoffs and returns the data updated in the database.
     * @param {CutoffUpdateManyAndReturnArgs} args - Arguments to update many Cutoffs.
     * @example
     * // Update many Cutoffs
     * const cutoff = await prisma.cutoff.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cutoffs and only return the `tenant_id`
     * const cutoffWithTenant_idOnly = await prisma.cutoff.updateManyAndReturn({
     *   select: { tenant_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CutoffUpdateManyAndReturnArgs>(args: SelectSubset<T, CutoffUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CutoffPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cutoff.
     * @param {CutoffUpsertArgs} args - Arguments to update or create a Cutoff.
     * @example
     * // Update or create a Cutoff
     * const cutoff = await prisma.cutoff.upsert({
     *   create: {
     *     // ... data to create a Cutoff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cutoff we want to update
     *   }
     * })
     */
    upsert<T extends CutoffUpsertArgs>(args: SelectSubset<T, CutoffUpsertArgs<ExtArgs>>): Prisma__CutoffClient<$Result.GetResult<Prisma.$CutoffPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cutoffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CutoffCountArgs} args - Arguments to filter Cutoffs to count.
     * @example
     * // Count the number of Cutoffs
     * const count = await prisma.cutoff.count({
     *   where: {
     *     // ... the filter for the Cutoffs we want to count
     *   }
     * })
    **/
    count<T extends CutoffCountArgs>(
      args?: Subset<T, CutoffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CutoffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cutoff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CutoffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CutoffAggregateArgs>(args: Subset<T, CutoffAggregateArgs>): Prisma.PrismaPromise<GetCutoffAggregateType<T>>

    /**
     * Group by Cutoff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CutoffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CutoffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CutoffGroupByArgs['orderBy'] }
        : { orderBy?: CutoffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CutoffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCutoffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cutoff model
   */
  readonly fields: CutoffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cutoff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CutoffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cutoff model
   */
  interface CutoffFieldRefs {
    readonly tenant_id: FieldRef<"Cutoff", 'String'>
    readonly booking_cutoff: FieldRef<"Cutoff", 'Int'>
    readonly cancel_cutoff: FieldRef<"Cutoff", 'Int'>
    readonly created_at: FieldRef<"Cutoff", 'DateTime'>
    readonly updated_at: FieldRef<"Cutoff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Cutoff findUnique
   */
  export type CutoffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cutoff
     */
    select?: CutoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cutoff
     */
    omit?: CutoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CutoffInclude<ExtArgs> | null
    /**
     * Filter, which Cutoff to fetch.
     */
    where: CutoffWhereUniqueInput
  }

  /**
   * Cutoff findUniqueOrThrow
   */
  export type CutoffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cutoff
     */
    select?: CutoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cutoff
     */
    omit?: CutoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CutoffInclude<ExtArgs> | null
    /**
     * Filter, which Cutoff to fetch.
     */
    where: CutoffWhereUniqueInput
  }

  /**
   * Cutoff findFirst
   */
  export type CutoffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cutoff
     */
    select?: CutoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cutoff
     */
    omit?: CutoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CutoffInclude<ExtArgs> | null
    /**
     * Filter, which Cutoff to fetch.
     */
    where?: CutoffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cutoffs to fetch.
     */
    orderBy?: CutoffOrderByWithRelationInput | CutoffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cutoffs.
     */
    cursor?: CutoffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cutoffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cutoffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cutoffs.
     */
    distinct?: CutoffScalarFieldEnum | CutoffScalarFieldEnum[]
  }

  /**
   * Cutoff findFirstOrThrow
   */
  export type CutoffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cutoff
     */
    select?: CutoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cutoff
     */
    omit?: CutoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CutoffInclude<ExtArgs> | null
    /**
     * Filter, which Cutoff to fetch.
     */
    where?: CutoffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cutoffs to fetch.
     */
    orderBy?: CutoffOrderByWithRelationInput | CutoffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cutoffs.
     */
    cursor?: CutoffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cutoffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cutoffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cutoffs.
     */
    distinct?: CutoffScalarFieldEnum | CutoffScalarFieldEnum[]
  }

  /**
   * Cutoff findMany
   */
  export type CutoffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cutoff
     */
    select?: CutoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cutoff
     */
    omit?: CutoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CutoffInclude<ExtArgs> | null
    /**
     * Filter, which Cutoffs to fetch.
     */
    where?: CutoffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cutoffs to fetch.
     */
    orderBy?: CutoffOrderByWithRelationInput | CutoffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cutoffs.
     */
    cursor?: CutoffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cutoffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cutoffs.
     */
    skip?: number
    distinct?: CutoffScalarFieldEnum | CutoffScalarFieldEnum[]
  }

  /**
   * Cutoff create
   */
  export type CutoffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cutoff
     */
    select?: CutoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cutoff
     */
    omit?: CutoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CutoffInclude<ExtArgs> | null
    /**
     * The data needed to create a Cutoff.
     */
    data: XOR<CutoffCreateInput, CutoffUncheckedCreateInput>
  }

  /**
   * Cutoff createMany
   */
  export type CutoffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cutoffs.
     */
    data: CutoffCreateManyInput | CutoffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cutoff createManyAndReturn
   */
  export type CutoffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cutoff
     */
    select?: CutoffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cutoff
     */
    omit?: CutoffOmit<ExtArgs> | null
    /**
     * The data used to create many Cutoffs.
     */
    data: CutoffCreateManyInput | CutoffCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CutoffIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cutoff update
   */
  export type CutoffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cutoff
     */
    select?: CutoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cutoff
     */
    omit?: CutoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CutoffInclude<ExtArgs> | null
    /**
     * The data needed to update a Cutoff.
     */
    data: XOR<CutoffUpdateInput, CutoffUncheckedUpdateInput>
    /**
     * Choose, which Cutoff to update.
     */
    where: CutoffWhereUniqueInput
  }

  /**
   * Cutoff updateMany
   */
  export type CutoffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cutoffs.
     */
    data: XOR<CutoffUpdateManyMutationInput, CutoffUncheckedUpdateManyInput>
    /**
     * Filter which Cutoffs to update
     */
    where?: CutoffWhereInput
    /**
     * Limit how many Cutoffs to update.
     */
    limit?: number
  }

  /**
   * Cutoff updateManyAndReturn
   */
  export type CutoffUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cutoff
     */
    select?: CutoffSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cutoff
     */
    omit?: CutoffOmit<ExtArgs> | null
    /**
     * The data used to update Cutoffs.
     */
    data: XOR<CutoffUpdateManyMutationInput, CutoffUncheckedUpdateManyInput>
    /**
     * Filter which Cutoffs to update
     */
    where?: CutoffWhereInput
    /**
     * Limit how many Cutoffs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CutoffIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cutoff upsert
   */
  export type CutoffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cutoff
     */
    select?: CutoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cutoff
     */
    omit?: CutoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CutoffInclude<ExtArgs> | null
    /**
     * The filter to search for the Cutoff to update in case it exists.
     */
    where: CutoffWhereUniqueInput
    /**
     * In case the Cutoff found by the `where` argument doesn't exist, create a new Cutoff with this data.
     */
    create: XOR<CutoffCreateInput, CutoffUncheckedCreateInput>
    /**
     * In case the Cutoff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CutoffUpdateInput, CutoffUncheckedUpdateInput>
  }

  /**
   * Cutoff delete
   */
  export type CutoffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cutoff
     */
    select?: CutoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cutoff
     */
    omit?: CutoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CutoffInclude<ExtArgs> | null
    /**
     * Filter which Cutoff to delete.
     */
    where: CutoffWhereUniqueInput
  }

  /**
   * Cutoff deleteMany
   */
  export type CutoffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cutoffs to delete
     */
    where?: CutoffWhereInput
    /**
     * Limit how many Cutoffs to delete.
     */
    limit?: number
  }

  /**
   * Cutoff without action
   */
  export type CutoffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cutoff
     */
    select?: CutoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cutoff
     */
    omit?: CutoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CutoffInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeAvgAggregateOutputType = {
    employee_id: number | null
    role_id: number | null
    team_id: number | null
    latitude: Decimal | null
    longitude: Decimal | null
  }

  export type EmployeeSumAggregateOutputType = {
    employee_id: number | null
    role_id: number | null
    team_id: number | null
    latitude: Decimal | null
    longitude: Decimal | null
  }

  export type EmployeeMinAggregateOutputType = {
    employee_id: number | null
    tenant_id: string | null
    role_id: number | null
    name: string | null
    employee_code: string | null
    email: string | null
    password: string | null
    team_id: number | null
    phone: string | null
    alternate_phone: string | null
    special_needs: string | null
    special_needs_start_date: Date | null
    special_needs_end_date: Date | null
    address: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    gender: $Enums.GenderEnum | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type EmployeeMaxAggregateOutputType = {
    employee_id: number | null
    tenant_id: string | null
    role_id: number | null
    name: string | null
    employee_code: string | null
    email: string | null
    password: string | null
    team_id: number | null
    phone: string | null
    alternate_phone: string | null
    special_needs: string | null
    special_needs_start_date: Date | null
    special_needs_end_date: Date | null
    address: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    gender: $Enums.GenderEnum | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type EmployeeCountAggregateOutputType = {
    employee_id: number
    tenant_id: number
    role_id: number
    name: number
    employee_code: number
    email: number
    password: number
    team_id: number
    phone: number
    alternate_phone: number
    special_needs: number
    special_needs_start_date: number
    special_needs_end_date: number
    address: number
    latitude: number
    longitude: number
    gender: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type EmployeeAvgAggregateInputType = {
    employee_id?: true
    role_id?: true
    team_id?: true
    latitude?: true
    longitude?: true
  }

  export type EmployeeSumAggregateInputType = {
    employee_id?: true
    role_id?: true
    team_id?: true
    latitude?: true
    longitude?: true
  }

  export type EmployeeMinAggregateInputType = {
    employee_id?: true
    tenant_id?: true
    role_id?: true
    name?: true
    employee_code?: true
    email?: true
    password?: true
    team_id?: true
    phone?: true
    alternate_phone?: true
    special_needs?: true
    special_needs_start_date?: true
    special_needs_end_date?: true
    address?: true
    latitude?: true
    longitude?: true
    gender?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type EmployeeMaxAggregateInputType = {
    employee_id?: true
    tenant_id?: true
    role_id?: true
    name?: true
    employee_code?: true
    email?: true
    password?: true
    team_id?: true
    phone?: true
    alternate_phone?: true
    special_needs?: true
    special_needs_start_date?: true
    special_needs_end_date?: true
    address?: true
    latitude?: true
    longitude?: true
    gender?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type EmployeeCountAggregateInputType = {
    employee_id?: true
    tenant_id?: true
    role_id?: true
    name?: true
    employee_code?: true
    email?: true
    password?: true
    team_id?: true
    phone?: true
    alternate_phone?: true
    special_needs?: true
    special_needs_start_date?: true
    special_needs_end_date?: true
    address?: true
    latitude?: true
    longitude?: true
    gender?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _avg?: EmployeeAvgAggregateInputType
    _sum?: EmployeeSumAggregateInputType
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    employee_id: number
    tenant_id: string
    role_id: number
    name: string
    employee_code: string
    email: string
    password: string
    team_id: number | null
    phone: string
    alternate_phone: string | null
    special_needs: string | null
    special_needs_start_date: Date | null
    special_needs_end_date: Date | null
    address: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    gender: $Enums.GenderEnum | null
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employee_id?: boolean
    tenant_id?: boolean
    role_id?: boolean
    name?: boolean
    employee_code?: boolean
    email?: boolean
    password?: boolean
    team_id?: boolean
    phone?: boolean
    alternate_phone?: boolean
    special_needs?: boolean
    special_needs_start_date?: boolean
    special_needs_end_date?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    gender?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    team?: boolean | Employee$teamArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    bookings?: boolean | Employee$bookingsArgs<ExtArgs>
    weekoff_config?: boolean | Employee$weekoff_configArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employee_id?: boolean
    tenant_id?: boolean
    role_id?: boolean
    name?: boolean
    employee_code?: boolean
    email?: boolean
    password?: boolean
    team_id?: boolean
    phone?: boolean
    alternate_phone?: boolean
    special_needs?: boolean
    special_needs_start_date?: boolean
    special_needs_end_date?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    gender?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    team?: boolean | Employee$teamArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employee_id?: boolean
    tenant_id?: boolean
    role_id?: boolean
    name?: boolean
    employee_code?: boolean
    email?: boolean
    password?: boolean
    team_id?: boolean
    phone?: boolean
    alternate_phone?: boolean
    special_needs?: boolean
    special_needs_start_date?: boolean
    special_needs_end_date?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    gender?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    team?: boolean | Employee$teamArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    employee_id?: boolean
    tenant_id?: boolean
    role_id?: boolean
    name?: boolean
    employee_code?: boolean
    email?: boolean
    password?: boolean
    team_id?: boolean
    phone?: boolean
    alternate_phone?: boolean
    special_needs?: boolean
    special_needs_start_date?: boolean
    special_needs_end_date?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    gender?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"employee_id" | "tenant_id" | "role_id" | "name" | "employee_code" | "email" | "password" | "team_id" | "phone" | "alternate_phone" | "special_needs" | "special_needs_start_date" | "special_needs_end_date" | "address" | "latitude" | "longitude" | "gender" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    team?: boolean | Employee$teamArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    bookings?: boolean | Employee$bookingsArgs<ExtArgs>
    weekoff_config?: boolean | Employee$weekoff_configArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    team?: boolean | Employee$teamArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    team?: boolean | Employee$teamArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs> | null
      role: Prisma.$RolePayload<ExtArgs>
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      weekoff_config: Prisma.$WeekoffConfigPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      employee_id: number
      tenant_id: string
      role_id: number
      name: string
      employee_code: string
      email: string
      password: string
      team_id: number | null
      phone: string
      alternate_phone: string | null
      special_needs: string | null
      special_needs_start_date: Date | null
      special_needs_end_date: Date | null
      address: string | null
      latitude: Prisma.Decimal | null
      longitude: Prisma.Decimal | null
      gender: $Enums.GenderEnum | null
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `employee_id`
     * const employeeWithEmployee_idOnly = await prisma.employee.findMany({ select: { employee_id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `employee_id`
     * const employeeWithEmployee_idOnly = await prisma.employee.createManyAndReturn({
     *   select: { employee_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {EmployeeUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `employee_id`
     * const employeeWithEmployee_idOnly = await prisma.employee.updateManyAndReturn({
     *   select: { employee_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    team<T extends Employee$teamArgs<ExtArgs> = {}>(args?: Subset<T, Employee$teamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bookings<T extends Employee$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    weekoff_config<T extends Employee$weekoff_configArgs<ExtArgs> = {}>(args?: Subset<T, Employee$weekoff_configArgs<ExtArgs>>): Prisma__WeekoffConfigClient<$Result.GetResult<Prisma.$WeekoffConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */
  interface EmployeeFieldRefs {
    readonly employee_id: FieldRef<"Employee", 'Int'>
    readonly tenant_id: FieldRef<"Employee", 'String'>
    readonly role_id: FieldRef<"Employee", 'Int'>
    readonly name: FieldRef<"Employee", 'String'>
    readonly employee_code: FieldRef<"Employee", 'String'>
    readonly email: FieldRef<"Employee", 'String'>
    readonly password: FieldRef<"Employee", 'String'>
    readonly team_id: FieldRef<"Employee", 'Int'>
    readonly phone: FieldRef<"Employee", 'String'>
    readonly alternate_phone: FieldRef<"Employee", 'String'>
    readonly special_needs: FieldRef<"Employee", 'String'>
    readonly special_needs_start_date: FieldRef<"Employee", 'DateTime'>
    readonly special_needs_end_date: FieldRef<"Employee", 'DateTime'>
    readonly address: FieldRef<"Employee", 'String'>
    readonly latitude: FieldRef<"Employee", 'Decimal'>
    readonly longitude: FieldRef<"Employee", 'Decimal'>
    readonly gender: FieldRef<"Employee", 'GenderEnum'>
    readonly is_active: FieldRef<"Employee", 'Boolean'>
    readonly created_at: FieldRef<"Employee", 'DateTime'>
    readonly updated_at: FieldRef<"Employee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee updateManyAndReturn
   */
  export type EmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employee.team
   */
  export type Employee$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * Employee.bookings
   */
  export type Employee$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Employee.weekoff_config
   */
  export type Employee$weekoff_configArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekoffConfig
     */
    select?: WeekoffConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekoffConfig
     */
    omit?: WeekoffConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekoffConfigInclude<ExtArgs> | null
    where?: WeekoffConfigWhereInput
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model Shift
   */

  export type AggregateShift = {
    _count: ShiftCountAggregateOutputType | null
    _avg: ShiftAvgAggregateOutputType | null
    _sum: ShiftSumAggregateOutputType | null
    _min: ShiftMinAggregateOutputType | null
    _max: ShiftMaxAggregateOutputType | null
  }

  export type ShiftAvgAggregateOutputType = {
    shift_id: number | null
    waiting_time_minutes: number | null
  }

  export type ShiftSumAggregateOutputType = {
    shift_id: number | null
    waiting_time_minutes: number | null
  }

  export type ShiftMinAggregateOutputType = {
    shift_id: number | null
    tenant_id: string | null
    shift_code: string | null
    log_type: $Enums.ShiftLogTypeEnum | null
    shift_time: Date | null
    pickup_type: $Enums.PickupTypeEnum | null
    gender: $Enums.GenderEnum | null
    waiting_time_minutes: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ShiftMaxAggregateOutputType = {
    shift_id: number | null
    tenant_id: string | null
    shift_code: string | null
    log_type: $Enums.ShiftLogTypeEnum | null
    shift_time: Date | null
    pickup_type: $Enums.PickupTypeEnum | null
    gender: $Enums.GenderEnum | null
    waiting_time_minutes: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ShiftCountAggregateOutputType = {
    shift_id: number
    tenant_id: number
    shift_code: number
    log_type: number
    shift_time: number
    pickup_type: number
    gender: number
    waiting_time_minutes: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ShiftAvgAggregateInputType = {
    shift_id?: true
    waiting_time_minutes?: true
  }

  export type ShiftSumAggregateInputType = {
    shift_id?: true
    waiting_time_minutes?: true
  }

  export type ShiftMinAggregateInputType = {
    shift_id?: true
    tenant_id?: true
    shift_code?: true
    log_type?: true
    shift_time?: true
    pickup_type?: true
    gender?: true
    waiting_time_minutes?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type ShiftMaxAggregateInputType = {
    shift_id?: true
    tenant_id?: true
    shift_code?: true
    log_type?: true
    shift_time?: true
    pickup_type?: true
    gender?: true
    waiting_time_minutes?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type ShiftCountAggregateInputType = {
    shift_id?: true
    tenant_id?: true
    shift_code?: true
    log_type?: true
    shift_time?: true
    pickup_type?: true
    gender?: true
    waiting_time_minutes?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ShiftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shift to aggregate.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shifts
    **/
    _count?: true | ShiftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShiftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShiftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShiftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShiftMaxAggregateInputType
  }

  export type GetShiftAggregateType<T extends ShiftAggregateArgs> = {
        [P in keyof T & keyof AggregateShift]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShift[P]>
      : GetScalarType<T[P], AggregateShift[P]>
  }




  export type ShiftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftWhereInput
    orderBy?: ShiftOrderByWithAggregationInput | ShiftOrderByWithAggregationInput[]
    by: ShiftScalarFieldEnum[] | ShiftScalarFieldEnum
    having?: ShiftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShiftCountAggregateInputType | true
    _avg?: ShiftAvgAggregateInputType
    _sum?: ShiftSumAggregateInputType
    _min?: ShiftMinAggregateInputType
    _max?: ShiftMaxAggregateInputType
  }

  export type ShiftGroupByOutputType = {
    shift_id: number
    tenant_id: string
    shift_code: string
    log_type: $Enums.ShiftLogTypeEnum
    shift_time: Date
    pickup_type: $Enums.PickupTypeEnum | null
    gender: $Enums.GenderEnum | null
    waiting_time_minutes: number
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: ShiftCountAggregateOutputType | null
    _avg: ShiftAvgAggregateOutputType | null
    _sum: ShiftSumAggregateOutputType | null
    _min: ShiftMinAggregateOutputType | null
    _max: ShiftMaxAggregateOutputType | null
  }

  type GetShiftGroupByPayload<T extends ShiftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShiftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShiftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShiftGroupByOutputType[P]>
            : GetScalarType<T[P], ShiftGroupByOutputType[P]>
        }
      >
    >


  export type ShiftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shift_id?: boolean
    tenant_id?: boolean
    shift_code?: boolean
    log_type?: boolean
    shift_time?: boolean
    pickup_type?: boolean
    gender?: boolean
    waiting_time_minutes?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    bookings?: boolean | Shift$bookingsArgs<ExtArgs>
    _count?: boolean | ShiftCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shift_id?: boolean
    tenant_id?: boolean
    shift_code?: boolean
    log_type?: boolean
    shift_time?: boolean
    pickup_type?: boolean
    gender?: boolean
    waiting_time_minutes?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shift_id?: boolean
    tenant_id?: boolean
    shift_code?: boolean
    log_type?: boolean
    shift_time?: boolean
    pickup_type?: boolean
    gender?: boolean
    waiting_time_minutes?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectScalar = {
    shift_id?: boolean
    tenant_id?: boolean
    shift_code?: boolean
    log_type?: boolean
    shift_time?: boolean
    pickup_type?: boolean
    gender?: boolean
    waiting_time_minutes?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ShiftOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"shift_id" | "tenant_id" | "shift_code" | "log_type" | "shift_time" | "pickup_type" | "gender" | "waiting_time_minutes" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["shift"]>
  export type ShiftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    bookings?: boolean | Shift$bookingsArgs<ExtArgs>
    _count?: boolean | ShiftCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShiftIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type ShiftIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $ShiftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shift"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      bookings: Prisma.$BookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      shift_id: number
      tenant_id: string
      shift_code: string
      log_type: $Enums.ShiftLogTypeEnum
      shift_time: Date
      pickup_type: $Enums.PickupTypeEnum | null
      gender: $Enums.GenderEnum | null
      waiting_time_minutes: number
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["shift"]>
    composites: {}
  }

  type ShiftGetPayload<S extends boolean | null | undefined | ShiftDefaultArgs> = $Result.GetResult<Prisma.$ShiftPayload, S>

  type ShiftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShiftFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShiftCountAggregateInputType | true
    }

  export interface ShiftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shift'], meta: { name: 'Shift' } }
    /**
     * Find zero or one Shift that matches the filter.
     * @param {ShiftFindUniqueArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShiftFindUniqueArgs>(args: SelectSubset<T, ShiftFindUniqueArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shift that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShiftFindUniqueOrThrowArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShiftFindUniqueOrThrowArgs>(args: SelectSubset<T, ShiftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shift that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindFirstArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShiftFindFirstArgs>(args?: SelectSubset<T, ShiftFindFirstArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shift that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindFirstOrThrowArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShiftFindFirstOrThrowArgs>(args?: SelectSubset<T, ShiftFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shifts
     * const shifts = await prisma.shift.findMany()
     * 
     * // Get first 10 Shifts
     * const shifts = await prisma.shift.findMany({ take: 10 })
     * 
     * // Only select the `shift_id`
     * const shiftWithShift_idOnly = await prisma.shift.findMany({ select: { shift_id: true } })
     * 
     */
    findMany<T extends ShiftFindManyArgs>(args?: SelectSubset<T, ShiftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shift.
     * @param {ShiftCreateArgs} args - Arguments to create a Shift.
     * @example
     * // Create one Shift
     * const Shift = await prisma.shift.create({
     *   data: {
     *     // ... data to create a Shift
     *   }
     * })
     * 
     */
    create<T extends ShiftCreateArgs>(args: SelectSubset<T, ShiftCreateArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shifts.
     * @param {ShiftCreateManyArgs} args - Arguments to create many Shifts.
     * @example
     * // Create many Shifts
     * const shift = await prisma.shift.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShiftCreateManyArgs>(args?: SelectSubset<T, ShiftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shifts and returns the data saved in the database.
     * @param {ShiftCreateManyAndReturnArgs} args - Arguments to create many Shifts.
     * @example
     * // Create many Shifts
     * const shift = await prisma.shift.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shifts and only return the `shift_id`
     * const shiftWithShift_idOnly = await prisma.shift.createManyAndReturn({
     *   select: { shift_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShiftCreateManyAndReturnArgs>(args?: SelectSubset<T, ShiftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Shift.
     * @param {ShiftDeleteArgs} args - Arguments to delete one Shift.
     * @example
     * // Delete one Shift
     * const Shift = await prisma.shift.delete({
     *   where: {
     *     // ... filter to delete one Shift
     *   }
     * })
     * 
     */
    delete<T extends ShiftDeleteArgs>(args: SelectSubset<T, ShiftDeleteArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shift.
     * @param {ShiftUpdateArgs} args - Arguments to update one Shift.
     * @example
     * // Update one Shift
     * const shift = await prisma.shift.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShiftUpdateArgs>(args: SelectSubset<T, ShiftUpdateArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shifts.
     * @param {ShiftDeleteManyArgs} args - Arguments to filter Shifts to delete.
     * @example
     * // Delete a few Shifts
     * const { count } = await prisma.shift.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShiftDeleteManyArgs>(args?: SelectSubset<T, ShiftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shifts
     * const shift = await prisma.shift.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShiftUpdateManyArgs>(args: SelectSubset<T, ShiftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shifts and returns the data updated in the database.
     * @param {ShiftUpdateManyAndReturnArgs} args - Arguments to update many Shifts.
     * @example
     * // Update many Shifts
     * const shift = await prisma.shift.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Shifts and only return the `shift_id`
     * const shiftWithShift_idOnly = await prisma.shift.updateManyAndReturn({
     *   select: { shift_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShiftUpdateManyAndReturnArgs>(args: SelectSubset<T, ShiftUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Shift.
     * @param {ShiftUpsertArgs} args - Arguments to update or create a Shift.
     * @example
     * // Update or create a Shift
     * const shift = await prisma.shift.upsert({
     *   create: {
     *     // ... data to create a Shift
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shift we want to update
     *   }
     * })
     */
    upsert<T extends ShiftUpsertArgs>(args: SelectSubset<T, ShiftUpsertArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftCountArgs} args - Arguments to filter Shifts to count.
     * @example
     * // Count the number of Shifts
     * const count = await prisma.shift.count({
     *   where: {
     *     // ... the filter for the Shifts we want to count
     *   }
     * })
    **/
    count<T extends ShiftCountArgs>(
      args?: Subset<T, ShiftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShiftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShiftAggregateArgs>(args: Subset<T, ShiftAggregateArgs>): Prisma.PrismaPromise<GetShiftAggregateType<T>>

    /**
     * Group by Shift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShiftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShiftGroupByArgs['orderBy'] }
        : { orderBy?: ShiftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShiftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShiftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shift model
   */
  readonly fields: ShiftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shift.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShiftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bookings<T extends Shift$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Shift$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shift model
   */
  interface ShiftFieldRefs {
    readonly shift_id: FieldRef<"Shift", 'Int'>
    readonly tenant_id: FieldRef<"Shift", 'String'>
    readonly shift_code: FieldRef<"Shift", 'String'>
    readonly log_type: FieldRef<"Shift", 'ShiftLogTypeEnum'>
    readonly shift_time: FieldRef<"Shift", 'DateTime'>
    readonly pickup_type: FieldRef<"Shift", 'PickupTypeEnum'>
    readonly gender: FieldRef<"Shift", 'GenderEnum'>
    readonly waiting_time_minutes: FieldRef<"Shift", 'Int'>
    readonly is_active: FieldRef<"Shift", 'Boolean'>
    readonly created_at: FieldRef<"Shift", 'DateTime'>
    readonly updated_at: FieldRef<"Shift", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Shift findUnique
   */
  export type ShiftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift findUniqueOrThrow
   */
  export type ShiftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift findFirst
   */
  export type ShiftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shifts.
     */
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift findFirstOrThrow
   */
  export type ShiftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shifts.
     */
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift findMany
   */
  export type ShiftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shifts to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift create
   */
  export type ShiftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The data needed to create a Shift.
     */
    data: XOR<ShiftCreateInput, ShiftUncheckedCreateInput>
  }

  /**
   * Shift createMany
   */
  export type ShiftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shifts.
     */
    data: ShiftCreateManyInput | ShiftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shift createManyAndReturn
   */
  export type ShiftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * The data used to create many Shifts.
     */
    data: ShiftCreateManyInput | ShiftCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shift update
   */
  export type ShiftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The data needed to update a Shift.
     */
    data: XOR<ShiftUpdateInput, ShiftUncheckedUpdateInput>
    /**
     * Choose, which Shift to update.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift updateMany
   */
  export type ShiftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shifts.
     */
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyInput>
    /**
     * Filter which Shifts to update
     */
    where?: ShiftWhereInput
    /**
     * Limit how many Shifts to update.
     */
    limit?: number
  }

  /**
   * Shift updateManyAndReturn
   */
  export type ShiftUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * The data used to update Shifts.
     */
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyInput>
    /**
     * Filter which Shifts to update
     */
    where?: ShiftWhereInput
    /**
     * Limit how many Shifts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shift upsert
   */
  export type ShiftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The filter to search for the Shift to update in case it exists.
     */
    where: ShiftWhereUniqueInput
    /**
     * In case the Shift found by the `where` argument doesn't exist, create a new Shift with this data.
     */
    create: XOR<ShiftCreateInput, ShiftUncheckedCreateInput>
    /**
     * In case the Shift was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShiftUpdateInput, ShiftUncheckedUpdateInput>
  }

  /**
   * Shift delete
   */
  export type ShiftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter which Shift to delete.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift deleteMany
   */
  export type ShiftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shifts to delete
     */
    where?: ShiftWhereInput
    /**
     * Limit how many Shifts to delete.
     */
    limit?: number
  }

  /**
   * Shift.bookings
   */
  export type Shift$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Shift without action
   */
  export type ShiftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamAvgAggregateOutputType = {
    team_id: number | null
  }

  export type TeamSumAggregateOutputType = {
    team_id: number | null
  }

  export type TeamMinAggregateOutputType = {
    team_id: number | null
    tenant_id: string | null
    name: string | null
    description: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TeamMaxAggregateOutputType = {
    team_id: number | null
    tenant_id: string | null
    name: string | null
    description: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TeamCountAggregateOutputType = {
    team_id: number
    tenant_id: number
    name: number
    description: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TeamAvgAggregateInputType = {
    team_id?: true
  }

  export type TeamSumAggregateInputType = {
    team_id?: true
  }

  export type TeamMinAggregateInputType = {
    team_id?: true
    tenant_id?: true
    name?: true
    description?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type TeamMaxAggregateInputType = {
    team_id?: true
    tenant_id?: true
    name?: true
    description?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type TeamCountAggregateInputType = {
    team_id?: true
    tenant_id?: true
    name?: true
    description?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _avg?: TeamAvgAggregateInputType
    _sum?: TeamSumAggregateInputType
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    team_id: number
    tenant_id: string
    name: string
    description: string | null
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    team_id?: boolean
    tenant_id?: boolean
    name?: boolean
    description?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    employees?: boolean | Team$employeesArgs<ExtArgs>
    bookings?: boolean | Team$bookingsArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    team_id?: boolean
    tenant_id?: boolean
    name?: boolean
    description?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    team_id?: boolean
    tenant_id?: boolean
    name?: boolean
    description?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    team_id?: boolean
    tenant_id?: boolean
    name?: boolean
    description?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type TeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"team_id" | "tenant_id" | "name" | "description" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["team"]>
  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    employees?: boolean | Team$employeesArgs<ExtArgs>
    bookings?: boolean | Team$bookingsArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TeamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      employees: Prisma.$EmployeePayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      team_id: number
      tenant_id: string
      name: string
      description: string | null
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `team_id`
     * const teamWithTeam_idOnly = await prisma.team.findMany({ select: { team_id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `team_id`
     * const teamWithTeam_idOnly = await prisma.team.createManyAndReturn({
     *   select: { team_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams and returns the data updated in the database.
     * @param {TeamUpdateManyAndReturnArgs} args - Arguments to update many Teams.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teams and only return the `team_id`
     * const teamWithTeam_idOnly = await prisma.team.updateManyAndReturn({
     *   select: { team_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employees<T extends Team$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Team$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookings<T extends Team$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Team$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */
  interface TeamFieldRefs {
    readonly team_id: FieldRef<"Team", 'Int'>
    readonly tenant_id: FieldRef<"Team", 'String'>
    readonly name: FieldRef<"Team", 'String'>
    readonly description: FieldRef<"Team", 'String'>
    readonly is_active: FieldRef<"Team", 'Boolean'>
    readonly created_at: FieldRef<"Team", 'DateTime'>
    readonly updated_at: FieldRef<"Team", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team updateManyAndReturn
   */
  export type TeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to delete.
     */
    limit?: number
  }

  /**
   * Team.employees
   */
  export type Team$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Team.bookings
   */
  export type Team$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _avg: TenantAvgAggregateOutputType | null
    _sum: TenantSumAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantAvgAggregateOutputType = {
    longitude: Decimal | null
    latitude: Decimal | null
  }

  export type TenantSumAggregateOutputType = {
    longitude: Decimal | null
    latitude: Decimal | null
  }

  export type TenantMinAggregateOutputType = {
    tenant_id: string | null
    name: string | null
    address: string | null
    longitude: Decimal | null
    latitude: Decimal | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    tenant_id: string | null
    name: string | null
    address: string | null
    longitude: Decimal | null
    latitude: Decimal | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TenantCountAggregateOutputType = {
    tenant_id: number
    name: number
    address: number
    longitude: number
    latitude: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TenantAvgAggregateInputType = {
    longitude?: true
    latitude?: true
  }

  export type TenantSumAggregateInputType = {
    longitude?: true
    latitude?: true
  }

  export type TenantMinAggregateInputType = {
    tenant_id?: true
    name?: true
    address?: true
    longitude?: true
    latitude?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type TenantMaxAggregateInputType = {
    tenant_id?: true
    name?: true
    address?: true
    longitude?: true
    latitude?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type TenantCountAggregateInputType = {
    tenant_id?: true
    name?: true
    address?: true
    longitude?: true
    latitude?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TenantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TenantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _avg?: TenantAvgAggregateInputType
    _sum?: TenantSumAggregateInputType
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    tenant_id: string
    name: string
    address: string | null
    longitude: Decimal | null
    latitude: Decimal | null
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: TenantCountAggregateOutputType | null
    _avg: TenantAvgAggregateOutputType | null
    _sum: TenantSumAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tenant_id?: boolean
    name?: boolean
    address?: boolean
    longitude?: boolean
    latitude?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    teams?: boolean | Tenant$teamsArgs<ExtArgs>
    employees?: boolean | Tenant$employeesArgs<ExtArgs>
    shifts?: boolean | Tenant$shiftsArgs<ExtArgs>
    bookings?: boolean | Tenant$bookingsArgs<ExtArgs>
    policies?: boolean | Tenant$policiesArgs<ExtArgs>
    cutoff?: boolean | Tenant$cutoffArgs<ExtArgs>
    vendors?: boolean | Tenant$vendorsArgs<ExtArgs>
    roles?: boolean | Tenant$rolesArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tenant_id?: boolean
    name?: boolean
    address?: boolean
    longitude?: boolean
    latitude?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tenant_id?: boolean
    name?: boolean
    address?: boolean
    longitude?: boolean
    latitude?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    tenant_id?: boolean
    name?: boolean
    address?: boolean
    longitude?: boolean
    latitude?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type TenantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"tenant_id" | "name" | "address" | "longitude" | "latitude" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["tenant"]>
  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teams?: boolean | Tenant$teamsArgs<ExtArgs>
    employees?: boolean | Tenant$employeesArgs<ExtArgs>
    shifts?: boolean | Tenant$shiftsArgs<ExtArgs>
    bookings?: boolean | Tenant$bookingsArgs<ExtArgs>
    policies?: boolean | Tenant$policiesArgs<ExtArgs>
    cutoff?: boolean | Tenant$cutoffArgs<ExtArgs>
    vendors?: boolean | Tenant$vendorsArgs<ExtArgs>
    roles?: boolean | Tenant$rolesArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TenantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      teams: Prisma.$TeamPayload<ExtArgs>[]
      employees: Prisma.$EmployeePayload<ExtArgs>[]
      shifts: Prisma.$ShiftPayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      policies: Prisma.$PolicyPayload<ExtArgs>[]
      cutoff: Prisma.$CutoffPayload<ExtArgs> | null
      vendors: Prisma.$VendorPayload<ExtArgs>[]
      roles: Prisma.$RolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      tenant_id: string
      name: string
      address: string | null
      longitude: Prisma.Decimal | null
      latitude: Prisma.Decimal | null
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `tenant_id`
     * const tenantWithTenant_idOnly = await prisma.tenant.findMany({ select: { tenant_id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `tenant_id`
     * const tenantWithTenant_idOnly = await prisma.tenant.createManyAndReturn({
     *   select: { tenant_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants and returns the data updated in the database.
     * @param {TenantUpdateManyAndReturnArgs} args - Arguments to update many Tenants.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tenants and only return the `tenant_id`
     * const tenantWithTenant_idOnly = await prisma.tenant.updateManyAndReturn({
     *   select: { tenant_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teams<T extends Tenant$teamsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employees<T extends Tenant$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shifts<T extends Tenant$shiftsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$shiftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookings<T extends Tenant$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    policies<T extends Tenant$policiesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$policiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cutoff<T extends Tenant$cutoffArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$cutoffArgs<ExtArgs>>): Prisma__CutoffClient<$Result.GetResult<Prisma.$CutoffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    vendors<T extends Tenant$vendorsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$vendorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roles<T extends Tenant$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */
  interface TenantFieldRefs {
    readonly tenant_id: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly address: FieldRef<"Tenant", 'String'>
    readonly longitude: FieldRef<"Tenant", 'Decimal'>
    readonly latitude: FieldRef<"Tenant", 'Decimal'>
    readonly is_active: FieldRef<"Tenant", 'Boolean'>
    readonly created_at: FieldRef<"Tenant", 'DateTime'>
    readonly updated_at: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant updateManyAndReturn
   */
  export type TenantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to delete.
     */
    limit?: number
  }

  /**
   * Tenant.teams
   */
  export type Tenant$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Tenant.employees
   */
  export type Tenant$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Tenant.shifts
   */
  export type Tenant$shiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    where?: ShiftWhereInput
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    cursor?: ShiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Tenant.bookings
   */
  export type Tenant$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Tenant.policies
   */
  export type Tenant$policiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    where?: PolicyWhereInput
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    cursor?: PolicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * Tenant.cutoff
   */
  export type Tenant$cutoffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cutoff
     */
    select?: CutoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cutoff
     */
    omit?: CutoffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CutoffInclude<ExtArgs> | null
    where?: CutoffWhereInput
  }

  /**
   * Tenant.vendors
   */
  export type Tenant$vendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    where?: VendorWhereInput
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    cursor?: VendorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Tenant.roles
   */
  export type Tenant$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    cursor?: RoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model WeekoffConfig
   */

  export type AggregateWeekoffConfig = {
    _count: WeekoffConfigCountAggregateOutputType | null
    _avg: WeekoffConfigAvgAggregateOutputType | null
    _sum: WeekoffConfigSumAggregateOutputType | null
    _min: WeekoffConfigMinAggregateOutputType | null
    _max: WeekoffConfigMaxAggregateOutputType | null
  }

  export type WeekoffConfigAvgAggregateOutputType = {
    weekoff_id: number | null
    employee_id: number | null
  }

  export type WeekoffConfigSumAggregateOutputType = {
    weekoff_id: number | null
    employee_id: number | null
  }

  export type WeekoffConfigMinAggregateOutputType = {
    weekoff_id: number | null
    employee_id: number | null
    monday: boolean | null
    tuesday: boolean | null
    wednesday: boolean | null
    thursday: boolean | null
    friday: boolean | null
    saturday: boolean | null
    sunday: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type WeekoffConfigMaxAggregateOutputType = {
    weekoff_id: number | null
    employee_id: number | null
    monday: boolean | null
    tuesday: boolean | null
    wednesday: boolean | null
    thursday: boolean | null
    friday: boolean | null
    saturday: boolean | null
    sunday: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type WeekoffConfigCountAggregateOutputType = {
    weekoff_id: number
    employee_id: number
    monday: number
    tuesday: number
    wednesday: number
    thursday: number
    friday: number
    saturday: number
    sunday: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type WeekoffConfigAvgAggregateInputType = {
    weekoff_id?: true
    employee_id?: true
  }

  export type WeekoffConfigSumAggregateInputType = {
    weekoff_id?: true
    employee_id?: true
  }

  export type WeekoffConfigMinAggregateInputType = {
    weekoff_id?: true
    employee_id?: true
    monday?: true
    tuesday?: true
    wednesday?: true
    thursday?: true
    friday?: true
    saturday?: true
    sunday?: true
    created_at?: true
    updated_at?: true
  }

  export type WeekoffConfigMaxAggregateInputType = {
    weekoff_id?: true
    employee_id?: true
    monday?: true
    tuesday?: true
    wednesday?: true
    thursday?: true
    friday?: true
    saturday?: true
    sunday?: true
    created_at?: true
    updated_at?: true
  }

  export type WeekoffConfigCountAggregateInputType = {
    weekoff_id?: true
    employee_id?: true
    monday?: true
    tuesday?: true
    wednesday?: true
    thursday?: true
    friday?: true
    saturday?: true
    sunday?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type WeekoffConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeekoffConfig to aggregate.
     */
    where?: WeekoffConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeekoffConfigs to fetch.
     */
    orderBy?: WeekoffConfigOrderByWithRelationInput | WeekoffConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeekoffConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeekoffConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeekoffConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WeekoffConfigs
    **/
    _count?: true | WeekoffConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeekoffConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeekoffConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeekoffConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeekoffConfigMaxAggregateInputType
  }

  export type GetWeekoffConfigAggregateType<T extends WeekoffConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateWeekoffConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeekoffConfig[P]>
      : GetScalarType<T[P], AggregateWeekoffConfig[P]>
  }




  export type WeekoffConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeekoffConfigWhereInput
    orderBy?: WeekoffConfigOrderByWithAggregationInput | WeekoffConfigOrderByWithAggregationInput[]
    by: WeekoffConfigScalarFieldEnum[] | WeekoffConfigScalarFieldEnum
    having?: WeekoffConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeekoffConfigCountAggregateInputType | true
    _avg?: WeekoffConfigAvgAggregateInputType
    _sum?: WeekoffConfigSumAggregateInputType
    _min?: WeekoffConfigMinAggregateInputType
    _max?: WeekoffConfigMaxAggregateInputType
  }

  export type WeekoffConfigGroupByOutputType = {
    weekoff_id: number
    employee_id: number
    monday: boolean
    tuesday: boolean
    wednesday: boolean
    thursday: boolean
    friday: boolean
    saturday: boolean
    sunday: boolean
    created_at: Date
    updated_at: Date
    _count: WeekoffConfigCountAggregateOutputType | null
    _avg: WeekoffConfigAvgAggregateOutputType | null
    _sum: WeekoffConfigSumAggregateOutputType | null
    _min: WeekoffConfigMinAggregateOutputType | null
    _max: WeekoffConfigMaxAggregateOutputType | null
  }

  type GetWeekoffConfigGroupByPayload<T extends WeekoffConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeekoffConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeekoffConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeekoffConfigGroupByOutputType[P]>
            : GetScalarType<T[P], WeekoffConfigGroupByOutputType[P]>
        }
      >
    >


  export type WeekoffConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    weekoff_id?: boolean
    employee_id?: boolean
    monday?: boolean
    tuesday?: boolean
    wednesday?: boolean
    thursday?: boolean
    friday?: boolean
    saturday?: boolean
    sunday?: boolean
    created_at?: boolean
    updated_at?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weekoffConfig"]>

  export type WeekoffConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    weekoff_id?: boolean
    employee_id?: boolean
    monday?: boolean
    tuesday?: boolean
    wednesday?: boolean
    thursday?: boolean
    friday?: boolean
    saturday?: boolean
    sunday?: boolean
    created_at?: boolean
    updated_at?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weekoffConfig"]>

  export type WeekoffConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    weekoff_id?: boolean
    employee_id?: boolean
    monday?: boolean
    tuesday?: boolean
    wednesday?: boolean
    thursday?: boolean
    friday?: boolean
    saturday?: boolean
    sunday?: boolean
    created_at?: boolean
    updated_at?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weekoffConfig"]>

  export type WeekoffConfigSelectScalar = {
    weekoff_id?: boolean
    employee_id?: boolean
    monday?: boolean
    tuesday?: boolean
    wednesday?: boolean
    thursday?: boolean
    friday?: boolean
    saturday?: boolean
    sunday?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type WeekoffConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"weekoff_id" | "employee_id" | "monday" | "tuesday" | "wednesday" | "thursday" | "friday" | "saturday" | "sunday" | "created_at" | "updated_at", ExtArgs["result"]["weekoffConfig"]>
  export type WeekoffConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type WeekoffConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type WeekoffConfigIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $WeekoffConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WeekoffConfig"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      weekoff_id: number
      employee_id: number
      monday: boolean
      tuesday: boolean
      wednesday: boolean
      thursday: boolean
      friday: boolean
      saturday: boolean
      sunday: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["weekoffConfig"]>
    composites: {}
  }

  type WeekoffConfigGetPayload<S extends boolean | null | undefined | WeekoffConfigDefaultArgs> = $Result.GetResult<Prisma.$WeekoffConfigPayload, S>

  type WeekoffConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WeekoffConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WeekoffConfigCountAggregateInputType | true
    }

  export interface WeekoffConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WeekoffConfig'], meta: { name: 'WeekoffConfig' } }
    /**
     * Find zero or one WeekoffConfig that matches the filter.
     * @param {WeekoffConfigFindUniqueArgs} args - Arguments to find a WeekoffConfig
     * @example
     * // Get one WeekoffConfig
     * const weekoffConfig = await prisma.weekoffConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeekoffConfigFindUniqueArgs>(args: SelectSubset<T, WeekoffConfigFindUniqueArgs<ExtArgs>>): Prisma__WeekoffConfigClient<$Result.GetResult<Prisma.$WeekoffConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WeekoffConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WeekoffConfigFindUniqueOrThrowArgs} args - Arguments to find a WeekoffConfig
     * @example
     * // Get one WeekoffConfig
     * const weekoffConfig = await prisma.weekoffConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeekoffConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, WeekoffConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeekoffConfigClient<$Result.GetResult<Prisma.$WeekoffConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WeekoffConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekoffConfigFindFirstArgs} args - Arguments to find a WeekoffConfig
     * @example
     * // Get one WeekoffConfig
     * const weekoffConfig = await prisma.weekoffConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeekoffConfigFindFirstArgs>(args?: SelectSubset<T, WeekoffConfigFindFirstArgs<ExtArgs>>): Prisma__WeekoffConfigClient<$Result.GetResult<Prisma.$WeekoffConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WeekoffConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekoffConfigFindFirstOrThrowArgs} args - Arguments to find a WeekoffConfig
     * @example
     * // Get one WeekoffConfig
     * const weekoffConfig = await prisma.weekoffConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeekoffConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, WeekoffConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeekoffConfigClient<$Result.GetResult<Prisma.$WeekoffConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WeekoffConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekoffConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WeekoffConfigs
     * const weekoffConfigs = await prisma.weekoffConfig.findMany()
     * 
     * // Get first 10 WeekoffConfigs
     * const weekoffConfigs = await prisma.weekoffConfig.findMany({ take: 10 })
     * 
     * // Only select the `weekoff_id`
     * const weekoffConfigWithWeekoff_idOnly = await prisma.weekoffConfig.findMany({ select: { weekoff_id: true } })
     * 
     */
    findMany<T extends WeekoffConfigFindManyArgs>(args?: SelectSubset<T, WeekoffConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeekoffConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WeekoffConfig.
     * @param {WeekoffConfigCreateArgs} args - Arguments to create a WeekoffConfig.
     * @example
     * // Create one WeekoffConfig
     * const WeekoffConfig = await prisma.weekoffConfig.create({
     *   data: {
     *     // ... data to create a WeekoffConfig
     *   }
     * })
     * 
     */
    create<T extends WeekoffConfigCreateArgs>(args: SelectSubset<T, WeekoffConfigCreateArgs<ExtArgs>>): Prisma__WeekoffConfigClient<$Result.GetResult<Prisma.$WeekoffConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WeekoffConfigs.
     * @param {WeekoffConfigCreateManyArgs} args - Arguments to create many WeekoffConfigs.
     * @example
     * // Create many WeekoffConfigs
     * const weekoffConfig = await prisma.weekoffConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeekoffConfigCreateManyArgs>(args?: SelectSubset<T, WeekoffConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WeekoffConfigs and returns the data saved in the database.
     * @param {WeekoffConfigCreateManyAndReturnArgs} args - Arguments to create many WeekoffConfigs.
     * @example
     * // Create many WeekoffConfigs
     * const weekoffConfig = await prisma.weekoffConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WeekoffConfigs and only return the `weekoff_id`
     * const weekoffConfigWithWeekoff_idOnly = await prisma.weekoffConfig.createManyAndReturn({
     *   select: { weekoff_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeekoffConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, WeekoffConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeekoffConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WeekoffConfig.
     * @param {WeekoffConfigDeleteArgs} args - Arguments to delete one WeekoffConfig.
     * @example
     * // Delete one WeekoffConfig
     * const WeekoffConfig = await prisma.weekoffConfig.delete({
     *   where: {
     *     // ... filter to delete one WeekoffConfig
     *   }
     * })
     * 
     */
    delete<T extends WeekoffConfigDeleteArgs>(args: SelectSubset<T, WeekoffConfigDeleteArgs<ExtArgs>>): Prisma__WeekoffConfigClient<$Result.GetResult<Prisma.$WeekoffConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WeekoffConfig.
     * @param {WeekoffConfigUpdateArgs} args - Arguments to update one WeekoffConfig.
     * @example
     * // Update one WeekoffConfig
     * const weekoffConfig = await prisma.weekoffConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeekoffConfigUpdateArgs>(args: SelectSubset<T, WeekoffConfigUpdateArgs<ExtArgs>>): Prisma__WeekoffConfigClient<$Result.GetResult<Prisma.$WeekoffConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WeekoffConfigs.
     * @param {WeekoffConfigDeleteManyArgs} args - Arguments to filter WeekoffConfigs to delete.
     * @example
     * // Delete a few WeekoffConfigs
     * const { count } = await prisma.weekoffConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeekoffConfigDeleteManyArgs>(args?: SelectSubset<T, WeekoffConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeekoffConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekoffConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WeekoffConfigs
     * const weekoffConfig = await prisma.weekoffConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeekoffConfigUpdateManyArgs>(args: SelectSubset<T, WeekoffConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeekoffConfigs and returns the data updated in the database.
     * @param {WeekoffConfigUpdateManyAndReturnArgs} args - Arguments to update many WeekoffConfigs.
     * @example
     * // Update many WeekoffConfigs
     * const weekoffConfig = await prisma.weekoffConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WeekoffConfigs and only return the `weekoff_id`
     * const weekoffConfigWithWeekoff_idOnly = await prisma.weekoffConfig.updateManyAndReturn({
     *   select: { weekoff_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WeekoffConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, WeekoffConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeekoffConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WeekoffConfig.
     * @param {WeekoffConfigUpsertArgs} args - Arguments to update or create a WeekoffConfig.
     * @example
     * // Update or create a WeekoffConfig
     * const weekoffConfig = await prisma.weekoffConfig.upsert({
     *   create: {
     *     // ... data to create a WeekoffConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WeekoffConfig we want to update
     *   }
     * })
     */
    upsert<T extends WeekoffConfigUpsertArgs>(args: SelectSubset<T, WeekoffConfigUpsertArgs<ExtArgs>>): Prisma__WeekoffConfigClient<$Result.GetResult<Prisma.$WeekoffConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WeekoffConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekoffConfigCountArgs} args - Arguments to filter WeekoffConfigs to count.
     * @example
     * // Count the number of WeekoffConfigs
     * const count = await prisma.weekoffConfig.count({
     *   where: {
     *     // ... the filter for the WeekoffConfigs we want to count
     *   }
     * })
    **/
    count<T extends WeekoffConfigCountArgs>(
      args?: Subset<T, WeekoffConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeekoffConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WeekoffConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekoffConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeekoffConfigAggregateArgs>(args: Subset<T, WeekoffConfigAggregateArgs>): Prisma.PrismaPromise<GetWeekoffConfigAggregateType<T>>

    /**
     * Group by WeekoffConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekoffConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeekoffConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeekoffConfigGroupByArgs['orderBy'] }
        : { orderBy?: WeekoffConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeekoffConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeekoffConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WeekoffConfig model
   */
  readonly fields: WeekoffConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WeekoffConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeekoffConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WeekoffConfig model
   */
  interface WeekoffConfigFieldRefs {
    readonly weekoff_id: FieldRef<"WeekoffConfig", 'Int'>
    readonly employee_id: FieldRef<"WeekoffConfig", 'Int'>
    readonly monday: FieldRef<"WeekoffConfig", 'Boolean'>
    readonly tuesday: FieldRef<"WeekoffConfig", 'Boolean'>
    readonly wednesday: FieldRef<"WeekoffConfig", 'Boolean'>
    readonly thursday: FieldRef<"WeekoffConfig", 'Boolean'>
    readonly friday: FieldRef<"WeekoffConfig", 'Boolean'>
    readonly saturday: FieldRef<"WeekoffConfig", 'Boolean'>
    readonly sunday: FieldRef<"WeekoffConfig", 'Boolean'>
    readonly created_at: FieldRef<"WeekoffConfig", 'DateTime'>
    readonly updated_at: FieldRef<"WeekoffConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WeekoffConfig findUnique
   */
  export type WeekoffConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekoffConfig
     */
    select?: WeekoffConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekoffConfig
     */
    omit?: WeekoffConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekoffConfigInclude<ExtArgs> | null
    /**
     * Filter, which WeekoffConfig to fetch.
     */
    where: WeekoffConfigWhereUniqueInput
  }

  /**
   * WeekoffConfig findUniqueOrThrow
   */
  export type WeekoffConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekoffConfig
     */
    select?: WeekoffConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekoffConfig
     */
    omit?: WeekoffConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekoffConfigInclude<ExtArgs> | null
    /**
     * Filter, which WeekoffConfig to fetch.
     */
    where: WeekoffConfigWhereUniqueInput
  }

  /**
   * WeekoffConfig findFirst
   */
  export type WeekoffConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekoffConfig
     */
    select?: WeekoffConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekoffConfig
     */
    omit?: WeekoffConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekoffConfigInclude<ExtArgs> | null
    /**
     * Filter, which WeekoffConfig to fetch.
     */
    where?: WeekoffConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeekoffConfigs to fetch.
     */
    orderBy?: WeekoffConfigOrderByWithRelationInput | WeekoffConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeekoffConfigs.
     */
    cursor?: WeekoffConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeekoffConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeekoffConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeekoffConfigs.
     */
    distinct?: WeekoffConfigScalarFieldEnum | WeekoffConfigScalarFieldEnum[]
  }

  /**
   * WeekoffConfig findFirstOrThrow
   */
  export type WeekoffConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekoffConfig
     */
    select?: WeekoffConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekoffConfig
     */
    omit?: WeekoffConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekoffConfigInclude<ExtArgs> | null
    /**
     * Filter, which WeekoffConfig to fetch.
     */
    where?: WeekoffConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeekoffConfigs to fetch.
     */
    orderBy?: WeekoffConfigOrderByWithRelationInput | WeekoffConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeekoffConfigs.
     */
    cursor?: WeekoffConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeekoffConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeekoffConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeekoffConfigs.
     */
    distinct?: WeekoffConfigScalarFieldEnum | WeekoffConfigScalarFieldEnum[]
  }

  /**
   * WeekoffConfig findMany
   */
  export type WeekoffConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekoffConfig
     */
    select?: WeekoffConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekoffConfig
     */
    omit?: WeekoffConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekoffConfigInclude<ExtArgs> | null
    /**
     * Filter, which WeekoffConfigs to fetch.
     */
    where?: WeekoffConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeekoffConfigs to fetch.
     */
    orderBy?: WeekoffConfigOrderByWithRelationInput | WeekoffConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WeekoffConfigs.
     */
    cursor?: WeekoffConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeekoffConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeekoffConfigs.
     */
    skip?: number
    distinct?: WeekoffConfigScalarFieldEnum | WeekoffConfigScalarFieldEnum[]
  }

  /**
   * WeekoffConfig create
   */
  export type WeekoffConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekoffConfig
     */
    select?: WeekoffConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekoffConfig
     */
    omit?: WeekoffConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekoffConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a WeekoffConfig.
     */
    data: XOR<WeekoffConfigCreateInput, WeekoffConfigUncheckedCreateInput>
  }

  /**
   * WeekoffConfig createMany
   */
  export type WeekoffConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WeekoffConfigs.
     */
    data: WeekoffConfigCreateManyInput | WeekoffConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WeekoffConfig createManyAndReturn
   */
  export type WeekoffConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekoffConfig
     */
    select?: WeekoffConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WeekoffConfig
     */
    omit?: WeekoffConfigOmit<ExtArgs> | null
    /**
     * The data used to create many WeekoffConfigs.
     */
    data: WeekoffConfigCreateManyInput | WeekoffConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekoffConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WeekoffConfig update
   */
  export type WeekoffConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekoffConfig
     */
    select?: WeekoffConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekoffConfig
     */
    omit?: WeekoffConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekoffConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a WeekoffConfig.
     */
    data: XOR<WeekoffConfigUpdateInput, WeekoffConfigUncheckedUpdateInput>
    /**
     * Choose, which WeekoffConfig to update.
     */
    where: WeekoffConfigWhereUniqueInput
  }

  /**
   * WeekoffConfig updateMany
   */
  export type WeekoffConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WeekoffConfigs.
     */
    data: XOR<WeekoffConfigUpdateManyMutationInput, WeekoffConfigUncheckedUpdateManyInput>
    /**
     * Filter which WeekoffConfigs to update
     */
    where?: WeekoffConfigWhereInput
    /**
     * Limit how many WeekoffConfigs to update.
     */
    limit?: number
  }

  /**
   * WeekoffConfig updateManyAndReturn
   */
  export type WeekoffConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekoffConfig
     */
    select?: WeekoffConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WeekoffConfig
     */
    omit?: WeekoffConfigOmit<ExtArgs> | null
    /**
     * The data used to update WeekoffConfigs.
     */
    data: XOR<WeekoffConfigUpdateManyMutationInput, WeekoffConfigUncheckedUpdateManyInput>
    /**
     * Filter which WeekoffConfigs to update
     */
    where?: WeekoffConfigWhereInput
    /**
     * Limit how many WeekoffConfigs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekoffConfigIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WeekoffConfig upsert
   */
  export type WeekoffConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekoffConfig
     */
    select?: WeekoffConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekoffConfig
     */
    omit?: WeekoffConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekoffConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the WeekoffConfig to update in case it exists.
     */
    where: WeekoffConfigWhereUniqueInput
    /**
     * In case the WeekoffConfig found by the `where` argument doesn't exist, create a new WeekoffConfig with this data.
     */
    create: XOR<WeekoffConfigCreateInput, WeekoffConfigUncheckedCreateInput>
    /**
     * In case the WeekoffConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeekoffConfigUpdateInput, WeekoffConfigUncheckedUpdateInput>
  }

  /**
   * WeekoffConfig delete
   */
  export type WeekoffConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekoffConfig
     */
    select?: WeekoffConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekoffConfig
     */
    omit?: WeekoffConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekoffConfigInclude<ExtArgs> | null
    /**
     * Filter which WeekoffConfig to delete.
     */
    where: WeekoffConfigWhereUniqueInput
  }

  /**
   * WeekoffConfig deleteMany
   */
  export type WeekoffConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeekoffConfigs to delete
     */
    where?: WeekoffConfigWhereInput
    /**
     * Limit how many WeekoffConfigs to delete.
     */
    limit?: number
  }

  /**
   * WeekoffConfig without action
   */
  export type WeekoffConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekoffConfig
     */
    select?: WeekoffConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeekoffConfig
     */
    omit?: WeekoffConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekoffConfigInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    admin_id: number | null
    role_id: number | null
  }

  export type AdminSumAggregateOutputType = {
    admin_id: number | null
    role_id: number | null
  }

  export type AdminMinAggregateOutputType = {
    admin_id: number | null
    name: string | null
    email: string | null
    phone: string | null
    password: string | null
    role_id: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    admin_id: number | null
    name: string | null
    email: string | null
    phone: string | null
    password: string | null
    role_id: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AdminCountAggregateOutputType = {
    admin_id: number
    name: number
    email: number
    phone: number
    password: number
    role_id: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    admin_id?: true
    role_id?: true
  }

  export type AdminSumAggregateInputType = {
    admin_id?: true
    role_id?: true
  }

  export type AdminMinAggregateInputType = {
    admin_id?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    role_id?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type AdminMaxAggregateInputType = {
    admin_id?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    role_id?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type AdminCountAggregateInputType = {
    admin_id?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    role_id?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    admin_id: number
    name: string
    email: string
    phone: string
    password: string
    role_id: number
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    admin_id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    role_id?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    admin_id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    role_id?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    admin_id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    role_id?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    admin_id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    role_id?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"admin_id" | "name" | "email" | "phone" | "password" | "role_id" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type AdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      admin_id: number
      name: string
      email: string
      phone: string
      password: string
      role_id: number
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `admin_id`
     * const adminWithAdmin_idOnly = await prisma.admin.findMany({ select: { admin_id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `admin_id`
     * const adminWithAdmin_idOnly = await prisma.admin.createManyAndReturn({
     *   select: { admin_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `admin_id`
     * const adminWithAdmin_idOnly = await prisma.admin.updateManyAndReturn({
     *   select: { admin_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly admin_id: FieldRef<"Admin", 'Int'>
    readonly name: FieldRef<"Admin", 'String'>
    readonly email: FieldRef<"Admin", 'String'>
    readonly phone: FieldRef<"Admin", 'String'>
    readonly password: FieldRef<"Admin", 'String'>
    readonly role_id: FieldRef<"Admin", 'Int'>
    readonly is_active: FieldRef<"Admin", 'Boolean'>
    readonly created_at: FieldRef<"Admin", 'DateTime'>
    readonly updated_at: FieldRef<"Admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionAvgAggregateOutputType = {
    permission_id: number | null
  }

  export type PermissionSumAggregateOutputType = {
    permission_id: number | null
  }

  export type PermissionMinAggregateOutputType = {
    permission_id: number | null
    module: string | null
    action: string | null
    description: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    permission_id: number | null
    module: string | null
    action: string | null
    description: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    permission_id: number
    module: number
    action: number
    description: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PermissionAvgAggregateInputType = {
    permission_id?: true
  }

  export type PermissionSumAggregateInputType = {
    permission_id?: true
  }

  export type PermissionMinAggregateInputType = {
    permission_id?: true
    module?: true
    action?: true
    description?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type PermissionMaxAggregateInputType = {
    permission_id?: true
    module?: true
    action?: true
    description?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type PermissionCountAggregateInputType = {
    permission_id?: true
    module?: true
    action?: true
    description?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _avg?: PermissionAvgAggregateInputType
    _sum?: PermissionSumAggregateInputType
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    permission_id: number
    module: string
    action: string
    description: string | null
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    permission_id?: boolean
    module?: boolean
    action?: boolean
    description?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    policy_permissions?: boolean | Permission$policy_permissionsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    permission_id?: boolean
    module?: boolean
    action?: boolean
    description?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    permission_id?: boolean
    module?: boolean
    action?: boolean
    description?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    permission_id?: boolean
    module?: boolean
    action?: boolean
    description?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"permission_id" | "module" | "action" | "description" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["permission"]>
  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    policy_permissions?: boolean | Permission$policy_permissionsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      policy_permissions: Prisma.$PolicyPermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      permission_id: number
      module: string
      action: string
      description: string | null
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `permission_id`
     * const permissionWithPermission_idOnly = await prisma.permission.findMany({ select: { permission_id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `permission_id`
     * const permissionWithPermission_idOnly = await prisma.permission.createManyAndReturn({
     *   select: { permission_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions and returns the data updated in the database.
     * @param {PermissionUpdateManyAndReturnArgs} args - Arguments to update many Permissions.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permissions and only return the `permission_id`
     * const permissionWithPermission_idOnly = await prisma.permission.updateManyAndReturn({
     *   select: { permission_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, PermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    policy_permissions<T extends Permission$policy_permissionsArgs<ExtArgs> = {}>(args?: Subset<T, Permission$policy_permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */
  interface PermissionFieldRefs {
    readonly permission_id: FieldRef<"Permission", 'Int'>
    readonly module: FieldRef<"Permission", 'String'>
    readonly action: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
    readonly is_active: FieldRef<"Permission", 'Boolean'>
    readonly created_at: FieldRef<"Permission", 'DateTime'>
    readonly updated_at: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission updateManyAndReturn
   */
  export type PermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permission.policy_permissions
   */
  export type Permission$policy_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyPermission
     */
    select?: PolicyPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolicyPermission
     */
    omit?: PolicyPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyPermissionInclude<ExtArgs> | null
    where?: PolicyPermissionWhereInput
    orderBy?: PolicyPermissionOrderByWithRelationInput | PolicyPermissionOrderByWithRelationInput[]
    cursor?: PolicyPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PolicyPermissionScalarFieldEnum | PolicyPermissionScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model Policy
   */

  export type AggregatePolicy = {
    _count: PolicyCountAggregateOutputType | null
    _avg: PolicyAvgAggregateOutputType | null
    _sum: PolicySumAggregateOutputType | null
    _min: PolicyMinAggregateOutputType | null
    _max: PolicyMaxAggregateOutputType | null
  }

  export type PolicyAvgAggregateOutputType = {
    policy_id: number | null
  }

  export type PolicySumAggregateOutputType = {
    policy_id: number | null
  }

  export type PolicyMinAggregateOutputType = {
    policy_id: number | null
    tenant_id: string | null
    name: string | null
    description: string | null
    is_active: boolean | null
    is_system_policy: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PolicyMaxAggregateOutputType = {
    policy_id: number | null
    tenant_id: string | null
    name: string | null
    description: string | null
    is_active: boolean | null
    is_system_policy: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PolicyCountAggregateOutputType = {
    policy_id: number
    tenant_id: number
    name: number
    description: number
    is_active: number
    is_system_policy: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PolicyAvgAggregateInputType = {
    policy_id?: true
  }

  export type PolicySumAggregateInputType = {
    policy_id?: true
  }

  export type PolicyMinAggregateInputType = {
    policy_id?: true
    tenant_id?: true
    name?: true
    description?: true
    is_active?: true
    is_system_policy?: true
    created_at?: true
    updated_at?: true
  }

  export type PolicyMaxAggregateInputType = {
    policy_id?: true
    tenant_id?: true
    name?: true
    description?: true
    is_active?: true
    is_system_policy?: true
    created_at?: true
    updated_at?: true
  }

  export type PolicyCountAggregateInputType = {
    policy_id?: true
    tenant_id?: true
    name?: true
    description?: true
    is_active?: true
    is_system_policy?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Policy to aggregate.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Policies
    **/
    _count?: true | PolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PolicyMaxAggregateInputType
  }

  export type GetPolicyAggregateType<T extends PolicyAggregateArgs> = {
        [P in keyof T & keyof AggregatePolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePolicy[P]>
      : GetScalarType<T[P], AggregatePolicy[P]>
  }




  export type PolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyWhereInput
    orderBy?: PolicyOrderByWithAggregationInput | PolicyOrderByWithAggregationInput[]
    by: PolicyScalarFieldEnum[] | PolicyScalarFieldEnum
    having?: PolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PolicyCountAggregateInputType | true
    _avg?: PolicyAvgAggregateInputType
    _sum?: PolicySumAggregateInputType
    _min?: PolicyMinAggregateInputType
    _max?: PolicyMaxAggregateInputType
  }

  export type PolicyGroupByOutputType = {
    policy_id: number
    tenant_id: string | null
    name: string
    description: string | null
    is_active: boolean
    is_system_policy: boolean
    created_at: Date
    updated_at: Date
    _count: PolicyCountAggregateOutputType | null
    _avg: PolicyAvgAggregateOutputType | null
    _sum: PolicySumAggregateOutputType | null
    _min: PolicyMinAggregateOutputType | null
    _max: PolicyMaxAggregateOutputType | null
  }

  type GetPolicyGroupByPayload<T extends PolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PolicyGroupByOutputType[P]>
            : GetScalarType<T[P], PolicyGroupByOutputType[P]>
        }
      >
    >


  export type PolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    policy_id?: boolean
    tenant_id?: boolean
    name?: boolean
    description?: boolean
    is_active?: boolean
    is_system_policy?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | Policy$tenantArgs<ExtArgs>
    policy_permissions?: boolean | Policy$policy_permissionsArgs<ExtArgs>
    role_policies?: boolean | Policy$role_policiesArgs<ExtArgs>
    _count?: boolean | PolicyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["policy"]>

  export type PolicySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    policy_id?: boolean
    tenant_id?: boolean
    name?: boolean
    description?: boolean
    is_active?: boolean
    is_system_policy?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | Policy$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["policy"]>

  export type PolicySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    policy_id?: boolean
    tenant_id?: boolean
    name?: boolean
    description?: boolean
    is_active?: boolean
    is_system_policy?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | Policy$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["policy"]>

  export type PolicySelectScalar = {
    policy_id?: boolean
    tenant_id?: boolean
    name?: boolean
    description?: boolean
    is_active?: boolean
    is_system_policy?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type PolicyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"policy_id" | "tenant_id" | "name" | "description" | "is_active" | "is_system_policy" | "created_at" | "updated_at", ExtArgs["result"]["policy"]>
  export type PolicyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | Policy$tenantArgs<ExtArgs>
    policy_permissions?: boolean | Policy$policy_permissionsArgs<ExtArgs>
    role_policies?: boolean | Policy$role_policiesArgs<ExtArgs>
    _count?: boolean | PolicyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PolicyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | Policy$tenantArgs<ExtArgs>
  }
  export type PolicyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | Policy$tenantArgs<ExtArgs>
  }

  export type $PolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Policy"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs> | null
      policy_permissions: Prisma.$PolicyPermissionPayload<ExtArgs>[]
      role_policies: Prisma.$RolePolicyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      policy_id: number
      tenant_id: string | null
      name: string
      description: string | null
      is_active: boolean
      is_system_policy: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["policy"]>
    composites: {}
  }

  type PolicyGetPayload<S extends boolean | null | undefined | PolicyDefaultArgs> = $Result.GetResult<Prisma.$PolicyPayload, S>

  type PolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PolicyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PolicyCountAggregateInputType | true
    }

  export interface PolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Policy'], meta: { name: 'Policy' } }
    /**
     * Find zero or one Policy that matches the filter.
     * @param {PolicyFindUniqueArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PolicyFindUniqueArgs>(args: SelectSubset<T, PolicyFindUniqueArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Policy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PolicyFindUniqueOrThrowArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, PolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Policy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyFindFirstArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PolicyFindFirstArgs>(args?: SelectSubset<T, PolicyFindFirstArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Policy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyFindFirstOrThrowArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, PolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Policies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Policies
     * const policies = await prisma.policy.findMany()
     * 
     * // Get first 10 Policies
     * const policies = await prisma.policy.findMany({ take: 10 })
     * 
     * // Only select the `policy_id`
     * const policyWithPolicy_idOnly = await prisma.policy.findMany({ select: { policy_id: true } })
     * 
     */
    findMany<T extends PolicyFindManyArgs>(args?: SelectSubset<T, PolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Policy.
     * @param {PolicyCreateArgs} args - Arguments to create a Policy.
     * @example
     * // Create one Policy
     * const Policy = await prisma.policy.create({
     *   data: {
     *     // ... data to create a Policy
     *   }
     * })
     * 
     */
    create<T extends PolicyCreateArgs>(args: SelectSubset<T, PolicyCreateArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Policies.
     * @param {PolicyCreateManyArgs} args - Arguments to create many Policies.
     * @example
     * // Create many Policies
     * const policy = await prisma.policy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PolicyCreateManyArgs>(args?: SelectSubset<T, PolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Policies and returns the data saved in the database.
     * @param {PolicyCreateManyAndReturnArgs} args - Arguments to create many Policies.
     * @example
     * // Create many Policies
     * const policy = await prisma.policy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Policies and only return the `policy_id`
     * const policyWithPolicy_idOnly = await prisma.policy.createManyAndReturn({
     *   select: { policy_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PolicyCreateManyAndReturnArgs>(args?: SelectSubset<T, PolicyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Policy.
     * @param {PolicyDeleteArgs} args - Arguments to delete one Policy.
     * @example
     * // Delete one Policy
     * const Policy = await prisma.policy.delete({
     *   where: {
     *     // ... filter to delete one Policy
     *   }
     * })
     * 
     */
    delete<T extends PolicyDeleteArgs>(args: SelectSubset<T, PolicyDeleteArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Policy.
     * @param {PolicyUpdateArgs} args - Arguments to update one Policy.
     * @example
     * // Update one Policy
     * const policy = await prisma.policy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PolicyUpdateArgs>(args: SelectSubset<T, PolicyUpdateArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Policies.
     * @param {PolicyDeleteManyArgs} args - Arguments to filter Policies to delete.
     * @example
     * // Delete a few Policies
     * const { count } = await prisma.policy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PolicyDeleteManyArgs>(args?: SelectSubset<T, PolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Policies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Policies
     * const policy = await prisma.policy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PolicyUpdateManyArgs>(args: SelectSubset<T, PolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Policies and returns the data updated in the database.
     * @param {PolicyUpdateManyAndReturnArgs} args - Arguments to update many Policies.
     * @example
     * // Update many Policies
     * const policy = await prisma.policy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Policies and only return the `policy_id`
     * const policyWithPolicy_idOnly = await prisma.policy.updateManyAndReturn({
     *   select: { policy_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PolicyUpdateManyAndReturnArgs>(args: SelectSubset<T, PolicyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Policy.
     * @param {PolicyUpsertArgs} args - Arguments to update or create a Policy.
     * @example
     * // Update or create a Policy
     * const policy = await prisma.policy.upsert({
     *   create: {
     *     // ... data to create a Policy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Policy we want to update
     *   }
     * })
     */
    upsert<T extends PolicyUpsertArgs>(args: SelectSubset<T, PolicyUpsertArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Policies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyCountArgs} args - Arguments to filter Policies to count.
     * @example
     * // Count the number of Policies
     * const count = await prisma.policy.count({
     *   where: {
     *     // ... the filter for the Policies we want to count
     *   }
     * })
    **/
    count<T extends PolicyCountArgs>(
      args?: Subset<T, PolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Policy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PolicyAggregateArgs>(args: Subset<T, PolicyAggregateArgs>): Prisma.PrismaPromise<GetPolicyAggregateType<T>>

    /**
     * Group by Policy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PolicyGroupByArgs['orderBy'] }
        : { orderBy?: PolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Policy model
   */
  readonly fields: PolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Policy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends Policy$tenantArgs<ExtArgs> = {}>(args?: Subset<T, Policy$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    policy_permissions<T extends Policy$policy_permissionsArgs<ExtArgs> = {}>(args?: Subset<T, Policy$policy_permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    role_policies<T extends Policy$role_policiesArgs<ExtArgs> = {}>(args?: Subset<T, Policy$role_policiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Policy model
   */
  interface PolicyFieldRefs {
    readonly policy_id: FieldRef<"Policy", 'Int'>
    readonly tenant_id: FieldRef<"Policy", 'String'>
    readonly name: FieldRef<"Policy", 'String'>
    readonly description: FieldRef<"Policy", 'String'>
    readonly is_active: FieldRef<"Policy", 'Boolean'>
    readonly is_system_policy: FieldRef<"Policy", 'Boolean'>
    readonly created_at: FieldRef<"Policy", 'DateTime'>
    readonly updated_at: FieldRef<"Policy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Policy findUnique
   */
  export type PolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy findUniqueOrThrow
   */
  export type PolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy findFirst
   */
  export type PolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Policies.
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Policies.
     */
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * Policy findFirstOrThrow
   */
  export type PolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Policies.
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Policies.
     */
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * Policy findMany
   */
  export type PolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policies to fetch.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Policies.
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * Policy create
   */
  export type PolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * The data needed to create a Policy.
     */
    data: XOR<PolicyCreateInput, PolicyUncheckedCreateInput>
  }

  /**
   * Policy createMany
   */
  export type PolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Policies.
     */
    data: PolicyCreateManyInput | PolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Policy createManyAndReturn
   */
  export type PolicyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * The data used to create many Policies.
     */
    data: PolicyCreateManyInput | PolicyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Policy update
   */
  export type PolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * The data needed to update a Policy.
     */
    data: XOR<PolicyUpdateInput, PolicyUncheckedUpdateInput>
    /**
     * Choose, which Policy to update.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy updateMany
   */
  export type PolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Policies.
     */
    data: XOR<PolicyUpdateManyMutationInput, PolicyUncheckedUpdateManyInput>
    /**
     * Filter which Policies to update
     */
    where?: PolicyWhereInput
    /**
     * Limit how many Policies to update.
     */
    limit?: number
  }

  /**
   * Policy updateManyAndReturn
   */
  export type PolicyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * The data used to update Policies.
     */
    data: XOR<PolicyUpdateManyMutationInput, PolicyUncheckedUpdateManyInput>
    /**
     * Filter which Policies to update
     */
    where?: PolicyWhereInput
    /**
     * Limit how many Policies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Policy upsert
   */
  export type PolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * The filter to search for the Policy to update in case it exists.
     */
    where: PolicyWhereUniqueInput
    /**
     * In case the Policy found by the `where` argument doesn't exist, create a new Policy with this data.
     */
    create: XOR<PolicyCreateInput, PolicyUncheckedCreateInput>
    /**
     * In case the Policy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PolicyUpdateInput, PolicyUncheckedUpdateInput>
  }

  /**
   * Policy delete
   */
  export type PolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter which Policy to delete.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy deleteMany
   */
  export type PolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Policies to delete
     */
    where?: PolicyWhereInput
    /**
     * Limit how many Policies to delete.
     */
    limit?: number
  }

  /**
   * Policy.tenant
   */
  export type Policy$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * Policy.policy_permissions
   */
  export type Policy$policy_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyPermission
     */
    select?: PolicyPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolicyPermission
     */
    omit?: PolicyPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyPermissionInclude<ExtArgs> | null
    where?: PolicyPermissionWhereInput
    orderBy?: PolicyPermissionOrderByWithRelationInput | PolicyPermissionOrderByWithRelationInput[]
    cursor?: PolicyPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PolicyPermissionScalarFieldEnum | PolicyPermissionScalarFieldEnum[]
  }

  /**
   * Policy.role_policies
   */
  export type Policy$role_policiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePolicy
     */
    select?: RolePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePolicy
     */
    omit?: RolePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePolicyInclude<ExtArgs> | null
    where?: RolePolicyWhereInput
    orderBy?: RolePolicyOrderByWithRelationInput | RolePolicyOrderByWithRelationInput[]
    cursor?: RolePolicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePolicyScalarFieldEnum | RolePolicyScalarFieldEnum[]
  }

  /**
   * Policy without action
   */
  export type PolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
  }


  /**
   * Model PolicyPermission
   */

  export type AggregatePolicyPermission = {
    _count: PolicyPermissionCountAggregateOutputType | null
    _avg: PolicyPermissionAvgAggregateOutputType | null
    _sum: PolicyPermissionSumAggregateOutputType | null
    _min: PolicyPermissionMinAggregateOutputType | null
    _max: PolicyPermissionMaxAggregateOutputType | null
  }

  export type PolicyPermissionAvgAggregateOutputType = {
    policy_id: number | null
    permission_id: number | null
  }

  export type PolicyPermissionSumAggregateOutputType = {
    policy_id: number | null
    permission_id: number | null
  }

  export type PolicyPermissionMinAggregateOutputType = {
    policy_id: number | null
    permission_id: number | null
  }

  export type PolicyPermissionMaxAggregateOutputType = {
    policy_id: number | null
    permission_id: number | null
  }

  export type PolicyPermissionCountAggregateOutputType = {
    policy_id: number
    permission_id: number
    _all: number
  }


  export type PolicyPermissionAvgAggregateInputType = {
    policy_id?: true
    permission_id?: true
  }

  export type PolicyPermissionSumAggregateInputType = {
    policy_id?: true
    permission_id?: true
  }

  export type PolicyPermissionMinAggregateInputType = {
    policy_id?: true
    permission_id?: true
  }

  export type PolicyPermissionMaxAggregateInputType = {
    policy_id?: true
    permission_id?: true
  }

  export type PolicyPermissionCountAggregateInputType = {
    policy_id?: true
    permission_id?: true
    _all?: true
  }

  export type PolicyPermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PolicyPermission to aggregate.
     */
    where?: PolicyPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolicyPermissions to fetch.
     */
    orderBy?: PolicyPermissionOrderByWithRelationInput | PolicyPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PolicyPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolicyPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolicyPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PolicyPermissions
    **/
    _count?: true | PolicyPermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PolicyPermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PolicyPermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PolicyPermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PolicyPermissionMaxAggregateInputType
  }

  export type GetPolicyPermissionAggregateType<T extends PolicyPermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePolicyPermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePolicyPermission[P]>
      : GetScalarType<T[P], AggregatePolicyPermission[P]>
  }




  export type PolicyPermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyPermissionWhereInput
    orderBy?: PolicyPermissionOrderByWithAggregationInput | PolicyPermissionOrderByWithAggregationInput[]
    by: PolicyPermissionScalarFieldEnum[] | PolicyPermissionScalarFieldEnum
    having?: PolicyPermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PolicyPermissionCountAggregateInputType | true
    _avg?: PolicyPermissionAvgAggregateInputType
    _sum?: PolicyPermissionSumAggregateInputType
    _min?: PolicyPermissionMinAggregateInputType
    _max?: PolicyPermissionMaxAggregateInputType
  }

  export type PolicyPermissionGroupByOutputType = {
    policy_id: number
    permission_id: number
    _count: PolicyPermissionCountAggregateOutputType | null
    _avg: PolicyPermissionAvgAggregateOutputType | null
    _sum: PolicyPermissionSumAggregateOutputType | null
    _min: PolicyPermissionMinAggregateOutputType | null
    _max: PolicyPermissionMaxAggregateOutputType | null
  }

  type GetPolicyPermissionGroupByPayload<T extends PolicyPermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PolicyPermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PolicyPermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PolicyPermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PolicyPermissionGroupByOutputType[P]>
        }
      >
    >


  export type PolicyPermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    policy_id?: boolean
    permission_id?: boolean
    policy?: boolean | PolicyDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["policyPermission"]>

  export type PolicyPermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    policy_id?: boolean
    permission_id?: boolean
    policy?: boolean | PolicyDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["policyPermission"]>

  export type PolicyPermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    policy_id?: boolean
    permission_id?: boolean
    policy?: boolean | PolicyDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["policyPermission"]>

  export type PolicyPermissionSelectScalar = {
    policy_id?: boolean
    permission_id?: boolean
  }

  export type PolicyPermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"policy_id" | "permission_id", ExtArgs["result"]["policyPermission"]>
  export type PolicyPermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    policy?: boolean | PolicyDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type PolicyPermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    policy?: boolean | PolicyDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type PolicyPermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    policy?: boolean | PolicyDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }

  export type $PolicyPermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PolicyPermission"
    objects: {
      policy: Prisma.$PolicyPayload<ExtArgs>
      permission: Prisma.$PermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      policy_id: number
      permission_id: number
    }, ExtArgs["result"]["policyPermission"]>
    composites: {}
  }

  type PolicyPermissionGetPayload<S extends boolean | null | undefined | PolicyPermissionDefaultArgs> = $Result.GetResult<Prisma.$PolicyPermissionPayload, S>

  type PolicyPermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PolicyPermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PolicyPermissionCountAggregateInputType | true
    }

  export interface PolicyPermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PolicyPermission'], meta: { name: 'PolicyPermission' } }
    /**
     * Find zero or one PolicyPermission that matches the filter.
     * @param {PolicyPermissionFindUniqueArgs} args - Arguments to find a PolicyPermission
     * @example
     * // Get one PolicyPermission
     * const policyPermission = await prisma.policyPermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PolicyPermissionFindUniqueArgs>(args: SelectSubset<T, PolicyPermissionFindUniqueArgs<ExtArgs>>): Prisma__PolicyPermissionClient<$Result.GetResult<Prisma.$PolicyPermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PolicyPermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PolicyPermissionFindUniqueOrThrowArgs} args - Arguments to find a PolicyPermission
     * @example
     * // Get one PolicyPermission
     * const policyPermission = await prisma.policyPermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PolicyPermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PolicyPermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PolicyPermissionClient<$Result.GetResult<Prisma.$PolicyPermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PolicyPermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyPermissionFindFirstArgs} args - Arguments to find a PolicyPermission
     * @example
     * // Get one PolicyPermission
     * const policyPermission = await prisma.policyPermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PolicyPermissionFindFirstArgs>(args?: SelectSubset<T, PolicyPermissionFindFirstArgs<ExtArgs>>): Prisma__PolicyPermissionClient<$Result.GetResult<Prisma.$PolicyPermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PolicyPermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyPermissionFindFirstOrThrowArgs} args - Arguments to find a PolicyPermission
     * @example
     * // Get one PolicyPermission
     * const policyPermission = await prisma.policyPermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PolicyPermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PolicyPermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PolicyPermissionClient<$Result.GetResult<Prisma.$PolicyPermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PolicyPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyPermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PolicyPermissions
     * const policyPermissions = await prisma.policyPermission.findMany()
     * 
     * // Get first 10 PolicyPermissions
     * const policyPermissions = await prisma.policyPermission.findMany({ take: 10 })
     * 
     * // Only select the `policy_id`
     * const policyPermissionWithPolicy_idOnly = await prisma.policyPermission.findMany({ select: { policy_id: true } })
     * 
     */
    findMany<T extends PolicyPermissionFindManyArgs>(args?: SelectSubset<T, PolicyPermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PolicyPermission.
     * @param {PolicyPermissionCreateArgs} args - Arguments to create a PolicyPermission.
     * @example
     * // Create one PolicyPermission
     * const PolicyPermission = await prisma.policyPermission.create({
     *   data: {
     *     // ... data to create a PolicyPermission
     *   }
     * })
     * 
     */
    create<T extends PolicyPermissionCreateArgs>(args: SelectSubset<T, PolicyPermissionCreateArgs<ExtArgs>>): Prisma__PolicyPermissionClient<$Result.GetResult<Prisma.$PolicyPermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PolicyPermissions.
     * @param {PolicyPermissionCreateManyArgs} args - Arguments to create many PolicyPermissions.
     * @example
     * // Create many PolicyPermissions
     * const policyPermission = await prisma.policyPermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PolicyPermissionCreateManyArgs>(args?: SelectSubset<T, PolicyPermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PolicyPermissions and returns the data saved in the database.
     * @param {PolicyPermissionCreateManyAndReturnArgs} args - Arguments to create many PolicyPermissions.
     * @example
     * // Create many PolicyPermissions
     * const policyPermission = await prisma.policyPermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PolicyPermissions and only return the `policy_id`
     * const policyPermissionWithPolicy_idOnly = await prisma.policyPermission.createManyAndReturn({
     *   select: { policy_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PolicyPermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PolicyPermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PolicyPermission.
     * @param {PolicyPermissionDeleteArgs} args - Arguments to delete one PolicyPermission.
     * @example
     * // Delete one PolicyPermission
     * const PolicyPermission = await prisma.policyPermission.delete({
     *   where: {
     *     // ... filter to delete one PolicyPermission
     *   }
     * })
     * 
     */
    delete<T extends PolicyPermissionDeleteArgs>(args: SelectSubset<T, PolicyPermissionDeleteArgs<ExtArgs>>): Prisma__PolicyPermissionClient<$Result.GetResult<Prisma.$PolicyPermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PolicyPermission.
     * @param {PolicyPermissionUpdateArgs} args - Arguments to update one PolicyPermission.
     * @example
     * // Update one PolicyPermission
     * const policyPermission = await prisma.policyPermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PolicyPermissionUpdateArgs>(args: SelectSubset<T, PolicyPermissionUpdateArgs<ExtArgs>>): Prisma__PolicyPermissionClient<$Result.GetResult<Prisma.$PolicyPermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PolicyPermissions.
     * @param {PolicyPermissionDeleteManyArgs} args - Arguments to filter PolicyPermissions to delete.
     * @example
     * // Delete a few PolicyPermissions
     * const { count } = await prisma.policyPermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PolicyPermissionDeleteManyArgs>(args?: SelectSubset<T, PolicyPermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PolicyPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyPermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PolicyPermissions
     * const policyPermission = await prisma.policyPermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PolicyPermissionUpdateManyArgs>(args: SelectSubset<T, PolicyPermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PolicyPermissions and returns the data updated in the database.
     * @param {PolicyPermissionUpdateManyAndReturnArgs} args - Arguments to update many PolicyPermissions.
     * @example
     * // Update many PolicyPermissions
     * const policyPermission = await prisma.policyPermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PolicyPermissions and only return the `policy_id`
     * const policyPermissionWithPolicy_idOnly = await prisma.policyPermission.updateManyAndReturn({
     *   select: { policy_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PolicyPermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, PolicyPermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PolicyPermission.
     * @param {PolicyPermissionUpsertArgs} args - Arguments to update or create a PolicyPermission.
     * @example
     * // Update or create a PolicyPermission
     * const policyPermission = await prisma.policyPermission.upsert({
     *   create: {
     *     // ... data to create a PolicyPermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PolicyPermission we want to update
     *   }
     * })
     */
    upsert<T extends PolicyPermissionUpsertArgs>(args: SelectSubset<T, PolicyPermissionUpsertArgs<ExtArgs>>): Prisma__PolicyPermissionClient<$Result.GetResult<Prisma.$PolicyPermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PolicyPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyPermissionCountArgs} args - Arguments to filter PolicyPermissions to count.
     * @example
     * // Count the number of PolicyPermissions
     * const count = await prisma.policyPermission.count({
     *   where: {
     *     // ... the filter for the PolicyPermissions we want to count
     *   }
     * })
    **/
    count<T extends PolicyPermissionCountArgs>(
      args?: Subset<T, PolicyPermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PolicyPermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PolicyPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyPermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PolicyPermissionAggregateArgs>(args: Subset<T, PolicyPermissionAggregateArgs>): Prisma.PrismaPromise<GetPolicyPermissionAggregateType<T>>

    /**
     * Group by PolicyPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyPermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PolicyPermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PolicyPermissionGroupByArgs['orderBy'] }
        : { orderBy?: PolicyPermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PolicyPermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPolicyPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PolicyPermission model
   */
  readonly fields: PolicyPermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PolicyPermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PolicyPermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    policy<T extends PolicyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PolicyDefaultArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PolicyPermission model
   */
  interface PolicyPermissionFieldRefs {
    readonly policy_id: FieldRef<"PolicyPermission", 'Int'>
    readonly permission_id: FieldRef<"PolicyPermission", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PolicyPermission findUnique
   */
  export type PolicyPermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyPermission
     */
    select?: PolicyPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolicyPermission
     */
    omit?: PolicyPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyPermissionInclude<ExtArgs> | null
    /**
     * Filter, which PolicyPermission to fetch.
     */
    where: PolicyPermissionWhereUniqueInput
  }

  /**
   * PolicyPermission findUniqueOrThrow
   */
  export type PolicyPermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyPermission
     */
    select?: PolicyPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolicyPermission
     */
    omit?: PolicyPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyPermissionInclude<ExtArgs> | null
    /**
     * Filter, which PolicyPermission to fetch.
     */
    where: PolicyPermissionWhereUniqueInput
  }

  /**
   * PolicyPermission findFirst
   */
  export type PolicyPermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyPermission
     */
    select?: PolicyPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolicyPermission
     */
    omit?: PolicyPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyPermissionInclude<ExtArgs> | null
    /**
     * Filter, which PolicyPermission to fetch.
     */
    where?: PolicyPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolicyPermissions to fetch.
     */
    orderBy?: PolicyPermissionOrderByWithRelationInput | PolicyPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PolicyPermissions.
     */
    cursor?: PolicyPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolicyPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolicyPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PolicyPermissions.
     */
    distinct?: PolicyPermissionScalarFieldEnum | PolicyPermissionScalarFieldEnum[]
  }

  /**
   * PolicyPermission findFirstOrThrow
   */
  export type PolicyPermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyPermission
     */
    select?: PolicyPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolicyPermission
     */
    omit?: PolicyPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyPermissionInclude<ExtArgs> | null
    /**
     * Filter, which PolicyPermission to fetch.
     */
    where?: PolicyPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolicyPermissions to fetch.
     */
    orderBy?: PolicyPermissionOrderByWithRelationInput | PolicyPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PolicyPermissions.
     */
    cursor?: PolicyPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolicyPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolicyPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PolicyPermissions.
     */
    distinct?: PolicyPermissionScalarFieldEnum | PolicyPermissionScalarFieldEnum[]
  }

  /**
   * PolicyPermission findMany
   */
  export type PolicyPermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyPermission
     */
    select?: PolicyPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolicyPermission
     */
    omit?: PolicyPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyPermissionInclude<ExtArgs> | null
    /**
     * Filter, which PolicyPermissions to fetch.
     */
    where?: PolicyPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolicyPermissions to fetch.
     */
    orderBy?: PolicyPermissionOrderByWithRelationInput | PolicyPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PolicyPermissions.
     */
    cursor?: PolicyPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolicyPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolicyPermissions.
     */
    skip?: number
    distinct?: PolicyPermissionScalarFieldEnum | PolicyPermissionScalarFieldEnum[]
  }

  /**
   * PolicyPermission create
   */
  export type PolicyPermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyPermission
     */
    select?: PolicyPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolicyPermission
     */
    omit?: PolicyPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyPermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a PolicyPermission.
     */
    data: XOR<PolicyPermissionCreateInput, PolicyPermissionUncheckedCreateInput>
  }

  /**
   * PolicyPermission createMany
   */
  export type PolicyPermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PolicyPermissions.
     */
    data: PolicyPermissionCreateManyInput | PolicyPermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PolicyPermission createManyAndReturn
   */
  export type PolicyPermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyPermission
     */
    select?: PolicyPermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PolicyPermission
     */
    omit?: PolicyPermissionOmit<ExtArgs> | null
    /**
     * The data used to create many PolicyPermissions.
     */
    data: PolicyPermissionCreateManyInput | PolicyPermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyPermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PolicyPermission update
   */
  export type PolicyPermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyPermission
     */
    select?: PolicyPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolicyPermission
     */
    omit?: PolicyPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyPermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a PolicyPermission.
     */
    data: XOR<PolicyPermissionUpdateInput, PolicyPermissionUncheckedUpdateInput>
    /**
     * Choose, which PolicyPermission to update.
     */
    where: PolicyPermissionWhereUniqueInput
  }

  /**
   * PolicyPermission updateMany
   */
  export type PolicyPermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PolicyPermissions.
     */
    data: XOR<PolicyPermissionUpdateManyMutationInput, PolicyPermissionUncheckedUpdateManyInput>
    /**
     * Filter which PolicyPermissions to update
     */
    where?: PolicyPermissionWhereInput
    /**
     * Limit how many PolicyPermissions to update.
     */
    limit?: number
  }

  /**
   * PolicyPermission updateManyAndReturn
   */
  export type PolicyPermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyPermission
     */
    select?: PolicyPermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PolicyPermission
     */
    omit?: PolicyPermissionOmit<ExtArgs> | null
    /**
     * The data used to update PolicyPermissions.
     */
    data: XOR<PolicyPermissionUpdateManyMutationInput, PolicyPermissionUncheckedUpdateManyInput>
    /**
     * Filter which PolicyPermissions to update
     */
    where?: PolicyPermissionWhereInput
    /**
     * Limit how many PolicyPermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyPermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PolicyPermission upsert
   */
  export type PolicyPermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyPermission
     */
    select?: PolicyPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolicyPermission
     */
    omit?: PolicyPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyPermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the PolicyPermission to update in case it exists.
     */
    where: PolicyPermissionWhereUniqueInput
    /**
     * In case the PolicyPermission found by the `where` argument doesn't exist, create a new PolicyPermission with this data.
     */
    create: XOR<PolicyPermissionCreateInput, PolicyPermissionUncheckedCreateInput>
    /**
     * In case the PolicyPermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PolicyPermissionUpdateInput, PolicyPermissionUncheckedUpdateInput>
  }

  /**
   * PolicyPermission delete
   */
  export type PolicyPermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyPermission
     */
    select?: PolicyPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolicyPermission
     */
    omit?: PolicyPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyPermissionInclude<ExtArgs> | null
    /**
     * Filter which PolicyPermission to delete.
     */
    where: PolicyPermissionWhereUniqueInput
  }

  /**
   * PolicyPermission deleteMany
   */
  export type PolicyPermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PolicyPermissions to delete
     */
    where?: PolicyPermissionWhereInput
    /**
     * Limit how many PolicyPermissions to delete.
     */
    limit?: number
  }

  /**
   * PolicyPermission without action
   */
  export type PolicyPermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyPermission
     */
    select?: PolicyPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolicyPermission
     */
    omit?: PolicyPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyPermissionInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    role_id: number | null
  }

  export type RoleSumAggregateOutputType = {
    role_id: number | null
  }

  export type RoleMinAggregateOutputType = {
    role_id: number | null
    name: string | null
    description: string | null
    is_active: boolean | null
    tenant_id: string | null
    is_system_role: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    role_id: number | null
    name: string | null
    description: string | null
    is_active: boolean | null
    tenant_id: string | null
    is_system_role: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RoleCountAggregateOutputType = {
    role_id: number
    name: number
    description: number
    is_active: number
    tenant_id: number
    is_system_role: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    role_id?: true
  }

  export type RoleSumAggregateInputType = {
    role_id?: true
  }

  export type RoleMinAggregateInputType = {
    role_id?: true
    name?: true
    description?: true
    is_active?: true
    tenant_id?: true
    is_system_role?: true
    created_at?: true
    updated_at?: true
  }

  export type RoleMaxAggregateInputType = {
    role_id?: true
    name?: true
    description?: true
    is_active?: true
    tenant_id?: true
    is_system_role?: true
    created_at?: true
    updated_at?: true
  }

  export type RoleCountAggregateInputType = {
    role_id?: true
    name?: true
    description?: true
    is_active?: true
    tenant_id?: true
    is_system_role?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    role_id: number
    name: string
    description: string | null
    is_active: boolean
    tenant_id: string | null
    is_system_role: boolean
    created_at: Date
    updated_at: Date
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    name?: boolean
    description?: boolean
    is_active?: boolean
    tenant_id?: boolean
    is_system_role?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | Role$tenantArgs<ExtArgs>
    role_policies?: boolean | Role$role_policiesArgs<ExtArgs>
    admins?: boolean | Role$adminsArgs<ExtArgs>
    vendor_users?: boolean | Role$vendor_usersArgs<ExtArgs>
    employees?: boolean | Role$employeesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    name?: boolean
    description?: boolean
    is_active?: boolean
    tenant_id?: boolean
    is_system_role?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | Role$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    name?: boolean
    description?: boolean
    is_active?: boolean
    tenant_id?: boolean
    is_system_role?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | Role$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    role_id?: boolean
    name?: boolean
    description?: boolean
    is_active?: boolean
    tenant_id?: boolean
    is_system_role?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"role_id" | "name" | "description" | "is_active" | "tenant_id" | "is_system_role" | "created_at" | "updated_at", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | Role$tenantArgs<ExtArgs>
    role_policies?: boolean | Role$role_policiesArgs<ExtArgs>
    admins?: boolean | Role$adminsArgs<ExtArgs>
    vendor_users?: boolean | Role$vendor_usersArgs<ExtArgs>
    employees?: boolean | Role$employeesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | Role$tenantArgs<ExtArgs>
  }
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | Role$tenantArgs<ExtArgs>
  }

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs> | null
      role_policies: Prisma.$RolePolicyPayload<ExtArgs>[]
      admins: Prisma.$AdminPayload<ExtArgs>[]
      vendor_users: Prisma.$VendorUserPayload<ExtArgs>[]
      employees: Prisma.$EmployeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      role_id: number
      name: string
      description: string | null
      is_active: boolean
      tenant_id: string | null
      is_system_role: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `role_id`
     * const roleWithRole_idOnly = await prisma.role.findMany({ select: { role_id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `role_id`
     * const roleWithRole_idOnly = await prisma.role.createManyAndReturn({
     *   select: { role_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `role_id`
     * const roleWithRole_idOnly = await prisma.role.updateManyAndReturn({
     *   select: { role_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends Role$tenantArgs<ExtArgs> = {}>(args?: Subset<T, Role$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    role_policies<T extends Role$role_policiesArgs<ExtArgs> = {}>(args?: Subset<T, Role$role_policiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    admins<T extends Role$adminsArgs<ExtArgs> = {}>(args?: Subset<T, Role$adminsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vendor_users<T extends Role$vendor_usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$vendor_usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employees<T extends Role$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Role$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly role_id: FieldRef<"Role", 'Int'>
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly is_active: FieldRef<"Role", 'Boolean'>
    readonly tenant_id: FieldRef<"Role", 'String'>
    readonly is_system_role: FieldRef<"Role", 'Boolean'>
    readonly created_at: FieldRef<"Role", 'DateTime'>
    readonly updated_at: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.tenant
   */
  export type Role$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * Role.role_policies
   */
  export type Role$role_policiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePolicy
     */
    select?: RolePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePolicy
     */
    omit?: RolePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePolicyInclude<ExtArgs> | null
    where?: RolePolicyWhereInput
    orderBy?: RolePolicyOrderByWithRelationInput | RolePolicyOrderByWithRelationInput[]
    cursor?: RolePolicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePolicyScalarFieldEnum | RolePolicyScalarFieldEnum[]
  }

  /**
   * Role.admins
   */
  export type Role$adminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    cursor?: AdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Role.vendor_users
   */
  export type Role$vendor_usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorUser
     */
    select?: VendorUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorUser
     */
    omit?: VendorUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorUserInclude<ExtArgs> | null
    where?: VendorUserWhereInput
    orderBy?: VendorUserOrderByWithRelationInput | VendorUserOrderByWithRelationInput[]
    cursor?: VendorUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorUserScalarFieldEnum | VendorUserScalarFieldEnum[]
  }

  /**
   * Role.employees
   */
  export type Role$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model RolePolicy
   */

  export type AggregateRolePolicy = {
    _count: RolePolicyCountAggregateOutputType | null
    _avg: RolePolicyAvgAggregateOutputType | null
    _sum: RolePolicySumAggregateOutputType | null
    _min: RolePolicyMinAggregateOutputType | null
    _max: RolePolicyMaxAggregateOutputType | null
  }

  export type RolePolicyAvgAggregateOutputType = {
    role_id: number | null
    policy_id: number | null
  }

  export type RolePolicySumAggregateOutputType = {
    role_id: number | null
    policy_id: number | null
  }

  export type RolePolicyMinAggregateOutputType = {
    role_id: number | null
    policy_id: number | null
  }

  export type RolePolicyMaxAggregateOutputType = {
    role_id: number | null
    policy_id: number | null
  }

  export type RolePolicyCountAggregateOutputType = {
    role_id: number
    policy_id: number
    _all: number
  }


  export type RolePolicyAvgAggregateInputType = {
    role_id?: true
    policy_id?: true
  }

  export type RolePolicySumAggregateInputType = {
    role_id?: true
    policy_id?: true
  }

  export type RolePolicyMinAggregateInputType = {
    role_id?: true
    policy_id?: true
  }

  export type RolePolicyMaxAggregateInputType = {
    role_id?: true
    policy_id?: true
  }

  export type RolePolicyCountAggregateInputType = {
    role_id?: true
    policy_id?: true
    _all?: true
  }

  export type RolePolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePolicy to aggregate.
     */
    where?: RolePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePolicies to fetch.
     */
    orderBy?: RolePolicyOrderByWithRelationInput | RolePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePolicies
    **/
    _count?: true | RolePolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolePolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolePolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePolicyMaxAggregateInputType
  }

  export type GetRolePolicyAggregateType<T extends RolePolicyAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePolicy[P]>
      : GetScalarType<T[P], AggregateRolePolicy[P]>
  }




  export type RolePolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePolicyWhereInput
    orderBy?: RolePolicyOrderByWithAggregationInput | RolePolicyOrderByWithAggregationInput[]
    by: RolePolicyScalarFieldEnum[] | RolePolicyScalarFieldEnum
    having?: RolePolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePolicyCountAggregateInputType | true
    _avg?: RolePolicyAvgAggregateInputType
    _sum?: RolePolicySumAggregateInputType
    _min?: RolePolicyMinAggregateInputType
    _max?: RolePolicyMaxAggregateInputType
  }

  export type RolePolicyGroupByOutputType = {
    role_id: number
    policy_id: number
    _count: RolePolicyCountAggregateOutputType | null
    _avg: RolePolicyAvgAggregateOutputType | null
    _sum: RolePolicySumAggregateOutputType | null
    _min: RolePolicyMinAggregateOutputType | null
    _max: RolePolicyMaxAggregateOutputType | null
  }

  type GetRolePolicyGroupByPayload<T extends RolePolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePolicyGroupByOutputType[P]>
            : GetScalarType<T[P], RolePolicyGroupByOutputType[P]>
        }
      >
    >


  export type RolePolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    policy_id?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    policy?: boolean | PolicyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePolicy"]>

  export type RolePolicySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    policy_id?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    policy?: boolean | PolicyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePolicy"]>

  export type RolePolicySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    policy_id?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    policy?: boolean | PolicyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePolicy"]>

  export type RolePolicySelectScalar = {
    role_id?: boolean
    policy_id?: boolean
  }

  export type RolePolicyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"role_id" | "policy_id", ExtArgs["result"]["rolePolicy"]>
  export type RolePolicyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    policy?: boolean | PolicyDefaultArgs<ExtArgs>
  }
  export type RolePolicyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    policy?: boolean | PolicyDefaultArgs<ExtArgs>
  }
  export type RolePolicyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    policy?: boolean | PolicyDefaultArgs<ExtArgs>
  }

  export type $RolePolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePolicy"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      policy: Prisma.$PolicyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      role_id: number
      policy_id: number
    }, ExtArgs["result"]["rolePolicy"]>
    composites: {}
  }

  type RolePolicyGetPayload<S extends boolean | null | undefined | RolePolicyDefaultArgs> = $Result.GetResult<Prisma.$RolePolicyPayload, S>

  type RolePolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolePolicyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolePolicyCountAggregateInputType | true
    }

  export interface RolePolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePolicy'], meta: { name: 'RolePolicy' } }
    /**
     * Find zero or one RolePolicy that matches the filter.
     * @param {RolePolicyFindUniqueArgs} args - Arguments to find a RolePolicy
     * @example
     * // Get one RolePolicy
     * const rolePolicy = await prisma.rolePolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePolicyFindUniqueArgs>(args: SelectSubset<T, RolePolicyFindUniqueArgs<ExtArgs>>): Prisma__RolePolicyClient<$Result.GetResult<Prisma.$RolePolicyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RolePolicy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolePolicyFindUniqueOrThrowArgs} args - Arguments to find a RolePolicy
     * @example
     * // Get one RolePolicy
     * const rolePolicy = await prisma.rolePolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePolicyClient<$Result.GetResult<Prisma.$RolePolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePolicyFindFirstArgs} args - Arguments to find a RolePolicy
     * @example
     * // Get one RolePolicy
     * const rolePolicy = await prisma.rolePolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePolicyFindFirstArgs>(args?: SelectSubset<T, RolePolicyFindFirstArgs<ExtArgs>>): Prisma__RolePolicyClient<$Result.GetResult<Prisma.$RolePolicyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePolicyFindFirstOrThrowArgs} args - Arguments to find a RolePolicy
     * @example
     * // Get one RolePolicy
     * const rolePolicy = await prisma.rolePolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePolicyClient<$Result.GetResult<Prisma.$RolePolicyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RolePolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePolicies
     * const rolePolicies = await prisma.rolePolicy.findMany()
     * 
     * // Get first 10 RolePolicies
     * const rolePolicies = await prisma.rolePolicy.findMany({ take: 10 })
     * 
     * // Only select the `role_id`
     * const rolePolicyWithRole_idOnly = await prisma.rolePolicy.findMany({ select: { role_id: true } })
     * 
     */
    findMany<T extends RolePolicyFindManyArgs>(args?: SelectSubset<T, RolePolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RolePolicy.
     * @param {RolePolicyCreateArgs} args - Arguments to create a RolePolicy.
     * @example
     * // Create one RolePolicy
     * const RolePolicy = await prisma.rolePolicy.create({
     *   data: {
     *     // ... data to create a RolePolicy
     *   }
     * })
     * 
     */
    create<T extends RolePolicyCreateArgs>(args: SelectSubset<T, RolePolicyCreateArgs<ExtArgs>>): Prisma__RolePolicyClient<$Result.GetResult<Prisma.$RolePolicyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RolePolicies.
     * @param {RolePolicyCreateManyArgs} args - Arguments to create many RolePolicies.
     * @example
     * // Create many RolePolicies
     * const rolePolicy = await prisma.rolePolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePolicyCreateManyArgs>(args?: SelectSubset<T, RolePolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolePolicies and returns the data saved in the database.
     * @param {RolePolicyCreateManyAndReturnArgs} args - Arguments to create many RolePolicies.
     * @example
     * // Create many RolePolicies
     * const rolePolicy = await prisma.rolePolicy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolePolicies and only return the `role_id`
     * const rolePolicyWithRole_idOnly = await prisma.rolePolicy.createManyAndReturn({
     *   select: { role_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolePolicyCreateManyAndReturnArgs>(args?: SelectSubset<T, RolePolicyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePolicyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RolePolicy.
     * @param {RolePolicyDeleteArgs} args - Arguments to delete one RolePolicy.
     * @example
     * // Delete one RolePolicy
     * const RolePolicy = await prisma.rolePolicy.delete({
     *   where: {
     *     // ... filter to delete one RolePolicy
     *   }
     * })
     * 
     */
    delete<T extends RolePolicyDeleteArgs>(args: SelectSubset<T, RolePolicyDeleteArgs<ExtArgs>>): Prisma__RolePolicyClient<$Result.GetResult<Prisma.$RolePolicyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RolePolicy.
     * @param {RolePolicyUpdateArgs} args - Arguments to update one RolePolicy.
     * @example
     * // Update one RolePolicy
     * const rolePolicy = await prisma.rolePolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePolicyUpdateArgs>(args: SelectSubset<T, RolePolicyUpdateArgs<ExtArgs>>): Prisma__RolePolicyClient<$Result.GetResult<Prisma.$RolePolicyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RolePolicies.
     * @param {RolePolicyDeleteManyArgs} args - Arguments to filter RolePolicies to delete.
     * @example
     * // Delete a few RolePolicies
     * const { count } = await prisma.rolePolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePolicyDeleteManyArgs>(args?: SelectSubset<T, RolePolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePolicies
     * const rolePolicy = await prisma.rolePolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePolicyUpdateManyArgs>(args: SelectSubset<T, RolePolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePolicies and returns the data updated in the database.
     * @param {RolePolicyUpdateManyAndReturnArgs} args - Arguments to update many RolePolicies.
     * @example
     * // Update many RolePolicies
     * const rolePolicy = await prisma.rolePolicy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RolePolicies and only return the `role_id`
     * const rolePolicyWithRole_idOnly = await prisma.rolePolicy.updateManyAndReturn({
     *   select: { role_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RolePolicyUpdateManyAndReturnArgs>(args: SelectSubset<T, RolePolicyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePolicyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RolePolicy.
     * @param {RolePolicyUpsertArgs} args - Arguments to update or create a RolePolicy.
     * @example
     * // Update or create a RolePolicy
     * const rolePolicy = await prisma.rolePolicy.upsert({
     *   create: {
     *     // ... data to create a RolePolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePolicy we want to update
     *   }
     * })
     */
    upsert<T extends RolePolicyUpsertArgs>(args: SelectSubset<T, RolePolicyUpsertArgs<ExtArgs>>): Prisma__RolePolicyClient<$Result.GetResult<Prisma.$RolePolicyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RolePolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePolicyCountArgs} args - Arguments to filter RolePolicies to count.
     * @example
     * // Count the number of RolePolicies
     * const count = await prisma.rolePolicy.count({
     *   where: {
     *     // ... the filter for the RolePolicies we want to count
     *   }
     * })
    **/
    count<T extends RolePolicyCountArgs>(
      args?: Subset<T, RolePolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePolicyAggregateArgs>(args: Subset<T, RolePolicyAggregateArgs>): Prisma.PrismaPromise<GetRolePolicyAggregateType<T>>

    /**
     * Group by RolePolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePolicyGroupByArgs['orderBy'] }
        : { orderBy?: RolePolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePolicy model
   */
  readonly fields: RolePolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    policy<T extends PolicyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PolicyDefaultArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePolicy model
   */
  interface RolePolicyFieldRefs {
    readonly role_id: FieldRef<"RolePolicy", 'Int'>
    readonly policy_id: FieldRef<"RolePolicy", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RolePolicy findUnique
   */
  export type RolePolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePolicy
     */
    select?: RolePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePolicy
     */
    omit?: RolePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePolicyInclude<ExtArgs> | null
    /**
     * Filter, which RolePolicy to fetch.
     */
    where: RolePolicyWhereUniqueInput
  }

  /**
   * RolePolicy findUniqueOrThrow
   */
  export type RolePolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePolicy
     */
    select?: RolePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePolicy
     */
    omit?: RolePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePolicyInclude<ExtArgs> | null
    /**
     * Filter, which RolePolicy to fetch.
     */
    where: RolePolicyWhereUniqueInput
  }

  /**
   * RolePolicy findFirst
   */
  export type RolePolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePolicy
     */
    select?: RolePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePolicy
     */
    omit?: RolePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePolicyInclude<ExtArgs> | null
    /**
     * Filter, which RolePolicy to fetch.
     */
    where?: RolePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePolicies to fetch.
     */
    orderBy?: RolePolicyOrderByWithRelationInput | RolePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePolicies.
     */
    cursor?: RolePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePolicies.
     */
    distinct?: RolePolicyScalarFieldEnum | RolePolicyScalarFieldEnum[]
  }

  /**
   * RolePolicy findFirstOrThrow
   */
  export type RolePolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePolicy
     */
    select?: RolePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePolicy
     */
    omit?: RolePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePolicyInclude<ExtArgs> | null
    /**
     * Filter, which RolePolicy to fetch.
     */
    where?: RolePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePolicies to fetch.
     */
    orderBy?: RolePolicyOrderByWithRelationInput | RolePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePolicies.
     */
    cursor?: RolePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePolicies.
     */
    distinct?: RolePolicyScalarFieldEnum | RolePolicyScalarFieldEnum[]
  }

  /**
   * RolePolicy findMany
   */
  export type RolePolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePolicy
     */
    select?: RolePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePolicy
     */
    omit?: RolePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePolicyInclude<ExtArgs> | null
    /**
     * Filter, which RolePolicies to fetch.
     */
    where?: RolePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePolicies to fetch.
     */
    orderBy?: RolePolicyOrderByWithRelationInput | RolePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePolicies.
     */
    cursor?: RolePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePolicies.
     */
    skip?: number
    distinct?: RolePolicyScalarFieldEnum | RolePolicyScalarFieldEnum[]
  }

  /**
   * RolePolicy create
   */
  export type RolePolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePolicy
     */
    select?: RolePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePolicy
     */
    omit?: RolePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePolicyInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePolicy.
     */
    data: XOR<RolePolicyCreateInput, RolePolicyUncheckedCreateInput>
  }

  /**
   * RolePolicy createMany
   */
  export type RolePolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePolicies.
     */
    data: RolePolicyCreateManyInput | RolePolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePolicy createManyAndReturn
   */
  export type RolePolicyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePolicy
     */
    select?: RolePolicySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolePolicy
     */
    omit?: RolePolicyOmit<ExtArgs> | null
    /**
     * The data used to create many RolePolicies.
     */
    data: RolePolicyCreateManyInput | RolePolicyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePolicyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePolicy update
   */
  export type RolePolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePolicy
     */
    select?: RolePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePolicy
     */
    omit?: RolePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePolicyInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePolicy.
     */
    data: XOR<RolePolicyUpdateInput, RolePolicyUncheckedUpdateInput>
    /**
     * Choose, which RolePolicy to update.
     */
    where: RolePolicyWhereUniqueInput
  }

  /**
   * RolePolicy updateMany
   */
  export type RolePolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePolicies.
     */
    data: XOR<RolePolicyUpdateManyMutationInput, RolePolicyUncheckedUpdateManyInput>
    /**
     * Filter which RolePolicies to update
     */
    where?: RolePolicyWhereInput
    /**
     * Limit how many RolePolicies to update.
     */
    limit?: number
  }

  /**
   * RolePolicy updateManyAndReturn
   */
  export type RolePolicyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePolicy
     */
    select?: RolePolicySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolePolicy
     */
    omit?: RolePolicyOmit<ExtArgs> | null
    /**
     * The data used to update RolePolicies.
     */
    data: XOR<RolePolicyUpdateManyMutationInput, RolePolicyUncheckedUpdateManyInput>
    /**
     * Filter which RolePolicies to update
     */
    where?: RolePolicyWhereInput
    /**
     * Limit how many RolePolicies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePolicyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePolicy upsert
   */
  export type RolePolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePolicy
     */
    select?: RolePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePolicy
     */
    omit?: RolePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePolicyInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePolicy to update in case it exists.
     */
    where: RolePolicyWhereUniqueInput
    /**
     * In case the RolePolicy found by the `where` argument doesn't exist, create a new RolePolicy with this data.
     */
    create: XOR<RolePolicyCreateInput, RolePolicyUncheckedCreateInput>
    /**
     * In case the RolePolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePolicyUpdateInput, RolePolicyUncheckedUpdateInput>
  }

  /**
   * RolePolicy delete
   */
  export type RolePolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePolicy
     */
    select?: RolePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePolicy
     */
    omit?: RolePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePolicyInclude<ExtArgs> | null
    /**
     * Filter which RolePolicy to delete.
     */
    where: RolePolicyWhereUniqueInput
  }

  /**
   * RolePolicy deleteMany
   */
  export type RolePolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePolicies to delete
     */
    where?: RolePolicyWhereInput
    /**
     * Limit how many RolePolicies to delete.
     */
    limit?: number
  }

  /**
   * RolePolicy without action
   */
  export type RolePolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePolicy
     */
    select?: RolePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePolicy
     */
    omit?: RolePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePolicyInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BookingScalarFieldEnum: {
    booking_id: 'booking_id',
    tenant_id: 'tenant_id',
    employee_id: 'employee_id',
    employee_code: 'employee_code',
    shift_id: 'shift_id',
    team_id: 'team_id',
    booking_date: 'booking_date',
    pickup_latitude: 'pickup_latitude',
    pickup_longitude: 'pickup_longitude',
    pickup_location: 'pickup_location',
    drop_latitude: 'drop_latitude',
    drop_longitude: 'drop_longitude',
    drop_location: 'drop_location',
    status: 'status',
    reason: 'reason',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const RouteScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type RouteScalarFieldEnum = (typeof RouteScalarFieldEnum)[keyof typeof RouteScalarFieldEnum]


  export const RouteManagementBookingScalarFieldEnum: {
    id: 'id',
    route_id: 'route_id',
    booking_id: 'booking_id',
    stop_order: 'stop_order',
    estimated_pickup_time: 'estimated_pickup_time',
    estimated_drop_time: 'estimated_drop_time',
    distance_from_previous: 'distance_from_previous',
    cumulative_distance: 'cumulative_distance',
    created_at: 'created_at'
  };

  export type RouteManagementBookingScalarFieldEnum = (typeof RouteManagementBookingScalarFieldEnum)[keyof typeof RouteManagementBookingScalarFieldEnum]


  export const RouteManagementScalarFieldEnum: {
    route_id: 'route_id',
    tenant_id: 'tenant_id',
    shift_id: 'shift_id',
    route_code: 'route_code',
    status: 'status',
    planned_distance_km: 'planned_distance_km',
    planned_duration_minutes: 'planned_duration_minutes',
    actual_distance_km: 'actual_distance_km',
    actual_duration_minutes: 'actual_duration_minutes',
    actual_start_time: 'actual_start_time',
    actual_end_time: 'actual_end_time',
    optimized_polyline: 'optimized_polyline',
    assigned_vendor_id: 'assigned_vendor_id',
    assigned_vehicle_id: 'assigned_vehicle_id',
    assigned_driver_id: 'assigned_driver_id',
    total_distance_km: 'total_distance_km',
    total_time_minutes: 'total_time_minutes',
    is_active: 'is_active',
    version: 'version',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type RouteManagementScalarFieldEnum = (typeof RouteManagementScalarFieldEnum)[keyof typeof RouteManagementScalarFieldEnum]


  export const DriverScalarFieldEnum: {
    driver_id: 'driver_id',
    vendor_id: 'vendor_id',
    name: 'name',
    code: 'code',
    email: 'email',
    phone: 'phone',
    gender: 'gender',
    password: 'password',
    date_of_birth: 'date_of_birth',
    date_of_joining: 'date_of_joining',
    permanent_address: 'permanent_address',
    current_address: 'current_address',
    photo_url: 'photo_url',
    bg_verify_status: 'bg_verify_status',
    bg_expiry_date: 'bg_expiry_date',
    bg_verify_url: 'bg_verify_url',
    police_verify_status: 'police_verify_status',
    police_expiry_date: 'police_expiry_date',
    police_verify_url: 'police_verify_url',
    medical_verify_status: 'medical_verify_status',
    medical_expiry_date: 'medical_expiry_date',
    medical_verify_url: 'medical_verify_url',
    training_verify_status: 'training_verify_status',
    training_expiry_date: 'training_expiry_date',
    training_verify_url: 'training_verify_url',
    eye_verify_status: 'eye_verify_status',
    eye_expiry_date: 'eye_expiry_date',
    eye_verify_url: 'eye_verify_url',
    license_number: 'license_number',
    license_expiry_date: 'license_expiry_date',
    license_url: 'license_url',
    badge_number: 'badge_number',
    badge_expiry_date: 'badge_expiry_date',
    badge_url: 'badge_url',
    alt_govt_id_number: 'alt_govt_id_number',
    alt_govt_id_type: 'alt_govt_id_type',
    alt_govt_id_url: 'alt_govt_id_url',
    induction_date: 'induction_date',
    induction_url: 'induction_url',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type DriverScalarFieldEnum = (typeof DriverScalarFieldEnum)[keyof typeof DriverScalarFieldEnum]


  export const VehicleScalarFieldEnum: {
    vehicle_id: 'vehicle_id',
    vehicle_type_id: 'vehicle_type_id',
    vendor_id: 'vendor_id',
    driver_id: 'driver_id',
    rc_number: 'rc_number',
    rc_expiry_date: 'rc_expiry_date',
    description: 'description',
    puc_number: 'puc_number',
    puc_expiry_date: 'puc_expiry_date',
    puc_url: 'puc_url',
    fitness_number: 'fitness_number',
    fitness_expiry_date: 'fitness_expiry_date',
    fitness_url: 'fitness_url',
    tax_receipt_number: 'tax_receipt_number',
    tax_receipt_date: 'tax_receipt_date',
    tax_receipt_url: 'tax_receipt_url',
    insurance_number: 'insurance_number',
    insurance_expiry_date: 'insurance_expiry_date',
    insurance_url: 'insurance_url',
    permit_number: 'permit_number',
    permit_expiry_date: 'permit_expiry_date',
    permit_url: 'permit_url',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type VehicleScalarFieldEnum = (typeof VehicleScalarFieldEnum)[keyof typeof VehicleScalarFieldEnum]


  export const VehicleTypeScalarFieldEnum: {
    vehicle_type_id: 'vehicle_type_id',
    vendor_id: 'vendor_id',
    name: 'name',
    description: 'description',
    seats: 'seats',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type VehicleTypeScalarFieldEnum = (typeof VehicleTypeScalarFieldEnum)[keyof typeof VehicleTypeScalarFieldEnum]


  export const VendorScalarFieldEnum: {
    vendor_id: 'vendor_id',
    tenant_id: 'tenant_id',
    name: 'name',
    vendor_code: 'vendor_code',
    email: 'email',
    phone: 'phone',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type VendorScalarFieldEnum = (typeof VendorScalarFieldEnum)[keyof typeof VendorScalarFieldEnum]


  export const VendorUserScalarFieldEnum: {
    vendor_user_id: 'vendor_user_id',
    tenant_id: 'tenant_id',
    vendor_id: 'vendor_id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    password: 'password',
    role_id: 'role_id',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type VendorUserScalarFieldEnum = (typeof VendorUserScalarFieldEnum)[keyof typeof VendorUserScalarFieldEnum]


  export const CutoffScalarFieldEnum: {
    tenant_id: 'tenant_id',
    booking_cutoff: 'booking_cutoff',
    cancel_cutoff: 'cancel_cutoff',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CutoffScalarFieldEnum = (typeof CutoffScalarFieldEnum)[keyof typeof CutoffScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    employee_id: 'employee_id',
    tenant_id: 'tenant_id',
    role_id: 'role_id',
    name: 'name',
    employee_code: 'employee_code',
    email: 'email',
    password: 'password',
    team_id: 'team_id',
    phone: 'phone',
    alternate_phone: 'alternate_phone',
    special_needs: 'special_needs',
    special_needs_start_date: 'special_needs_start_date',
    special_needs_end_date: 'special_needs_end_date',
    address: 'address',
    latitude: 'latitude',
    longitude: 'longitude',
    gender: 'gender',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const ShiftScalarFieldEnum: {
    shift_id: 'shift_id',
    tenant_id: 'tenant_id',
    shift_code: 'shift_code',
    log_type: 'log_type',
    shift_time: 'shift_time',
    pickup_type: 'pickup_type',
    gender: 'gender',
    waiting_time_minutes: 'waiting_time_minutes',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ShiftScalarFieldEnum = (typeof ShiftScalarFieldEnum)[keyof typeof ShiftScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    team_id: 'team_id',
    tenant_id: 'tenant_id',
    name: 'name',
    description: 'description',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const TenantScalarFieldEnum: {
    tenant_id: 'tenant_id',
    name: 'name',
    address: 'address',
    longitude: 'longitude',
    latitude: 'latitude',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const WeekoffConfigScalarFieldEnum: {
    weekoff_id: 'weekoff_id',
    employee_id: 'employee_id',
    monday: 'monday',
    tuesday: 'tuesday',
    wednesday: 'wednesday',
    thursday: 'thursday',
    friday: 'friday',
    saturday: 'saturday',
    sunday: 'sunday',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type WeekoffConfigScalarFieldEnum = (typeof WeekoffConfigScalarFieldEnum)[keyof typeof WeekoffConfigScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    admin_id: 'admin_id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    password: 'password',
    role_id: 'role_id',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    permission_id: 'permission_id',
    module: 'module',
    action: 'action',
    description: 'description',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const PolicyScalarFieldEnum: {
    policy_id: 'policy_id',
    tenant_id: 'tenant_id',
    name: 'name',
    description: 'description',
    is_active: 'is_active',
    is_system_policy: 'is_system_policy',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PolicyScalarFieldEnum = (typeof PolicyScalarFieldEnum)[keyof typeof PolicyScalarFieldEnum]


  export const PolicyPermissionScalarFieldEnum: {
    policy_id: 'policy_id',
    permission_id: 'permission_id'
  };

  export type PolicyPermissionScalarFieldEnum = (typeof PolicyPermissionScalarFieldEnum)[keyof typeof PolicyPermissionScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    role_id: 'role_id',
    name: 'name',
    description: 'description',
    is_active: 'is_active',
    tenant_id: 'tenant_id',
    is_system_role: 'is_system_role',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const RolePolicyScalarFieldEnum: {
    role_id: 'role_id',
    policy_id: 'policy_id'
  };

  export type RolePolicyScalarFieldEnum = (typeof RolePolicyScalarFieldEnum)[keyof typeof RolePolicyScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'BookingStatusEnum'
   */
  export type EnumBookingStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatusEnum'>
    


  /**
   * Reference to a field of type 'BookingStatusEnum[]'
   */
  export type ListEnumBookingStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatusEnum[]'>
    


  /**
   * Reference to a field of type 'RouteManagementStatusEnum'
   */
  export type EnumRouteManagementStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RouteManagementStatusEnum'>
    


  /**
   * Reference to a field of type 'RouteManagementStatusEnum[]'
   */
  export type ListEnumRouteManagementStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RouteManagementStatusEnum[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'GenderEnum'
   */
  export type EnumGenderEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GenderEnum'>
    


  /**
   * Reference to a field of type 'GenderEnum[]'
   */
  export type ListEnumGenderEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GenderEnum[]'>
    


  /**
   * Reference to a field of type 'VerificationStatusEnum'
   */
  export type EnumVerificationStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationStatusEnum'>
    


  /**
   * Reference to a field of type 'VerificationStatusEnum[]'
   */
  export type ListEnumVerificationStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationStatusEnum[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'ShiftLogTypeEnum'
   */
  export type EnumShiftLogTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShiftLogTypeEnum'>
    


  /**
   * Reference to a field of type 'ShiftLogTypeEnum[]'
   */
  export type ListEnumShiftLogTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShiftLogTypeEnum[]'>
    


  /**
   * Reference to a field of type 'PickupTypeEnum'
   */
  export type EnumPickupTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PickupTypeEnum'>
    


  /**
   * Reference to a field of type 'PickupTypeEnum[]'
   */
  export type ListEnumPickupTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PickupTypeEnum[]'>
    
  /**
   * Deep Input Types
   */


  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    booking_id?: IntFilter<"Booking"> | number
    tenant_id?: StringFilter<"Booking"> | string
    employee_id?: IntFilter<"Booking"> | number
    employee_code?: StringFilter<"Booking"> | string
    shift_id?: IntNullableFilter<"Booking"> | number | null
    team_id?: IntNullableFilter<"Booking"> | number | null
    booking_date?: DateTimeFilter<"Booking"> | Date | string
    pickup_latitude?: FloatNullableFilter<"Booking"> | number | null
    pickup_longitude?: FloatNullableFilter<"Booking"> | number | null
    pickup_location?: StringNullableFilter<"Booking"> | string | null
    drop_latitude?: FloatNullableFilter<"Booking"> | number | null
    drop_longitude?: FloatNullableFilter<"Booking"> | number | null
    drop_location?: StringNullableFilter<"Booking"> | string | null
    status?: EnumBookingStatusEnumFilter<"Booking"> | $Enums.BookingStatusEnum
    reason?: StringNullableFilter<"Booking"> | string | null
    created_at?: DateTimeFilter<"Booking"> | Date | string
    updated_at?: DateTimeFilter<"Booking"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    shift?: XOR<ShiftNullableScalarRelationFilter, ShiftWhereInput> | null
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
  }

  export type BookingOrderByWithRelationInput = {
    booking_id?: SortOrder
    tenant_id?: SortOrder
    employee_id?: SortOrder
    employee_code?: SortOrder
    shift_id?: SortOrderInput | SortOrder
    team_id?: SortOrderInput | SortOrder
    booking_date?: SortOrder
    pickup_latitude?: SortOrderInput | SortOrder
    pickup_longitude?: SortOrderInput | SortOrder
    pickup_location?: SortOrderInput | SortOrder
    drop_latitude?: SortOrderInput | SortOrder
    drop_longitude?: SortOrderInput | SortOrder
    drop_location?: SortOrderInput | SortOrder
    status?: SortOrder
    reason?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
    shift?: ShiftOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    booking_id?: number
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    tenant_id?: StringFilter<"Booking"> | string
    employee_id?: IntFilter<"Booking"> | number
    employee_code?: StringFilter<"Booking"> | string
    shift_id?: IntNullableFilter<"Booking"> | number | null
    team_id?: IntNullableFilter<"Booking"> | number | null
    booking_date?: DateTimeFilter<"Booking"> | Date | string
    pickup_latitude?: FloatNullableFilter<"Booking"> | number | null
    pickup_longitude?: FloatNullableFilter<"Booking"> | number | null
    pickup_location?: StringNullableFilter<"Booking"> | string | null
    drop_latitude?: FloatNullableFilter<"Booking"> | number | null
    drop_longitude?: FloatNullableFilter<"Booking"> | number | null
    drop_location?: StringNullableFilter<"Booking"> | string | null
    status?: EnumBookingStatusEnumFilter<"Booking"> | $Enums.BookingStatusEnum
    reason?: StringNullableFilter<"Booking"> | string | null
    created_at?: DateTimeFilter<"Booking"> | Date | string
    updated_at?: DateTimeFilter<"Booking"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    shift?: XOR<ShiftNullableScalarRelationFilter, ShiftWhereInput> | null
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
  }, "booking_id">

  export type BookingOrderByWithAggregationInput = {
    booking_id?: SortOrder
    tenant_id?: SortOrder
    employee_id?: SortOrder
    employee_code?: SortOrder
    shift_id?: SortOrderInput | SortOrder
    team_id?: SortOrderInput | SortOrder
    booking_date?: SortOrder
    pickup_latitude?: SortOrderInput | SortOrder
    pickup_longitude?: SortOrderInput | SortOrder
    pickup_location?: SortOrderInput | SortOrder
    drop_latitude?: SortOrderInput | SortOrder
    drop_longitude?: SortOrderInput | SortOrder
    drop_location?: SortOrderInput | SortOrder
    status?: SortOrder
    reason?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    booking_id?: IntWithAggregatesFilter<"Booking"> | number
    tenant_id?: StringWithAggregatesFilter<"Booking"> | string
    employee_id?: IntWithAggregatesFilter<"Booking"> | number
    employee_code?: StringWithAggregatesFilter<"Booking"> | string
    shift_id?: IntNullableWithAggregatesFilter<"Booking"> | number | null
    team_id?: IntNullableWithAggregatesFilter<"Booking"> | number | null
    booking_date?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    pickup_latitude?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    pickup_longitude?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    pickup_location?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    drop_latitude?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    drop_longitude?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    drop_location?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    status?: EnumBookingStatusEnumWithAggregatesFilter<"Booking"> | $Enums.BookingStatusEnum
    reason?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
  }

  export type RouteWhereInput = {
    AND?: RouteWhereInput | RouteWhereInput[]
    OR?: RouteWhereInput[]
    NOT?: RouteWhereInput | RouteWhereInput[]
    id?: IntFilter<"Route"> | number
    created_at?: DateTimeFilter<"Route"> | Date | string
    updated_at?: DateTimeFilter<"Route"> | Date | string
  }

  export type RouteOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RouteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RouteWhereInput | RouteWhereInput[]
    OR?: RouteWhereInput[]
    NOT?: RouteWhereInput | RouteWhereInput[]
    created_at?: DateTimeFilter<"Route"> | Date | string
    updated_at?: DateTimeFilter<"Route"> | Date | string
  }, "id">

  export type RouteOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: RouteCountOrderByAggregateInput
    _avg?: RouteAvgOrderByAggregateInput
    _max?: RouteMaxOrderByAggregateInput
    _min?: RouteMinOrderByAggregateInput
    _sum?: RouteSumOrderByAggregateInput
  }

  export type RouteScalarWhereWithAggregatesInput = {
    AND?: RouteScalarWhereWithAggregatesInput | RouteScalarWhereWithAggregatesInput[]
    OR?: RouteScalarWhereWithAggregatesInput[]
    NOT?: RouteScalarWhereWithAggregatesInput | RouteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Route"> | number
    created_at?: DateTimeWithAggregatesFilter<"Route"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Route"> | Date | string
  }

  export type RouteManagementBookingWhereInput = {
    AND?: RouteManagementBookingWhereInput | RouteManagementBookingWhereInput[]
    OR?: RouteManagementBookingWhereInput[]
    NOT?: RouteManagementBookingWhereInput | RouteManagementBookingWhereInput[]
    id?: IntFilter<"RouteManagementBooking"> | number
    route_id?: StringFilter<"RouteManagementBooking"> | string
    booking_id?: IntFilter<"RouteManagementBooking"> | number
    stop_order?: IntFilter<"RouteManagementBooking"> | number
    estimated_pickup_time?: StringNullableFilter<"RouteManagementBooking"> | string | null
    estimated_drop_time?: StringNullableFilter<"RouteManagementBooking"> | string | null
    distance_from_previous?: FloatNullableFilter<"RouteManagementBooking"> | number | null
    cumulative_distance?: FloatNullableFilter<"RouteManagementBooking"> | number | null
    created_at?: DateTimeFilter<"RouteManagementBooking"> | Date | string
    route_management?: XOR<RouteManagementScalarRelationFilter, RouteManagementWhereInput>
  }

  export type RouteManagementBookingOrderByWithRelationInput = {
    id?: SortOrder
    route_id?: SortOrder
    booking_id?: SortOrder
    stop_order?: SortOrder
    estimated_pickup_time?: SortOrderInput | SortOrder
    estimated_drop_time?: SortOrderInput | SortOrder
    distance_from_previous?: SortOrderInput | SortOrder
    cumulative_distance?: SortOrderInput | SortOrder
    created_at?: SortOrder
    route_management?: RouteManagementOrderByWithRelationInput
  }

  export type RouteManagementBookingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uq_route_management_booking_unique?: RouteManagementBookingUq_route_management_booking_uniqueCompoundUniqueInput
    AND?: RouteManagementBookingWhereInput | RouteManagementBookingWhereInput[]
    OR?: RouteManagementBookingWhereInput[]
    NOT?: RouteManagementBookingWhereInput | RouteManagementBookingWhereInput[]
    route_id?: StringFilter<"RouteManagementBooking"> | string
    booking_id?: IntFilter<"RouteManagementBooking"> | number
    stop_order?: IntFilter<"RouteManagementBooking"> | number
    estimated_pickup_time?: StringNullableFilter<"RouteManagementBooking"> | string | null
    estimated_drop_time?: StringNullableFilter<"RouteManagementBooking"> | string | null
    distance_from_previous?: FloatNullableFilter<"RouteManagementBooking"> | number | null
    cumulative_distance?: FloatNullableFilter<"RouteManagementBooking"> | number | null
    created_at?: DateTimeFilter<"RouteManagementBooking"> | Date | string
    route_management?: XOR<RouteManagementScalarRelationFilter, RouteManagementWhereInput>
  }, "id" | "uq_route_management_booking_unique">

  export type RouteManagementBookingOrderByWithAggregationInput = {
    id?: SortOrder
    route_id?: SortOrder
    booking_id?: SortOrder
    stop_order?: SortOrder
    estimated_pickup_time?: SortOrderInput | SortOrder
    estimated_drop_time?: SortOrderInput | SortOrder
    distance_from_previous?: SortOrderInput | SortOrder
    cumulative_distance?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: RouteManagementBookingCountOrderByAggregateInput
    _avg?: RouteManagementBookingAvgOrderByAggregateInput
    _max?: RouteManagementBookingMaxOrderByAggregateInput
    _min?: RouteManagementBookingMinOrderByAggregateInput
    _sum?: RouteManagementBookingSumOrderByAggregateInput
  }

  export type RouteManagementBookingScalarWhereWithAggregatesInput = {
    AND?: RouteManagementBookingScalarWhereWithAggregatesInput | RouteManagementBookingScalarWhereWithAggregatesInput[]
    OR?: RouteManagementBookingScalarWhereWithAggregatesInput[]
    NOT?: RouteManagementBookingScalarWhereWithAggregatesInput | RouteManagementBookingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RouteManagementBooking"> | number
    route_id?: StringWithAggregatesFilter<"RouteManagementBooking"> | string
    booking_id?: IntWithAggregatesFilter<"RouteManagementBooking"> | number
    stop_order?: IntWithAggregatesFilter<"RouteManagementBooking"> | number
    estimated_pickup_time?: StringNullableWithAggregatesFilter<"RouteManagementBooking"> | string | null
    estimated_drop_time?: StringNullableWithAggregatesFilter<"RouteManagementBooking"> | string | null
    distance_from_previous?: FloatNullableWithAggregatesFilter<"RouteManagementBooking"> | number | null
    cumulative_distance?: FloatNullableWithAggregatesFilter<"RouteManagementBooking"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"RouteManagementBooking"> | Date | string
  }

  export type RouteManagementWhereInput = {
    AND?: RouteManagementWhereInput | RouteManagementWhereInput[]
    OR?: RouteManagementWhereInput[]
    NOT?: RouteManagementWhereInput | RouteManagementWhereInput[]
    route_id?: StringFilter<"RouteManagement"> | string
    tenant_id?: StringFilter<"RouteManagement"> | string
    shift_id?: IntNullableFilter<"RouteManagement"> | number | null
    route_code?: StringFilter<"RouteManagement"> | string
    status?: EnumRouteManagementStatusEnumFilter<"RouteManagement"> | $Enums.RouteManagementStatusEnum
    planned_distance_km?: FloatNullableFilter<"RouteManagement"> | number | null
    planned_duration_minutes?: IntNullableFilter<"RouteManagement"> | number | null
    actual_distance_km?: FloatNullableFilter<"RouteManagement"> | number | null
    actual_duration_minutes?: IntNullableFilter<"RouteManagement"> | number | null
    actual_start_time?: DateTimeNullableFilter<"RouteManagement"> | Date | string | null
    actual_end_time?: DateTimeNullableFilter<"RouteManagement"> | Date | string | null
    optimized_polyline?: StringNullableFilter<"RouteManagement"> | string | null
    assigned_vendor_id?: IntNullableFilter<"RouteManagement"> | number | null
    assigned_vehicle_id?: IntNullableFilter<"RouteManagement"> | number | null
    assigned_driver_id?: IntNullableFilter<"RouteManagement"> | number | null
    total_distance_km?: FloatNullableFilter<"RouteManagement"> | number | null
    total_time_minutes?: FloatNullableFilter<"RouteManagement"> | number | null
    is_active?: BoolFilter<"RouteManagement"> | boolean
    version?: IntFilter<"RouteManagement"> | number
    created_at?: DateTimeFilter<"RouteManagement"> | Date | string
    updated_at?: DateTimeFilter<"RouteManagement"> | Date | string
    route_management_bookings?: RouteManagementBookingListRelationFilter
  }

  export type RouteManagementOrderByWithRelationInput = {
    route_id?: SortOrder
    tenant_id?: SortOrder
    shift_id?: SortOrderInput | SortOrder
    route_code?: SortOrder
    status?: SortOrder
    planned_distance_km?: SortOrderInput | SortOrder
    planned_duration_minutes?: SortOrderInput | SortOrder
    actual_distance_km?: SortOrderInput | SortOrder
    actual_duration_minutes?: SortOrderInput | SortOrder
    actual_start_time?: SortOrderInput | SortOrder
    actual_end_time?: SortOrderInput | SortOrder
    optimized_polyline?: SortOrderInput | SortOrder
    assigned_vendor_id?: SortOrderInput | SortOrder
    assigned_vehicle_id?: SortOrderInput | SortOrder
    assigned_driver_id?: SortOrderInput | SortOrder
    total_distance_km?: SortOrderInput | SortOrder
    total_time_minutes?: SortOrderInput | SortOrder
    is_active?: SortOrder
    version?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    route_management_bookings?: RouteManagementBookingOrderByRelationAggregateInput
  }

  export type RouteManagementWhereUniqueInput = Prisma.AtLeast<{
    route_id?: string
    uq_route_management_code_per_tenant?: RouteManagementUq_route_management_code_per_tenantCompoundUniqueInput
    AND?: RouteManagementWhereInput | RouteManagementWhereInput[]
    OR?: RouteManagementWhereInput[]
    NOT?: RouteManagementWhereInput | RouteManagementWhereInput[]
    tenant_id?: StringFilter<"RouteManagement"> | string
    shift_id?: IntNullableFilter<"RouteManagement"> | number | null
    route_code?: StringFilter<"RouteManagement"> | string
    status?: EnumRouteManagementStatusEnumFilter<"RouteManagement"> | $Enums.RouteManagementStatusEnum
    planned_distance_km?: FloatNullableFilter<"RouteManagement"> | number | null
    planned_duration_minutes?: IntNullableFilter<"RouteManagement"> | number | null
    actual_distance_km?: FloatNullableFilter<"RouteManagement"> | number | null
    actual_duration_minutes?: IntNullableFilter<"RouteManagement"> | number | null
    actual_start_time?: DateTimeNullableFilter<"RouteManagement"> | Date | string | null
    actual_end_time?: DateTimeNullableFilter<"RouteManagement"> | Date | string | null
    optimized_polyline?: StringNullableFilter<"RouteManagement"> | string | null
    assigned_vendor_id?: IntNullableFilter<"RouteManagement"> | number | null
    assigned_vehicle_id?: IntNullableFilter<"RouteManagement"> | number | null
    assigned_driver_id?: IntNullableFilter<"RouteManagement"> | number | null
    total_distance_km?: FloatNullableFilter<"RouteManagement"> | number | null
    total_time_minutes?: FloatNullableFilter<"RouteManagement"> | number | null
    is_active?: BoolFilter<"RouteManagement"> | boolean
    version?: IntFilter<"RouteManagement"> | number
    created_at?: DateTimeFilter<"RouteManagement"> | Date | string
    updated_at?: DateTimeFilter<"RouteManagement"> | Date | string
    route_management_bookings?: RouteManagementBookingListRelationFilter
  }, "route_id" | "uq_route_management_code_per_tenant">

  export type RouteManagementOrderByWithAggregationInput = {
    route_id?: SortOrder
    tenant_id?: SortOrder
    shift_id?: SortOrderInput | SortOrder
    route_code?: SortOrder
    status?: SortOrder
    planned_distance_km?: SortOrderInput | SortOrder
    planned_duration_minutes?: SortOrderInput | SortOrder
    actual_distance_km?: SortOrderInput | SortOrder
    actual_duration_minutes?: SortOrderInput | SortOrder
    actual_start_time?: SortOrderInput | SortOrder
    actual_end_time?: SortOrderInput | SortOrder
    optimized_polyline?: SortOrderInput | SortOrder
    assigned_vendor_id?: SortOrderInput | SortOrder
    assigned_vehicle_id?: SortOrderInput | SortOrder
    assigned_driver_id?: SortOrderInput | SortOrder
    total_distance_km?: SortOrderInput | SortOrder
    total_time_minutes?: SortOrderInput | SortOrder
    is_active?: SortOrder
    version?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: RouteManagementCountOrderByAggregateInput
    _avg?: RouteManagementAvgOrderByAggregateInput
    _max?: RouteManagementMaxOrderByAggregateInput
    _min?: RouteManagementMinOrderByAggregateInput
    _sum?: RouteManagementSumOrderByAggregateInput
  }

  export type RouteManagementScalarWhereWithAggregatesInput = {
    AND?: RouteManagementScalarWhereWithAggregatesInput | RouteManagementScalarWhereWithAggregatesInput[]
    OR?: RouteManagementScalarWhereWithAggregatesInput[]
    NOT?: RouteManagementScalarWhereWithAggregatesInput | RouteManagementScalarWhereWithAggregatesInput[]
    route_id?: StringWithAggregatesFilter<"RouteManagement"> | string
    tenant_id?: StringWithAggregatesFilter<"RouteManagement"> | string
    shift_id?: IntNullableWithAggregatesFilter<"RouteManagement"> | number | null
    route_code?: StringWithAggregatesFilter<"RouteManagement"> | string
    status?: EnumRouteManagementStatusEnumWithAggregatesFilter<"RouteManagement"> | $Enums.RouteManagementStatusEnum
    planned_distance_km?: FloatNullableWithAggregatesFilter<"RouteManagement"> | number | null
    planned_duration_minutes?: IntNullableWithAggregatesFilter<"RouteManagement"> | number | null
    actual_distance_km?: FloatNullableWithAggregatesFilter<"RouteManagement"> | number | null
    actual_duration_minutes?: IntNullableWithAggregatesFilter<"RouteManagement"> | number | null
    actual_start_time?: DateTimeNullableWithAggregatesFilter<"RouteManagement"> | Date | string | null
    actual_end_time?: DateTimeNullableWithAggregatesFilter<"RouteManagement"> | Date | string | null
    optimized_polyline?: StringNullableWithAggregatesFilter<"RouteManagement"> | string | null
    assigned_vendor_id?: IntNullableWithAggregatesFilter<"RouteManagement"> | number | null
    assigned_vehicle_id?: IntNullableWithAggregatesFilter<"RouteManagement"> | number | null
    assigned_driver_id?: IntNullableWithAggregatesFilter<"RouteManagement"> | number | null
    total_distance_km?: FloatNullableWithAggregatesFilter<"RouteManagement"> | number | null
    total_time_minutes?: FloatNullableWithAggregatesFilter<"RouteManagement"> | number | null
    is_active?: BoolWithAggregatesFilter<"RouteManagement"> | boolean
    version?: IntWithAggregatesFilter<"RouteManagement"> | number
    created_at?: DateTimeWithAggregatesFilter<"RouteManagement"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"RouteManagement"> | Date | string
  }

  export type DriverWhereInput = {
    AND?: DriverWhereInput | DriverWhereInput[]
    OR?: DriverWhereInput[]
    NOT?: DriverWhereInput | DriverWhereInput[]
    driver_id?: IntFilter<"Driver"> | number
    vendor_id?: IntFilter<"Driver"> | number
    name?: StringFilter<"Driver"> | string
    code?: StringFilter<"Driver"> | string
    email?: StringFilter<"Driver"> | string
    phone?: StringFilter<"Driver"> | string
    gender?: EnumGenderEnumNullableFilter<"Driver"> | $Enums.GenderEnum | null
    password?: StringFilter<"Driver"> | string
    date_of_birth?: DateTimeNullableFilter<"Driver"> | Date | string | null
    date_of_joining?: DateTimeNullableFilter<"Driver"> | Date | string | null
    permanent_address?: StringNullableFilter<"Driver"> | string | null
    current_address?: StringNullableFilter<"Driver"> | string | null
    photo_url?: StringNullableFilter<"Driver"> | string | null
    bg_verify_status?: EnumVerificationStatusEnumNullableFilter<"Driver"> | $Enums.VerificationStatusEnum | null
    bg_expiry_date?: DateTimeNullableFilter<"Driver"> | Date | string | null
    bg_verify_url?: StringNullableFilter<"Driver"> | string | null
    police_verify_status?: EnumVerificationStatusEnumNullableFilter<"Driver"> | $Enums.VerificationStatusEnum | null
    police_expiry_date?: DateTimeNullableFilter<"Driver"> | Date | string | null
    police_verify_url?: StringNullableFilter<"Driver"> | string | null
    medical_verify_status?: EnumVerificationStatusEnumNullableFilter<"Driver"> | $Enums.VerificationStatusEnum | null
    medical_expiry_date?: DateTimeNullableFilter<"Driver"> | Date | string | null
    medical_verify_url?: StringNullableFilter<"Driver"> | string | null
    training_verify_status?: EnumVerificationStatusEnumNullableFilter<"Driver"> | $Enums.VerificationStatusEnum | null
    training_expiry_date?: DateTimeNullableFilter<"Driver"> | Date | string | null
    training_verify_url?: StringNullableFilter<"Driver"> | string | null
    eye_verify_status?: EnumVerificationStatusEnumNullableFilter<"Driver"> | $Enums.VerificationStatusEnum | null
    eye_expiry_date?: DateTimeNullableFilter<"Driver"> | Date | string | null
    eye_verify_url?: StringNullableFilter<"Driver"> | string | null
    license_number?: StringNullableFilter<"Driver"> | string | null
    license_expiry_date?: DateTimeNullableFilter<"Driver"> | Date | string | null
    license_url?: StringNullableFilter<"Driver"> | string | null
    badge_number?: StringNullableFilter<"Driver"> | string | null
    badge_expiry_date?: DateTimeNullableFilter<"Driver"> | Date | string | null
    badge_url?: StringNullableFilter<"Driver"> | string | null
    alt_govt_id_number?: StringNullableFilter<"Driver"> | string | null
    alt_govt_id_type?: StringNullableFilter<"Driver"> | string | null
    alt_govt_id_url?: StringNullableFilter<"Driver"> | string | null
    induction_date?: DateTimeNullableFilter<"Driver"> | Date | string | null
    induction_url?: StringNullableFilter<"Driver"> | string | null
    is_active?: BoolFilter<"Driver"> | boolean
    created_at?: DateTimeFilter<"Driver"> | Date | string
    updated_at?: DateTimeFilter<"Driver"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    vehicles?: VehicleListRelationFilter
  }

  export type DriverOrderByWithRelationInput = {
    driver_id?: SortOrder
    vendor_id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    gender?: SortOrderInput | SortOrder
    password?: SortOrder
    date_of_birth?: SortOrderInput | SortOrder
    date_of_joining?: SortOrderInput | SortOrder
    permanent_address?: SortOrderInput | SortOrder
    current_address?: SortOrderInput | SortOrder
    photo_url?: SortOrderInput | SortOrder
    bg_verify_status?: SortOrderInput | SortOrder
    bg_expiry_date?: SortOrderInput | SortOrder
    bg_verify_url?: SortOrderInput | SortOrder
    police_verify_status?: SortOrderInput | SortOrder
    police_expiry_date?: SortOrderInput | SortOrder
    police_verify_url?: SortOrderInput | SortOrder
    medical_verify_status?: SortOrderInput | SortOrder
    medical_expiry_date?: SortOrderInput | SortOrder
    medical_verify_url?: SortOrderInput | SortOrder
    training_verify_status?: SortOrderInput | SortOrder
    training_expiry_date?: SortOrderInput | SortOrder
    training_verify_url?: SortOrderInput | SortOrder
    eye_verify_status?: SortOrderInput | SortOrder
    eye_expiry_date?: SortOrderInput | SortOrder
    eye_verify_url?: SortOrderInput | SortOrder
    license_number?: SortOrderInput | SortOrder
    license_expiry_date?: SortOrderInput | SortOrder
    license_url?: SortOrderInput | SortOrder
    badge_number?: SortOrderInput | SortOrder
    badge_expiry_date?: SortOrderInput | SortOrder
    badge_url?: SortOrderInput | SortOrder
    alt_govt_id_number?: SortOrderInput | SortOrder
    alt_govt_id_type?: SortOrderInput | SortOrder
    alt_govt_id_url?: SortOrderInput | SortOrder
    induction_date?: SortOrderInput | SortOrder
    induction_url?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    vendor?: VendorOrderByWithRelationInput
    vehicles?: VehicleOrderByRelationAggregateInput
  }

  export type DriverWhereUniqueInput = Prisma.AtLeast<{
    driver_id?: number
    uq_vendor_driver_email?: DriverUq_vendor_driver_emailCompoundUniqueInput
    uq_vendor_driver_phone?: DriverUq_vendor_driver_phoneCompoundUniqueInput
    uq_vendor_driver_badge?: DriverUq_vendor_driver_badgeCompoundUniqueInput
    uq_vendor_driver_license?: DriverUq_vendor_driver_licenseCompoundUniqueInput
    uq_vendor_driver_code?: DriverUq_vendor_driver_codeCompoundUniqueInput
    uq_vendor_driver_alt_govt_id?: DriverUq_vendor_driver_alt_govt_idCompoundUniqueInput
    AND?: DriverWhereInput | DriverWhereInput[]
    OR?: DriverWhereInput[]
    NOT?: DriverWhereInput | DriverWhereInput[]
    vendor_id?: IntFilter<"Driver"> | number
    name?: StringFilter<"Driver"> | string
    code?: StringFilter<"Driver"> | string
    email?: StringFilter<"Driver"> | string
    phone?: StringFilter<"Driver"> | string
    gender?: EnumGenderEnumNullableFilter<"Driver"> | $Enums.GenderEnum | null
    password?: StringFilter<"Driver"> | string
    date_of_birth?: DateTimeNullableFilter<"Driver"> | Date | string | null
    date_of_joining?: DateTimeNullableFilter<"Driver"> | Date | string | null
    permanent_address?: StringNullableFilter<"Driver"> | string | null
    current_address?: StringNullableFilter<"Driver"> | string | null
    photo_url?: StringNullableFilter<"Driver"> | string | null
    bg_verify_status?: EnumVerificationStatusEnumNullableFilter<"Driver"> | $Enums.VerificationStatusEnum | null
    bg_expiry_date?: DateTimeNullableFilter<"Driver"> | Date | string | null
    bg_verify_url?: StringNullableFilter<"Driver"> | string | null
    police_verify_status?: EnumVerificationStatusEnumNullableFilter<"Driver"> | $Enums.VerificationStatusEnum | null
    police_expiry_date?: DateTimeNullableFilter<"Driver"> | Date | string | null
    police_verify_url?: StringNullableFilter<"Driver"> | string | null
    medical_verify_status?: EnumVerificationStatusEnumNullableFilter<"Driver"> | $Enums.VerificationStatusEnum | null
    medical_expiry_date?: DateTimeNullableFilter<"Driver"> | Date | string | null
    medical_verify_url?: StringNullableFilter<"Driver"> | string | null
    training_verify_status?: EnumVerificationStatusEnumNullableFilter<"Driver"> | $Enums.VerificationStatusEnum | null
    training_expiry_date?: DateTimeNullableFilter<"Driver"> | Date | string | null
    training_verify_url?: StringNullableFilter<"Driver"> | string | null
    eye_verify_status?: EnumVerificationStatusEnumNullableFilter<"Driver"> | $Enums.VerificationStatusEnum | null
    eye_expiry_date?: DateTimeNullableFilter<"Driver"> | Date | string | null
    eye_verify_url?: StringNullableFilter<"Driver"> | string | null
    license_number?: StringNullableFilter<"Driver"> | string | null
    license_expiry_date?: DateTimeNullableFilter<"Driver"> | Date | string | null
    license_url?: StringNullableFilter<"Driver"> | string | null
    badge_number?: StringNullableFilter<"Driver"> | string | null
    badge_expiry_date?: DateTimeNullableFilter<"Driver"> | Date | string | null
    badge_url?: StringNullableFilter<"Driver"> | string | null
    alt_govt_id_number?: StringNullableFilter<"Driver"> | string | null
    alt_govt_id_type?: StringNullableFilter<"Driver"> | string | null
    alt_govt_id_url?: StringNullableFilter<"Driver"> | string | null
    induction_date?: DateTimeNullableFilter<"Driver"> | Date | string | null
    induction_url?: StringNullableFilter<"Driver"> | string | null
    is_active?: BoolFilter<"Driver"> | boolean
    created_at?: DateTimeFilter<"Driver"> | Date | string
    updated_at?: DateTimeFilter<"Driver"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    vehicles?: VehicleListRelationFilter
  }, "driver_id" | "uq_vendor_driver_email" | "uq_vendor_driver_phone" | "uq_vendor_driver_badge" | "uq_vendor_driver_license" | "uq_vendor_driver_code" | "uq_vendor_driver_alt_govt_id">

  export type DriverOrderByWithAggregationInput = {
    driver_id?: SortOrder
    vendor_id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    gender?: SortOrderInput | SortOrder
    password?: SortOrder
    date_of_birth?: SortOrderInput | SortOrder
    date_of_joining?: SortOrderInput | SortOrder
    permanent_address?: SortOrderInput | SortOrder
    current_address?: SortOrderInput | SortOrder
    photo_url?: SortOrderInput | SortOrder
    bg_verify_status?: SortOrderInput | SortOrder
    bg_expiry_date?: SortOrderInput | SortOrder
    bg_verify_url?: SortOrderInput | SortOrder
    police_verify_status?: SortOrderInput | SortOrder
    police_expiry_date?: SortOrderInput | SortOrder
    police_verify_url?: SortOrderInput | SortOrder
    medical_verify_status?: SortOrderInput | SortOrder
    medical_expiry_date?: SortOrderInput | SortOrder
    medical_verify_url?: SortOrderInput | SortOrder
    training_verify_status?: SortOrderInput | SortOrder
    training_expiry_date?: SortOrderInput | SortOrder
    training_verify_url?: SortOrderInput | SortOrder
    eye_verify_status?: SortOrderInput | SortOrder
    eye_expiry_date?: SortOrderInput | SortOrder
    eye_verify_url?: SortOrderInput | SortOrder
    license_number?: SortOrderInput | SortOrder
    license_expiry_date?: SortOrderInput | SortOrder
    license_url?: SortOrderInput | SortOrder
    badge_number?: SortOrderInput | SortOrder
    badge_expiry_date?: SortOrderInput | SortOrder
    badge_url?: SortOrderInput | SortOrder
    alt_govt_id_number?: SortOrderInput | SortOrder
    alt_govt_id_type?: SortOrderInput | SortOrder
    alt_govt_id_url?: SortOrderInput | SortOrder
    induction_date?: SortOrderInput | SortOrder
    induction_url?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: DriverCountOrderByAggregateInput
    _avg?: DriverAvgOrderByAggregateInput
    _max?: DriverMaxOrderByAggregateInput
    _min?: DriverMinOrderByAggregateInput
    _sum?: DriverSumOrderByAggregateInput
  }

  export type DriverScalarWhereWithAggregatesInput = {
    AND?: DriverScalarWhereWithAggregatesInput | DriverScalarWhereWithAggregatesInput[]
    OR?: DriverScalarWhereWithAggregatesInput[]
    NOT?: DriverScalarWhereWithAggregatesInput | DriverScalarWhereWithAggregatesInput[]
    driver_id?: IntWithAggregatesFilter<"Driver"> | number
    vendor_id?: IntWithAggregatesFilter<"Driver"> | number
    name?: StringWithAggregatesFilter<"Driver"> | string
    code?: StringWithAggregatesFilter<"Driver"> | string
    email?: StringWithAggregatesFilter<"Driver"> | string
    phone?: StringWithAggregatesFilter<"Driver"> | string
    gender?: EnumGenderEnumNullableWithAggregatesFilter<"Driver"> | $Enums.GenderEnum | null
    password?: StringWithAggregatesFilter<"Driver"> | string
    date_of_birth?: DateTimeNullableWithAggregatesFilter<"Driver"> | Date | string | null
    date_of_joining?: DateTimeNullableWithAggregatesFilter<"Driver"> | Date | string | null
    permanent_address?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    current_address?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    photo_url?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    bg_verify_status?: EnumVerificationStatusEnumNullableWithAggregatesFilter<"Driver"> | $Enums.VerificationStatusEnum | null
    bg_expiry_date?: DateTimeNullableWithAggregatesFilter<"Driver"> | Date | string | null
    bg_verify_url?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    police_verify_status?: EnumVerificationStatusEnumNullableWithAggregatesFilter<"Driver"> | $Enums.VerificationStatusEnum | null
    police_expiry_date?: DateTimeNullableWithAggregatesFilter<"Driver"> | Date | string | null
    police_verify_url?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    medical_verify_status?: EnumVerificationStatusEnumNullableWithAggregatesFilter<"Driver"> | $Enums.VerificationStatusEnum | null
    medical_expiry_date?: DateTimeNullableWithAggregatesFilter<"Driver"> | Date | string | null
    medical_verify_url?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    training_verify_status?: EnumVerificationStatusEnumNullableWithAggregatesFilter<"Driver"> | $Enums.VerificationStatusEnum | null
    training_expiry_date?: DateTimeNullableWithAggregatesFilter<"Driver"> | Date | string | null
    training_verify_url?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    eye_verify_status?: EnumVerificationStatusEnumNullableWithAggregatesFilter<"Driver"> | $Enums.VerificationStatusEnum | null
    eye_expiry_date?: DateTimeNullableWithAggregatesFilter<"Driver"> | Date | string | null
    eye_verify_url?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    license_number?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    license_expiry_date?: DateTimeNullableWithAggregatesFilter<"Driver"> | Date | string | null
    license_url?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    badge_number?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    badge_expiry_date?: DateTimeNullableWithAggregatesFilter<"Driver"> | Date | string | null
    badge_url?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    alt_govt_id_number?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    alt_govt_id_type?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    alt_govt_id_url?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    induction_date?: DateTimeNullableWithAggregatesFilter<"Driver"> | Date | string | null
    induction_url?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    is_active?: BoolWithAggregatesFilter<"Driver"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Driver"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Driver"> | Date | string
  }

  export type VehicleWhereInput = {
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    vehicle_id?: IntFilter<"Vehicle"> | number
    vehicle_type_id?: IntFilter<"Vehicle"> | number
    vendor_id?: IntFilter<"Vehicle"> | number
    driver_id?: IntNullableFilter<"Vehicle"> | number | null
    rc_number?: StringFilter<"Vehicle"> | string
    rc_expiry_date?: DateTimeNullableFilter<"Vehicle"> | Date | string | null
    description?: StringNullableFilter<"Vehicle"> | string | null
    puc_number?: StringNullableFilter<"Vehicle"> | string | null
    puc_expiry_date?: DateTimeNullableFilter<"Vehicle"> | Date | string | null
    puc_url?: StringNullableFilter<"Vehicle"> | string | null
    fitness_number?: StringNullableFilter<"Vehicle"> | string | null
    fitness_expiry_date?: DateTimeNullableFilter<"Vehicle"> | Date | string | null
    fitness_url?: StringNullableFilter<"Vehicle"> | string | null
    tax_receipt_number?: StringNullableFilter<"Vehicle"> | string | null
    tax_receipt_date?: DateTimeNullableFilter<"Vehicle"> | Date | string | null
    tax_receipt_url?: StringNullableFilter<"Vehicle"> | string | null
    insurance_number?: StringNullableFilter<"Vehicle"> | string | null
    insurance_expiry_date?: DateTimeNullableFilter<"Vehicle"> | Date | string | null
    insurance_url?: StringNullableFilter<"Vehicle"> | string | null
    permit_number?: StringNullableFilter<"Vehicle"> | string | null
    permit_expiry_date?: DateTimeNullableFilter<"Vehicle"> | Date | string | null
    permit_url?: StringNullableFilter<"Vehicle"> | string | null
    is_active?: BoolFilter<"Vehicle"> | boolean
    created_at?: DateTimeFilter<"Vehicle"> | Date | string
    updated_at?: DateTimeFilter<"Vehicle"> | Date | string
    vehicle_type?: XOR<VehicleTypeScalarRelationFilter, VehicleTypeWhereInput>
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    driver?: XOR<DriverNullableScalarRelationFilter, DriverWhereInput> | null
  }

  export type VehicleOrderByWithRelationInput = {
    vehicle_id?: SortOrder
    vehicle_type_id?: SortOrder
    vendor_id?: SortOrder
    driver_id?: SortOrderInput | SortOrder
    rc_number?: SortOrder
    rc_expiry_date?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    puc_number?: SortOrderInput | SortOrder
    puc_expiry_date?: SortOrderInput | SortOrder
    puc_url?: SortOrderInput | SortOrder
    fitness_number?: SortOrderInput | SortOrder
    fitness_expiry_date?: SortOrderInput | SortOrder
    fitness_url?: SortOrderInput | SortOrder
    tax_receipt_number?: SortOrderInput | SortOrder
    tax_receipt_date?: SortOrderInput | SortOrder
    tax_receipt_url?: SortOrderInput | SortOrder
    insurance_number?: SortOrderInput | SortOrder
    insurance_expiry_date?: SortOrderInput | SortOrder
    insurance_url?: SortOrderInput | SortOrder
    permit_number?: SortOrderInput | SortOrder
    permit_expiry_date?: SortOrderInput | SortOrder
    permit_url?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    vehicle_type?: VehicleTypeOrderByWithRelationInput
    vendor?: VendorOrderByWithRelationInput
    driver?: DriverOrderByWithRelationInput
  }

  export type VehicleWhereUniqueInput = Prisma.AtLeast<{
    vehicle_id?: number
    uq_vendor_rc_number?: VehicleUq_vendor_rc_numberCompoundUniqueInput
    uq_vendor_puc_number?: VehicleUq_vendor_puc_numberCompoundUniqueInput
    uq_vendor_fitness_number?: VehicleUq_vendor_fitness_numberCompoundUniqueInput
    uq_vendor_tax_receipt_number?: VehicleUq_vendor_tax_receipt_numberCompoundUniqueInput
    uq_vendor_insurance_number?: VehicleUq_vendor_insurance_numberCompoundUniqueInput
    uq_vendor_permit_number?: VehicleUq_vendor_permit_numberCompoundUniqueInput
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    vehicle_type_id?: IntFilter<"Vehicle"> | number
    vendor_id?: IntFilter<"Vehicle"> | number
    driver_id?: IntNullableFilter<"Vehicle"> | number | null
    rc_number?: StringFilter<"Vehicle"> | string
    rc_expiry_date?: DateTimeNullableFilter<"Vehicle"> | Date | string | null
    description?: StringNullableFilter<"Vehicle"> | string | null
    puc_number?: StringNullableFilter<"Vehicle"> | string | null
    puc_expiry_date?: DateTimeNullableFilter<"Vehicle"> | Date | string | null
    puc_url?: StringNullableFilter<"Vehicle"> | string | null
    fitness_number?: StringNullableFilter<"Vehicle"> | string | null
    fitness_expiry_date?: DateTimeNullableFilter<"Vehicle"> | Date | string | null
    fitness_url?: StringNullableFilter<"Vehicle"> | string | null
    tax_receipt_number?: StringNullableFilter<"Vehicle"> | string | null
    tax_receipt_date?: DateTimeNullableFilter<"Vehicle"> | Date | string | null
    tax_receipt_url?: StringNullableFilter<"Vehicle"> | string | null
    insurance_number?: StringNullableFilter<"Vehicle"> | string | null
    insurance_expiry_date?: DateTimeNullableFilter<"Vehicle"> | Date | string | null
    insurance_url?: StringNullableFilter<"Vehicle"> | string | null
    permit_number?: StringNullableFilter<"Vehicle"> | string | null
    permit_expiry_date?: DateTimeNullableFilter<"Vehicle"> | Date | string | null
    permit_url?: StringNullableFilter<"Vehicle"> | string | null
    is_active?: BoolFilter<"Vehicle"> | boolean
    created_at?: DateTimeFilter<"Vehicle"> | Date | string
    updated_at?: DateTimeFilter<"Vehicle"> | Date | string
    vehicle_type?: XOR<VehicleTypeScalarRelationFilter, VehicleTypeWhereInput>
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    driver?: XOR<DriverNullableScalarRelationFilter, DriverWhereInput> | null
  }, "vehicle_id" | "uq_vendor_rc_number" | "uq_vendor_puc_number" | "uq_vendor_fitness_number" | "uq_vendor_tax_receipt_number" | "uq_vendor_insurance_number" | "uq_vendor_permit_number">

  export type VehicleOrderByWithAggregationInput = {
    vehicle_id?: SortOrder
    vehicle_type_id?: SortOrder
    vendor_id?: SortOrder
    driver_id?: SortOrderInput | SortOrder
    rc_number?: SortOrder
    rc_expiry_date?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    puc_number?: SortOrderInput | SortOrder
    puc_expiry_date?: SortOrderInput | SortOrder
    puc_url?: SortOrderInput | SortOrder
    fitness_number?: SortOrderInput | SortOrder
    fitness_expiry_date?: SortOrderInput | SortOrder
    fitness_url?: SortOrderInput | SortOrder
    tax_receipt_number?: SortOrderInput | SortOrder
    tax_receipt_date?: SortOrderInput | SortOrder
    tax_receipt_url?: SortOrderInput | SortOrder
    insurance_number?: SortOrderInput | SortOrder
    insurance_expiry_date?: SortOrderInput | SortOrder
    insurance_url?: SortOrderInput | SortOrder
    permit_number?: SortOrderInput | SortOrder
    permit_expiry_date?: SortOrderInput | SortOrder
    permit_url?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: VehicleCountOrderByAggregateInput
    _avg?: VehicleAvgOrderByAggregateInput
    _max?: VehicleMaxOrderByAggregateInput
    _min?: VehicleMinOrderByAggregateInput
    _sum?: VehicleSumOrderByAggregateInput
  }

  export type VehicleScalarWhereWithAggregatesInput = {
    AND?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    OR?: VehicleScalarWhereWithAggregatesInput[]
    NOT?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    vehicle_id?: IntWithAggregatesFilter<"Vehicle"> | number
    vehicle_type_id?: IntWithAggregatesFilter<"Vehicle"> | number
    vendor_id?: IntWithAggregatesFilter<"Vehicle"> | number
    driver_id?: IntNullableWithAggregatesFilter<"Vehicle"> | number | null
    rc_number?: StringWithAggregatesFilter<"Vehicle"> | string
    rc_expiry_date?: DateTimeNullableWithAggregatesFilter<"Vehicle"> | Date | string | null
    description?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    puc_number?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    puc_expiry_date?: DateTimeNullableWithAggregatesFilter<"Vehicle"> | Date | string | null
    puc_url?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    fitness_number?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    fitness_expiry_date?: DateTimeNullableWithAggregatesFilter<"Vehicle"> | Date | string | null
    fitness_url?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    tax_receipt_number?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    tax_receipt_date?: DateTimeNullableWithAggregatesFilter<"Vehicle"> | Date | string | null
    tax_receipt_url?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    insurance_number?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    insurance_expiry_date?: DateTimeNullableWithAggregatesFilter<"Vehicle"> | Date | string | null
    insurance_url?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    permit_number?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    permit_expiry_date?: DateTimeNullableWithAggregatesFilter<"Vehicle"> | Date | string | null
    permit_url?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    is_active?: BoolWithAggregatesFilter<"Vehicle"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Vehicle"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Vehicle"> | Date | string
  }

  export type VehicleTypeWhereInput = {
    AND?: VehicleTypeWhereInput | VehicleTypeWhereInput[]
    OR?: VehicleTypeWhereInput[]
    NOT?: VehicleTypeWhereInput | VehicleTypeWhereInput[]
    vehicle_type_id?: IntFilter<"VehicleType"> | number
    vendor_id?: IntFilter<"VehicleType"> | number
    name?: StringFilter<"VehicleType"> | string
    description?: StringNullableFilter<"VehicleType"> | string | null
    seats?: IntFilter<"VehicleType"> | number
    is_active?: BoolFilter<"VehicleType"> | boolean
    created_at?: DateTimeFilter<"VehicleType"> | Date | string
    updated_at?: DateTimeFilter<"VehicleType"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    vehicles?: VehicleListRelationFilter
  }

  export type VehicleTypeOrderByWithRelationInput = {
    vehicle_type_id?: SortOrder
    vendor_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    seats?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    vendor?: VendorOrderByWithRelationInput
    vehicles?: VehicleOrderByRelationAggregateInput
  }

  export type VehicleTypeWhereUniqueInput = Prisma.AtLeast<{
    vehicle_type_id?: number
    uq_vendor_vehicle_type_name?: VehicleTypeUq_vendor_vehicle_type_nameCompoundUniqueInput
    AND?: VehicleTypeWhereInput | VehicleTypeWhereInput[]
    OR?: VehicleTypeWhereInput[]
    NOT?: VehicleTypeWhereInput | VehicleTypeWhereInput[]
    vendor_id?: IntFilter<"VehicleType"> | number
    name?: StringFilter<"VehicleType"> | string
    description?: StringNullableFilter<"VehicleType"> | string | null
    seats?: IntFilter<"VehicleType"> | number
    is_active?: BoolFilter<"VehicleType"> | boolean
    created_at?: DateTimeFilter<"VehicleType"> | Date | string
    updated_at?: DateTimeFilter<"VehicleType"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    vehicles?: VehicleListRelationFilter
  }, "vehicle_type_id" | "uq_vendor_vehicle_type_name">

  export type VehicleTypeOrderByWithAggregationInput = {
    vehicle_type_id?: SortOrder
    vendor_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    seats?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: VehicleTypeCountOrderByAggregateInput
    _avg?: VehicleTypeAvgOrderByAggregateInput
    _max?: VehicleTypeMaxOrderByAggregateInput
    _min?: VehicleTypeMinOrderByAggregateInput
    _sum?: VehicleTypeSumOrderByAggregateInput
  }

  export type VehicleTypeScalarWhereWithAggregatesInput = {
    AND?: VehicleTypeScalarWhereWithAggregatesInput | VehicleTypeScalarWhereWithAggregatesInput[]
    OR?: VehicleTypeScalarWhereWithAggregatesInput[]
    NOT?: VehicleTypeScalarWhereWithAggregatesInput | VehicleTypeScalarWhereWithAggregatesInput[]
    vehicle_type_id?: IntWithAggregatesFilter<"VehicleType"> | number
    vendor_id?: IntWithAggregatesFilter<"VehicleType"> | number
    name?: StringWithAggregatesFilter<"VehicleType"> | string
    description?: StringNullableWithAggregatesFilter<"VehicleType"> | string | null
    seats?: IntWithAggregatesFilter<"VehicleType"> | number
    is_active?: BoolWithAggregatesFilter<"VehicleType"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"VehicleType"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"VehicleType"> | Date | string
  }

  export type VendorWhereInput = {
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    vendor_id?: IntFilter<"Vendor"> | number
    tenant_id?: StringFilter<"Vendor"> | string
    name?: StringFilter<"Vendor"> | string
    vendor_code?: StringFilter<"Vendor"> | string
    email?: StringNullableFilter<"Vendor"> | string | null
    phone?: StringNullableFilter<"Vendor"> | string | null
    is_active?: BoolFilter<"Vendor"> | boolean
    created_at?: DateTimeFilter<"Vendor"> | Date | string
    updated_at?: DateTimeFilter<"Vendor"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    drivers?: DriverListRelationFilter
    vehicle_types?: VehicleTypeListRelationFilter
    vehicles?: VehicleListRelationFilter
    vendor_users?: VendorUserListRelationFilter
  }

  export type VendorOrderByWithRelationInput = {
    vendor_id?: SortOrder
    tenant_id?: SortOrder
    name?: SortOrder
    vendor_code?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    drivers?: DriverOrderByRelationAggregateInput
    vehicle_types?: VehicleTypeOrderByRelationAggregateInput
    vehicles?: VehicleOrderByRelationAggregateInput
    vendor_users?: VendorUserOrderByRelationAggregateInput
  }

  export type VendorWhereUniqueInput = Prisma.AtLeast<{
    vendor_id?: number
    uq_vendor_name_per_tenant?: VendorUq_vendor_name_per_tenantCompoundUniqueInput
    uq_vendor_code_per_tenant?: VendorUq_vendor_code_per_tenantCompoundUniqueInput
    uq_vendor_email_per_tenant?: VendorUq_vendor_email_per_tenantCompoundUniqueInput
    uq_vendor_phone_per_tenant?: VendorUq_vendor_phone_per_tenantCompoundUniqueInput
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    tenant_id?: StringFilter<"Vendor"> | string
    name?: StringFilter<"Vendor"> | string
    vendor_code?: StringFilter<"Vendor"> | string
    email?: StringNullableFilter<"Vendor"> | string | null
    phone?: StringNullableFilter<"Vendor"> | string | null
    is_active?: BoolFilter<"Vendor"> | boolean
    created_at?: DateTimeFilter<"Vendor"> | Date | string
    updated_at?: DateTimeFilter<"Vendor"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    drivers?: DriverListRelationFilter
    vehicle_types?: VehicleTypeListRelationFilter
    vehicles?: VehicleListRelationFilter
    vendor_users?: VendorUserListRelationFilter
  }, "vendor_id" | "uq_vendor_name_per_tenant" | "uq_vendor_code_per_tenant" | "uq_vendor_email_per_tenant" | "uq_vendor_phone_per_tenant">

  export type VendorOrderByWithAggregationInput = {
    vendor_id?: SortOrder
    tenant_id?: SortOrder
    name?: SortOrder
    vendor_code?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: VendorCountOrderByAggregateInput
    _avg?: VendorAvgOrderByAggregateInput
    _max?: VendorMaxOrderByAggregateInput
    _min?: VendorMinOrderByAggregateInput
    _sum?: VendorSumOrderByAggregateInput
  }

  export type VendorScalarWhereWithAggregatesInput = {
    AND?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    OR?: VendorScalarWhereWithAggregatesInput[]
    NOT?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    vendor_id?: IntWithAggregatesFilter<"Vendor"> | number
    tenant_id?: StringWithAggregatesFilter<"Vendor"> | string
    name?: StringWithAggregatesFilter<"Vendor"> | string
    vendor_code?: StringWithAggregatesFilter<"Vendor"> | string
    email?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    is_active?: BoolWithAggregatesFilter<"Vendor"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
  }

  export type VendorUserWhereInput = {
    AND?: VendorUserWhereInput | VendorUserWhereInput[]
    OR?: VendorUserWhereInput[]
    NOT?: VendorUserWhereInput | VendorUserWhereInput[]
    vendor_user_id?: IntFilter<"VendorUser"> | number
    tenant_id?: StringFilter<"VendorUser"> | string
    vendor_id?: IntFilter<"VendorUser"> | number
    name?: StringFilter<"VendorUser"> | string
    email?: StringFilter<"VendorUser"> | string
    phone?: StringFilter<"VendorUser"> | string
    password?: StringFilter<"VendorUser"> | string
    role_id?: IntFilter<"VendorUser"> | number
    is_active?: BoolFilter<"VendorUser"> | boolean
    created_at?: DateTimeFilter<"VendorUser"> | Date | string
    updated_at?: DateTimeFilter<"VendorUser"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }

  export type VendorUserOrderByWithRelationInput = {
    vendor_user_id?: SortOrder
    tenant_id?: SortOrder
    vendor_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    vendor?: VendorOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
  }

  export type VendorUserWhereUniqueInput = Prisma.AtLeast<{
    vendor_user_id?: number
    uq_tenant_vendor_email?: VendorUserUq_tenant_vendor_emailCompoundUniqueInput
    uq_tenant_vendor_phone?: VendorUserUq_tenant_vendor_phoneCompoundUniqueInput
    AND?: VendorUserWhereInput | VendorUserWhereInput[]
    OR?: VendorUserWhereInput[]
    NOT?: VendorUserWhereInput | VendorUserWhereInput[]
    tenant_id?: StringFilter<"VendorUser"> | string
    vendor_id?: IntFilter<"VendorUser"> | number
    name?: StringFilter<"VendorUser"> | string
    email?: StringFilter<"VendorUser"> | string
    phone?: StringFilter<"VendorUser"> | string
    password?: StringFilter<"VendorUser"> | string
    role_id?: IntFilter<"VendorUser"> | number
    is_active?: BoolFilter<"VendorUser"> | boolean
    created_at?: DateTimeFilter<"VendorUser"> | Date | string
    updated_at?: DateTimeFilter<"VendorUser"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }, "vendor_user_id" | "uq_tenant_vendor_email" | "uq_tenant_vendor_phone">

  export type VendorUserOrderByWithAggregationInput = {
    vendor_user_id?: SortOrder
    tenant_id?: SortOrder
    vendor_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: VendorUserCountOrderByAggregateInput
    _avg?: VendorUserAvgOrderByAggregateInput
    _max?: VendorUserMaxOrderByAggregateInput
    _min?: VendorUserMinOrderByAggregateInput
    _sum?: VendorUserSumOrderByAggregateInput
  }

  export type VendorUserScalarWhereWithAggregatesInput = {
    AND?: VendorUserScalarWhereWithAggregatesInput | VendorUserScalarWhereWithAggregatesInput[]
    OR?: VendorUserScalarWhereWithAggregatesInput[]
    NOT?: VendorUserScalarWhereWithAggregatesInput | VendorUserScalarWhereWithAggregatesInput[]
    vendor_user_id?: IntWithAggregatesFilter<"VendorUser"> | number
    tenant_id?: StringWithAggregatesFilter<"VendorUser"> | string
    vendor_id?: IntWithAggregatesFilter<"VendorUser"> | number
    name?: StringWithAggregatesFilter<"VendorUser"> | string
    email?: StringWithAggregatesFilter<"VendorUser"> | string
    phone?: StringWithAggregatesFilter<"VendorUser"> | string
    password?: StringWithAggregatesFilter<"VendorUser"> | string
    role_id?: IntWithAggregatesFilter<"VendorUser"> | number
    is_active?: BoolWithAggregatesFilter<"VendorUser"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"VendorUser"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"VendorUser"> | Date | string
  }

  export type CutoffWhereInput = {
    AND?: CutoffWhereInput | CutoffWhereInput[]
    OR?: CutoffWhereInput[]
    NOT?: CutoffWhereInput | CutoffWhereInput[]
    tenant_id?: StringFilter<"Cutoff"> | string
    booking_cutoff?: IntFilter<"Cutoff"> | number
    cancel_cutoff?: IntFilter<"Cutoff"> | number
    created_at?: DateTimeFilter<"Cutoff"> | Date | string
    updated_at?: DateTimeFilter<"Cutoff"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type CutoffOrderByWithRelationInput = {
    tenant_id?: SortOrder
    booking_cutoff?: SortOrder
    cancel_cutoff?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type CutoffWhereUniqueInput = Prisma.AtLeast<{
    tenant_id?: string
    AND?: CutoffWhereInput | CutoffWhereInput[]
    OR?: CutoffWhereInput[]
    NOT?: CutoffWhereInput | CutoffWhereInput[]
    booking_cutoff?: IntFilter<"Cutoff"> | number
    cancel_cutoff?: IntFilter<"Cutoff"> | number
    created_at?: DateTimeFilter<"Cutoff"> | Date | string
    updated_at?: DateTimeFilter<"Cutoff"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "tenant_id">

  export type CutoffOrderByWithAggregationInput = {
    tenant_id?: SortOrder
    booking_cutoff?: SortOrder
    cancel_cutoff?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CutoffCountOrderByAggregateInput
    _avg?: CutoffAvgOrderByAggregateInput
    _max?: CutoffMaxOrderByAggregateInput
    _min?: CutoffMinOrderByAggregateInput
    _sum?: CutoffSumOrderByAggregateInput
  }

  export type CutoffScalarWhereWithAggregatesInput = {
    AND?: CutoffScalarWhereWithAggregatesInput | CutoffScalarWhereWithAggregatesInput[]
    OR?: CutoffScalarWhereWithAggregatesInput[]
    NOT?: CutoffScalarWhereWithAggregatesInput | CutoffScalarWhereWithAggregatesInput[]
    tenant_id?: StringWithAggregatesFilter<"Cutoff"> | string
    booking_cutoff?: IntWithAggregatesFilter<"Cutoff"> | number
    cancel_cutoff?: IntWithAggregatesFilter<"Cutoff"> | number
    created_at?: DateTimeWithAggregatesFilter<"Cutoff"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Cutoff"> | Date | string
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    employee_id?: IntFilter<"Employee"> | number
    tenant_id?: StringFilter<"Employee"> | string
    role_id?: IntFilter<"Employee"> | number
    name?: StringFilter<"Employee"> | string
    employee_code?: StringFilter<"Employee"> | string
    email?: StringFilter<"Employee"> | string
    password?: StringFilter<"Employee"> | string
    team_id?: IntNullableFilter<"Employee"> | number | null
    phone?: StringFilter<"Employee"> | string
    alternate_phone?: StringNullableFilter<"Employee"> | string | null
    special_needs?: StringNullableFilter<"Employee"> | string | null
    special_needs_start_date?: DateTimeNullableFilter<"Employee"> | Date | string | null
    special_needs_end_date?: DateTimeNullableFilter<"Employee"> | Date | string | null
    address?: StringNullableFilter<"Employee"> | string | null
    latitude?: DecimalNullableFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    gender?: EnumGenderEnumNullableFilter<"Employee"> | $Enums.GenderEnum | null
    is_active?: BoolFilter<"Employee"> | boolean
    created_at?: DateTimeFilter<"Employee"> | Date | string
    updated_at?: DateTimeFilter<"Employee"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    bookings?: BookingListRelationFilter
    weekoff_config?: XOR<WeekoffConfigNullableScalarRelationFilter, WeekoffConfigWhereInput> | null
  }

  export type EmployeeOrderByWithRelationInput = {
    employee_id?: SortOrder
    tenant_id?: SortOrder
    role_id?: SortOrder
    name?: SortOrder
    employee_code?: SortOrder
    email?: SortOrder
    password?: SortOrder
    team_id?: SortOrderInput | SortOrder
    phone?: SortOrder
    alternate_phone?: SortOrderInput | SortOrder
    special_needs?: SortOrderInput | SortOrder
    special_needs_start_date?: SortOrderInput | SortOrder
    special_needs_end_date?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
    bookings?: BookingOrderByRelationAggregateInput
    weekoff_config?: WeekoffConfigOrderByWithRelationInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    employee_id?: number
    uq_employee_code_per_tenant?: EmployeeUq_employee_code_per_tenantCompoundUniqueInput
    uq_employee_email_per_tenant?: EmployeeUq_employee_email_per_tenantCompoundUniqueInput
    uq_employee_phone_per_tenant?: EmployeeUq_employee_phone_per_tenantCompoundUniqueInput
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    tenant_id?: StringFilter<"Employee"> | string
    role_id?: IntFilter<"Employee"> | number
    name?: StringFilter<"Employee"> | string
    employee_code?: StringFilter<"Employee"> | string
    email?: StringFilter<"Employee"> | string
    password?: StringFilter<"Employee"> | string
    team_id?: IntNullableFilter<"Employee"> | number | null
    phone?: StringFilter<"Employee"> | string
    alternate_phone?: StringNullableFilter<"Employee"> | string | null
    special_needs?: StringNullableFilter<"Employee"> | string | null
    special_needs_start_date?: DateTimeNullableFilter<"Employee"> | Date | string | null
    special_needs_end_date?: DateTimeNullableFilter<"Employee"> | Date | string | null
    address?: StringNullableFilter<"Employee"> | string | null
    latitude?: DecimalNullableFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    gender?: EnumGenderEnumNullableFilter<"Employee"> | $Enums.GenderEnum | null
    is_active?: BoolFilter<"Employee"> | boolean
    created_at?: DateTimeFilter<"Employee"> | Date | string
    updated_at?: DateTimeFilter<"Employee"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    bookings?: BookingListRelationFilter
    weekoff_config?: XOR<WeekoffConfigNullableScalarRelationFilter, WeekoffConfigWhereInput> | null
  }, "employee_id" | "uq_employee_code_per_tenant" | "uq_employee_email_per_tenant" | "uq_employee_phone_per_tenant">

  export type EmployeeOrderByWithAggregationInput = {
    employee_id?: SortOrder
    tenant_id?: SortOrder
    role_id?: SortOrder
    name?: SortOrder
    employee_code?: SortOrder
    email?: SortOrder
    password?: SortOrder
    team_id?: SortOrderInput | SortOrder
    phone?: SortOrder
    alternate_phone?: SortOrderInput | SortOrder
    special_needs?: SortOrderInput | SortOrder
    special_needs_start_date?: SortOrderInput | SortOrder
    special_needs_end_date?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _avg?: EmployeeAvgOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
    _sum?: EmployeeSumOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    employee_id?: IntWithAggregatesFilter<"Employee"> | number
    tenant_id?: StringWithAggregatesFilter<"Employee"> | string
    role_id?: IntWithAggregatesFilter<"Employee"> | number
    name?: StringWithAggregatesFilter<"Employee"> | string
    employee_code?: StringWithAggregatesFilter<"Employee"> | string
    email?: StringWithAggregatesFilter<"Employee"> | string
    password?: StringWithAggregatesFilter<"Employee"> | string
    team_id?: IntNullableWithAggregatesFilter<"Employee"> | number | null
    phone?: StringWithAggregatesFilter<"Employee"> | string
    alternate_phone?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    special_needs?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    special_needs_start_date?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    special_needs_end_date?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    address?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    latitude?: DecimalNullableWithAggregatesFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableWithAggregatesFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    gender?: EnumGenderEnumNullableWithAggregatesFilter<"Employee"> | $Enums.GenderEnum | null
    is_active?: BoolWithAggregatesFilter<"Employee"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
  }

  export type ShiftWhereInput = {
    AND?: ShiftWhereInput | ShiftWhereInput[]
    OR?: ShiftWhereInput[]
    NOT?: ShiftWhereInput | ShiftWhereInput[]
    shift_id?: IntFilter<"Shift"> | number
    tenant_id?: StringFilter<"Shift"> | string
    shift_code?: StringFilter<"Shift"> | string
    log_type?: EnumShiftLogTypeEnumFilter<"Shift"> | $Enums.ShiftLogTypeEnum
    shift_time?: DateTimeFilter<"Shift"> | Date | string
    pickup_type?: EnumPickupTypeEnumNullableFilter<"Shift"> | $Enums.PickupTypeEnum | null
    gender?: EnumGenderEnumNullableFilter<"Shift"> | $Enums.GenderEnum | null
    waiting_time_minutes?: IntFilter<"Shift"> | number
    is_active?: BoolFilter<"Shift"> | boolean
    created_at?: DateTimeFilter<"Shift"> | Date | string
    updated_at?: DateTimeFilter<"Shift"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    bookings?: BookingListRelationFilter
  }

  export type ShiftOrderByWithRelationInput = {
    shift_id?: SortOrder
    tenant_id?: SortOrder
    shift_code?: SortOrder
    log_type?: SortOrder
    shift_time?: SortOrder
    pickup_type?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    waiting_time_minutes?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    bookings?: BookingOrderByRelationAggregateInput
  }

  export type ShiftWhereUniqueInput = Prisma.AtLeast<{
    shift_id?: number
    uq_shift_code_per_tenant?: ShiftUq_shift_code_per_tenantCompoundUniqueInput
    AND?: ShiftWhereInput | ShiftWhereInput[]
    OR?: ShiftWhereInput[]
    NOT?: ShiftWhereInput | ShiftWhereInput[]
    tenant_id?: StringFilter<"Shift"> | string
    shift_code?: StringFilter<"Shift"> | string
    log_type?: EnumShiftLogTypeEnumFilter<"Shift"> | $Enums.ShiftLogTypeEnum
    shift_time?: DateTimeFilter<"Shift"> | Date | string
    pickup_type?: EnumPickupTypeEnumNullableFilter<"Shift"> | $Enums.PickupTypeEnum | null
    gender?: EnumGenderEnumNullableFilter<"Shift"> | $Enums.GenderEnum | null
    waiting_time_minutes?: IntFilter<"Shift"> | number
    is_active?: BoolFilter<"Shift"> | boolean
    created_at?: DateTimeFilter<"Shift"> | Date | string
    updated_at?: DateTimeFilter<"Shift"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    bookings?: BookingListRelationFilter
  }, "shift_id" | "uq_shift_code_per_tenant">

  export type ShiftOrderByWithAggregationInput = {
    shift_id?: SortOrder
    tenant_id?: SortOrder
    shift_code?: SortOrder
    log_type?: SortOrder
    shift_time?: SortOrder
    pickup_type?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    waiting_time_minutes?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ShiftCountOrderByAggregateInput
    _avg?: ShiftAvgOrderByAggregateInput
    _max?: ShiftMaxOrderByAggregateInput
    _min?: ShiftMinOrderByAggregateInput
    _sum?: ShiftSumOrderByAggregateInput
  }

  export type ShiftScalarWhereWithAggregatesInput = {
    AND?: ShiftScalarWhereWithAggregatesInput | ShiftScalarWhereWithAggregatesInput[]
    OR?: ShiftScalarWhereWithAggregatesInput[]
    NOT?: ShiftScalarWhereWithAggregatesInput | ShiftScalarWhereWithAggregatesInput[]
    shift_id?: IntWithAggregatesFilter<"Shift"> | number
    tenant_id?: StringWithAggregatesFilter<"Shift"> | string
    shift_code?: StringWithAggregatesFilter<"Shift"> | string
    log_type?: EnumShiftLogTypeEnumWithAggregatesFilter<"Shift"> | $Enums.ShiftLogTypeEnum
    shift_time?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    pickup_type?: EnumPickupTypeEnumNullableWithAggregatesFilter<"Shift"> | $Enums.PickupTypeEnum | null
    gender?: EnumGenderEnumNullableWithAggregatesFilter<"Shift"> | $Enums.GenderEnum | null
    waiting_time_minutes?: IntWithAggregatesFilter<"Shift"> | number
    is_active?: BoolWithAggregatesFilter<"Shift"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    team_id?: IntFilter<"Team"> | number
    tenant_id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    is_active?: BoolFilter<"Team"> | boolean
    created_at?: DateTimeFilter<"Team"> | Date | string
    updated_at?: DateTimeFilter<"Team"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    employees?: EmployeeListRelationFilter
    bookings?: BookingListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    team_id?: SortOrder
    tenant_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    employees?: EmployeeOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    team_id?: number
    uq_team_name_per_tenant?: TeamUq_team_name_per_tenantCompoundUniqueInput
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    tenant_id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    is_active?: BoolFilter<"Team"> | boolean
    created_at?: DateTimeFilter<"Team"> | Date | string
    updated_at?: DateTimeFilter<"Team"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    employees?: EmployeeListRelationFilter
    bookings?: BookingListRelationFilter
  }, "team_id" | "uq_team_name_per_tenant">

  export type TeamOrderByWithAggregationInput = {
    team_id?: SortOrder
    tenant_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _avg?: TeamAvgOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
    _sum?: TeamSumOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    team_id?: IntWithAggregatesFilter<"Team"> | number
    tenant_id?: StringWithAggregatesFilter<"Team"> | string
    name?: StringWithAggregatesFilter<"Team"> | string
    description?: StringNullableWithAggregatesFilter<"Team"> | string | null
    is_active?: BoolWithAggregatesFilter<"Team"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Team"> | Date | string
  }

  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    tenant_id?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    address?: StringNullableFilter<"Tenant"> | string | null
    longitude?: DecimalNullableFilter<"Tenant"> | Decimal | DecimalJsLike | number | string | null
    latitude?: DecimalNullableFilter<"Tenant"> | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolFilter<"Tenant"> | boolean
    created_at?: DateTimeFilter<"Tenant"> | Date | string
    updated_at?: DateTimeFilter<"Tenant"> | Date | string
    teams?: TeamListRelationFilter
    employees?: EmployeeListRelationFilter
    shifts?: ShiftListRelationFilter
    bookings?: BookingListRelationFilter
    policies?: PolicyListRelationFilter
    cutoff?: XOR<CutoffNullableScalarRelationFilter, CutoffWhereInput> | null
    vendors?: VendorListRelationFilter
    roles?: RoleListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    tenant_id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    teams?: TeamOrderByRelationAggregateInput
    employees?: EmployeeOrderByRelationAggregateInput
    shifts?: ShiftOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    policies?: PolicyOrderByRelationAggregateInput
    cutoff?: CutoffOrderByWithRelationInput
    vendors?: VendorOrderByRelationAggregateInput
    roles?: RoleOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    tenant_id?: string
    name?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    address?: StringNullableFilter<"Tenant"> | string | null
    longitude?: DecimalNullableFilter<"Tenant"> | Decimal | DecimalJsLike | number | string | null
    latitude?: DecimalNullableFilter<"Tenant"> | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolFilter<"Tenant"> | boolean
    created_at?: DateTimeFilter<"Tenant"> | Date | string
    updated_at?: DateTimeFilter<"Tenant"> | Date | string
    teams?: TeamListRelationFilter
    employees?: EmployeeListRelationFilter
    shifts?: ShiftListRelationFilter
    bookings?: BookingListRelationFilter
    policies?: PolicyListRelationFilter
    cutoff?: XOR<CutoffNullableScalarRelationFilter, CutoffWhereInput> | null
    vendors?: VendorListRelationFilter
    roles?: RoleListRelationFilter
  }, "tenant_id" | "name">

  export type TenantOrderByWithAggregationInput = {
    tenant_id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _avg?: TenantAvgOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
    _sum?: TenantSumOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    tenant_id?: StringWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    address?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    longitude?: DecimalNullableWithAggregatesFilter<"Tenant"> | Decimal | DecimalJsLike | number | string | null
    latitude?: DecimalNullableWithAggregatesFilter<"Tenant"> | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolWithAggregatesFilter<"Tenant"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
  }

  export type WeekoffConfigWhereInput = {
    AND?: WeekoffConfigWhereInput | WeekoffConfigWhereInput[]
    OR?: WeekoffConfigWhereInput[]
    NOT?: WeekoffConfigWhereInput | WeekoffConfigWhereInput[]
    weekoff_id?: IntFilter<"WeekoffConfig"> | number
    employee_id?: IntFilter<"WeekoffConfig"> | number
    monday?: BoolFilter<"WeekoffConfig"> | boolean
    tuesday?: BoolFilter<"WeekoffConfig"> | boolean
    wednesday?: BoolFilter<"WeekoffConfig"> | boolean
    thursday?: BoolFilter<"WeekoffConfig"> | boolean
    friday?: BoolFilter<"WeekoffConfig"> | boolean
    saturday?: BoolFilter<"WeekoffConfig"> | boolean
    sunday?: BoolFilter<"WeekoffConfig"> | boolean
    created_at?: DateTimeFilter<"WeekoffConfig"> | Date | string
    updated_at?: DateTimeFilter<"WeekoffConfig"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type WeekoffConfigOrderByWithRelationInput = {
    weekoff_id?: SortOrder
    employee_id?: SortOrder
    monday?: SortOrder
    tuesday?: SortOrder
    wednesday?: SortOrder
    thursday?: SortOrder
    friday?: SortOrder
    saturday?: SortOrder
    sunday?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type WeekoffConfigWhereUniqueInput = Prisma.AtLeast<{
    weekoff_id?: number
    employee_id?: number
    AND?: WeekoffConfigWhereInput | WeekoffConfigWhereInput[]
    OR?: WeekoffConfigWhereInput[]
    NOT?: WeekoffConfigWhereInput | WeekoffConfigWhereInput[]
    monday?: BoolFilter<"WeekoffConfig"> | boolean
    tuesday?: BoolFilter<"WeekoffConfig"> | boolean
    wednesday?: BoolFilter<"WeekoffConfig"> | boolean
    thursday?: BoolFilter<"WeekoffConfig"> | boolean
    friday?: BoolFilter<"WeekoffConfig"> | boolean
    saturday?: BoolFilter<"WeekoffConfig"> | boolean
    sunday?: BoolFilter<"WeekoffConfig"> | boolean
    created_at?: DateTimeFilter<"WeekoffConfig"> | Date | string
    updated_at?: DateTimeFilter<"WeekoffConfig"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "weekoff_id" | "employee_id">

  export type WeekoffConfigOrderByWithAggregationInput = {
    weekoff_id?: SortOrder
    employee_id?: SortOrder
    monday?: SortOrder
    tuesday?: SortOrder
    wednesday?: SortOrder
    thursday?: SortOrder
    friday?: SortOrder
    saturday?: SortOrder
    sunday?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: WeekoffConfigCountOrderByAggregateInput
    _avg?: WeekoffConfigAvgOrderByAggregateInput
    _max?: WeekoffConfigMaxOrderByAggregateInput
    _min?: WeekoffConfigMinOrderByAggregateInput
    _sum?: WeekoffConfigSumOrderByAggregateInput
  }

  export type WeekoffConfigScalarWhereWithAggregatesInput = {
    AND?: WeekoffConfigScalarWhereWithAggregatesInput | WeekoffConfigScalarWhereWithAggregatesInput[]
    OR?: WeekoffConfigScalarWhereWithAggregatesInput[]
    NOT?: WeekoffConfigScalarWhereWithAggregatesInput | WeekoffConfigScalarWhereWithAggregatesInput[]
    weekoff_id?: IntWithAggregatesFilter<"WeekoffConfig"> | number
    employee_id?: IntWithAggregatesFilter<"WeekoffConfig"> | number
    monday?: BoolWithAggregatesFilter<"WeekoffConfig"> | boolean
    tuesday?: BoolWithAggregatesFilter<"WeekoffConfig"> | boolean
    wednesday?: BoolWithAggregatesFilter<"WeekoffConfig"> | boolean
    thursday?: BoolWithAggregatesFilter<"WeekoffConfig"> | boolean
    friday?: BoolWithAggregatesFilter<"WeekoffConfig"> | boolean
    saturday?: BoolWithAggregatesFilter<"WeekoffConfig"> | boolean
    sunday?: BoolWithAggregatesFilter<"WeekoffConfig"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"WeekoffConfig"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"WeekoffConfig"> | Date | string
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    admin_id?: IntFilter<"Admin"> | number
    name?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    phone?: StringFilter<"Admin"> | string
    password?: StringFilter<"Admin"> | string
    role_id?: IntFilter<"Admin"> | number
    is_active?: BoolFilter<"Admin"> | boolean
    created_at?: DateTimeFilter<"Admin"> | Date | string
    updated_at?: DateTimeFilter<"Admin"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }

  export type AdminOrderByWithRelationInput = {
    admin_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    role?: RoleOrderByWithRelationInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    admin_id?: number
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    name?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    phone?: StringFilter<"Admin"> | string
    password?: StringFilter<"Admin"> | string
    role_id?: IntFilter<"Admin"> | number
    is_active?: BoolFilter<"Admin"> | boolean
    created_at?: DateTimeFilter<"Admin"> | Date | string
    updated_at?: DateTimeFilter<"Admin"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }, "admin_id">

  export type AdminOrderByWithAggregationInput = {
    admin_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _avg?: AdminAvgOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
    _sum?: AdminSumOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    admin_id?: IntWithAggregatesFilter<"Admin"> | number
    name?: StringWithAggregatesFilter<"Admin"> | string
    email?: StringWithAggregatesFilter<"Admin"> | string
    phone?: StringWithAggregatesFilter<"Admin"> | string
    password?: StringWithAggregatesFilter<"Admin"> | string
    role_id?: IntWithAggregatesFilter<"Admin"> | number
    is_active?: BoolWithAggregatesFilter<"Admin"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    permission_id?: IntFilter<"Permission"> | number
    module?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    is_active?: BoolFilter<"Permission"> | boolean
    created_at?: DateTimeFilter<"Permission"> | Date | string
    updated_at?: DateTimeFilter<"Permission"> | Date | string
    policy_permissions?: PolicyPermissionListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    permission_id?: SortOrder
    module?: SortOrder
    action?: SortOrder
    description?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    policy_permissions?: PolicyPermissionOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    permission_id?: number
    uq_permission_module_action?: PermissionUq_permission_module_actionCompoundUniqueInput
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    module?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    is_active?: BoolFilter<"Permission"> | boolean
    created_at?: DateTimeFilter<"Permission"> | Date | string
    updated_at?: DateTimeFilter<"Permission"> | Date | string
    policy_permissions?: PolicyPermissionListRelationFilter
  }, "permission_id" | "uq_permission_module_action">

  export type PermissionOrderByWithAggregationInput = {
    permission_id?: SortOrder
    module?: SortOrder
    action?: SortOrder
    description?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _avg?: PermissionAvgOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
    _sum?: PermissionSumOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    permission_id?: IntWithAggregatesFilter<"Permission"> | number
    module?: StringWithAggregatesFilter<"Permission"> | string
    action?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    is_active?: BoolWithAggregatesFilter<"Permission"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
  }

  export type PolicyWhereInput = {
    AND?: PolicyWhereInput | PolicyWhereInput[]
    OR?: PolicyWhereInput[]
    NOT?: PolicyWhereInput | PolicyWhereInput[]
    policy_id?: IntFilter<"Policy"> | number
    tenant_id?: StringNullableFilter<"Policy"> | string | null
    name?: StringFilter<"Policy"> | string
    description?: StringNullableFilter<"Policy"> | string | null
    is_active?: BoolFilter<"Policy"> | boolean
    is_system_policy?: BoolFilter<"Policy"> | boolean
    created_at?: DateTimeFilter<"Policy"> | Date | string
    updated_at?: DateTimeFilter<"Policy"> | Date | string
    tenant?: XOR<TenantNullableScalarRelationFilter, TenantWhereInput> | null
    policy_permissions?: PolicyPermissionListRelationFilter
    role_policies?: RolePolicyListRelationFilter
  }

  export type PolicyOrderByWithRelationInput = {
    policy_id?: SortOrder
    tenant_id?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_system_policy?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    policy_permissions?: PolicyPermissionOrderByRelationAggregateInput
    role_policies?: RolePolicyOrderByRelationAggregateInput
  }

  export type PolicyWhereUniqueInput = Prisma.AtLeast<{
    policy_id?: number
    uq_policy_tenant_name?: PolicyUq_policy_tenant_nameCompoundUniqueInput
    AND?: PolicyWhereInput | PolicyWhereInput[]
    OR?: PolicyWhereInput[]
    NOT?: PolicyWhereInput | PolicyWhereInput[]
    tenant_id?: StringNullableFilter<"Policy"> | string | null
    name?: StringFilter<"Policy"> | string
    description?: StringNullableFilter<"Policy"> | string | null
    is_active?: BoolFilter<"Policy"> | boolean
    is_system_policy?: BoolFilter<"Policy"> | boolean
    created_at?: DateTimeFilter<"Policy"> | Date | string
    updated_at?: DateTimeFilter<"Policy"> | Date | string
    tenant?: XOR<TenantNullableScalarRelationFilter, TenantWhereInput> | null
    policy_permissions?: PolicyPermissionListRelationFilter
    role_policies?: RolePolicyListRelationFilter
  }, "policy_id" | "uq_policy_tenant_name">

  export type PolicyOrderByWithAggregationInput = {
    policy_id?: SortOrder
    tenant_id?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_system_policy?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: PolicyCountOrderByAggregateInput
    _avg?: PolicyAvgOrderByAggregateInput
    _max?: PolicyMaxOrderByAggregateInput
    _min?: PolicyMinOrderByAggregateInput
    _sum?: PolicySumOrderByAggregateInput
  }

  export type PolicyScalarWhereWithAggregatesInput = {
    AND?: PolicyScalarWhereWithAggregatesInput | PolicyScalarWhereWithAggregatesInput[]
    OR?: PolicyScalarWhereWithAggregatesInput[]
    NOT?: PolicyScalarWhereWithAggregatesInput | PolicyScalarWhereWithAggregatesInput[]
    policy_id?: IntWithAggregatesFilter<"Policy"> | number
    tenant_id?: StringNullableWithAggregatesFilter<"Policy"> | string | null
    name?: StringWithAggregatesFilter<"Policy"> | string
    description?: StringNullableWithAggregatesFilter<"Policy"> | string | null
    is_active?: BoolWithAggregatesFilter<"Policy"> | boolean
    is_system_policy?: BoolWithAggregatesFilter<"Policy"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Policy"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Policy"> | Date | string
  }

  export type PolicyPermissionWhereInput = {
    AND?: PolicyPermissionWhereInput | PolicyPermissionWhereInput[]
    OR?: PolicyPermissionWhereInput[]
    NOT?: PolicyPermissionWhereInput | PolicyPermissionWhereInput[]
    policy_id?: IntFilter<"PolicyPermission"> | number
    permission_id?: IntFilter<"PolicyPermission"> | number
    policy?: XOR<PolicyScalarRelationFilter, PolicyWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }

  export type PolicyPermissionOrderByWithRelationInput = {
    policy_id?: SortOrder
    permission_id?: SortOrder
    policy?: PolicyOrderByWithRelationInput
    permission?: PermissionOrderByWithRelationInput
  }

  export type PolicyPermissionWhereUniqueInput = Prisma.AtLeast<{
    policy_id_permission_id?: PolicyPermissionPolicy_idPermission_idCompoundUniqueInput
    AND?: PolicyPermissionWhereInput | PolicyPermissionWhereInput[]
    OR?: PolicyPermissionWhereInput[]
    NOT?: PolicyPermissionWhereInput | PolicyPermissionWhereInput[]
    policy_id?: IntFilter<"PolicyPermission"> | number
    permission_id?: IntFilter<"PolicyPermission"> | number
    policy?: XOR<PolicyScalarRelationFilter, PolicyWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }, "policy_id_permission_id">

  export type PolicyPermissionOrderByWithAggregationInput = {
    policy_id?: SortOrder
    permission_id?: SortOrder
    _count?: PolicyPermissionCountOrderByAggregateInput
    _avg?: PolicyPermissionAvgOrderByAggregateInput
    _max?: PolicyPermissionMaxOrderByAggregateInput
    _min?: PolicyPermissionMinOrderByAggregateInput
    _sum?: PolicyPermissionSumOrderByAggregateInput
  }

  export type PolicyPermissionScalarWhereWithAggregatesInput = {
    AND?: PolicyPermissionScalarWhereWithAggregatesInput | PolicyPermissionScalarWhereWithAggregatesInput[]
    OR?: PolicyPermissionScalarWhereWithAggregatesInput[]
    NOT?: PolicyPermissionScalarWhereWithAggregatesInput | PolicyPermissionScalarWhereWithAggregatesInput[]
    policy_id?: IntWithAggregatesFilter<"PolicyPermission"> | number
    permission_id?: IntWithAggregatesFilter<"PolicyPermission"> | number
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    role_id?: IntFilter<"Role"> | number
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    is_active?: BoolFilter<"Role"> | boolean
    tenant_id?: StringNullableFilter<"Role"> | string | null
    is_system_role?: BoolFilter<"Role"> | boolean
    created_at?: DateTimeFilter<"Role"> | Date | string
    updated_at?: DateTimeFilter<"Role"> | Date | string
    tenant?: XOR<TenantNullableScalarRelationFilter, TenantWhereInput> | null
    role_policies?: RolePolicyListRelationFilter
    admins?: AdminListRelationFilter
    vendor_users?: VendorUserListRelationFilter
    employees?: EmployeeListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    role_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    is_active?: SortOrder
    tenant_id?: SortOrderInput | SortOrder
    is_system_role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    role_policies?: RolePolicyOrderByRelationAggregateInput
    admins?: AdminOrderByRelationAggregateInput
    vendor_users?: VendorUserOrderByRelationAggregateInput
    employees?: EmployeeOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    role_id?: number
    uq_role_tenant_name?: RoleUq_role_tenant_nameCompoundUniqueInput
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    is_active?: BoolFilter<"Role"> | boolean
    tenant_id?: StringNullableFilter<"Role"> | string | null
    is_system_role?: BoolFilter<"Role"> | boolean
    created_at?: DateTimeFilter<"Role"> | Date | string
    updated_at?: DateTimeFilter<"Role"> | Date | string
    tenant?: XOR<TenantNullableScalarRelationFilter, TenantWhereInput> | null
    role_policies?: RolePolicyListRelationFilter
    admins?: AdminListRelationFilter
    vendor_users?: VendorUserListRelationFilter
    employees?: EmployeeListRelationFilter
  }, "role_id" | "uq_role_tenant_name">

  export type RoleOrderByWithAggregationInput = {
    role_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    is_active?: SortOrder
    tenant_id?: SortOrderInput | SortOrder
    is_system_role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    role_id?: IntWithAggregatesFilter<"Role"> | number
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    is_active?: BoolWithAggregatesFilter<"Role"> | boolean
    tenant_id?: StringNullableWithAggregatesFilter<"Role"> | string | null
    is_system_role?: BoolWithAggregatesFilter<"Role"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type RolePolicyWhereInput = {
    AND?: RolePolicyWhereInput | RolePolicyWhereInput[]
    OR?: RolePolicyWhereInput[]
    NOT?: RolePolicyWhereInput | RolePolicyWhereInput[]
    role_id?: IntFilter<"RolePolicy"> | number
    policy_id?: IntFilter<"RolePolicy"> | number
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    policy?: XOR<PolicyScalarRelationFilter, PolicyWhereInput>
  }

  export type RolePolicyOrderByWithRelationInput = {
    role_id?: SortOrder
    policy_id?: SortOrder
    role?: RoleOrderByWithRelationInput
    policy?: PolicyOrderByWithRelationInput
  }

  export type RolePolicyWhereUniqueInput = Prisma.AtLeast<{
    role_id_policy_id?: RolePolicyRole_idPolicy_idCompoundUniqueInput
    AND?: RolePolicyWhereInput | RolePolicyWhereInput[]
    OR?: RolePolicyWhereInput[]
    NOT?: RolePolicyWhereInput | RolePolicyWhereInput[]
    role_id?: IntFilter<"RolePolicy"> | number
    policy_id?: IntFilter<"RolePolicy"> | number
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    policy?: XOR<PolicyScalarRelationFilter, PolicyWhereInput>
  }, "role_id_policy_id">

  export type RolePolicyOrderByWithAggregationInput = {
    role_id?: SortOrder
    policy_id?: SortOrder
    _count?: RolePolicyCountOrderByAggregateInput
    _avg?: RolePolicyAvgOrderByAggregateInput
    _max?: RolePolicyMaxOrderByAggregateInput
    _min?: RolePolicyMinOrderByAggregateInput
    _sum?: RolePolicySumOrderByAggregateInput
  }

  export type RolePolicyScalarWhereWithAggregatesInput = {
    AND?: RolePolicyScalarWhereWithAggregatesInput | RolePolicyScalarWhereWithAggregatesInput[]
    OR?: RolePolicyScalarWhereWithAggregatesInput[]
    NOT?: RolePolicyScalarWhereWithAggregatesInput | RolePolicyScalarWhereWithAggregatesInput[]
    role_id?: IntWithAggregatesFilter<"RolePolicy"> | number
    policy_id?: IntWithAggregatesFilter<"RolePolicy"> | number
  }

  export type BookingCreateInput = {
    employee_code: string
    booking_date: Date | string
    pickup_latitude?: number | null
    pickup_longitude?: number | null
    pickup_location?: string | null
    drop_latitude?: number | null
    drop_longitude?: number | null
    drop_location?: string | null
    status?: $Enums.BookingStatusEnum
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutBookingsInput
    employee: EmployeeCreateNestedOneWithoutBookingsInput
    shift?: ShiftCreateNestedOneWithoutBookingsInput
    team?: TeamCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateInput = {
    booking_id?: number
    tenant_id: string
    employee_id: number
    employee_code: string
    shift_id?: number | null
    team_id?: number | null
    booking_date: Date | string
    pickup_latitude?: number | null
    pickup_longitude?: number | null
    pickup_location?: string | null
    drop_latitude?: number | null
    drop_longitude?: number | null
    drop_location?: string | null
    status?: $Enums.BookingStatusEnum
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingUpdateInput = {
    employee_code?: StringFieldUpdateOperationsInput | string
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pickup_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    drop_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusEnumFieldUpdateOperationsInput | $Enums.BookingStatusEnum
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBookingsNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutBookingsNestedInput
    shift?: ShiftUpdateOneWithoutBookingsNestedInput
    team?: TeamUpdateOneWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    booking_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    employee_id?: IntFieldUpdateOperationsInput | number
    employee_code?: StringFieldUpdateOperationsInput | string
    shift_id?: NullableIntFieldUpdateOperationsInput | number | null
    team_id?: NullableIntFieldUpdateOperationsInput | number | null
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pickup_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    drop_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusEnumFieldUpdateOperationsInput | $Enums.BookingStatusEnum
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyInput = {
    booking_id?: number
    tenant_id: string
    employee_id: number
    employee_code: string
    shift_id?: number | null
    team_id?: number | null
    booking_date: Date | string
    pickup_latitude?: number | null
    pickup_longitude?: number | null
    pickup_location?: string | null
    drop_latitude?: number | null
    drop_longitude?: number | null
    drop_location?: string | null
    status?: $Enums.BookingStatusEnum
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingUpdateManyMutationInput = {
    employee_code?: StringFieldUpdateOperationsInput | string
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pickup_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    drop_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusEnumFieldUpdateOperationsInput | $Enums.BookingStatusEnum
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyInput = {
    booking_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    employee_id?: IntFieldUpdateOperationsInput | number
    employee_code?: StringFieldUpdateOperationsInput | string
    shift_id?: NullableIntFieldUpdateOperationsInput | number | null
    team_id?: NullableIntFieldUpdateOperationsInput | number | null
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pickup_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    drop_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusEnumFieldUpdateOperationsInput | $Enums.BookingStatusEnum
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RouteUncheckedCreateInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RouteUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteCreateManyInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RouteUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteManagementBookingCreateInput = {
    booking_id: number
    stop_order: number
    estimated_pickup_time?: string | null
    estimated_drop_time?: string | null
    distance_from_previous?: number | null
    cumulative_distance?: number | null
    created_at?: Date | string
    route_management: RouteManagementCreateNestedOneWithoutRoute_management_bookingsInput
  }

  export type RouteManagementBookingUncheckedCreateInput = {
    id?: number
    route_id: string
    booking_id: number
    stop_order: number
    estimated_pickup_time?: string | null
    estimated_drop_time?: string | null
    distance_from_previous?: number | null
    cumulative_distance?: number | null
    created_at?: Date | string
  }

  export type RouteManagementBookingUpdateInput = {
    booking_id?: IntFieldUpdateOperationsInput | number
    stop_order?: IntFieldUpdateOperationsInput | number
    estimated_pickup_time?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_drop_time?: NullableStringFieldUpdateOperationsInput | string | null
    distance_from_previous?: NullableFloatFieldUpdateOperationsInput | number | null
    cumulative_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    route_management?: RouteManagementUpdateOneRequiredWithoutRoute_management_bookingsNestedInput
  }

  export type RouteManagementBookingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    route_id?: StringFieldUpdateOperationsInput | string
    booking_id?: IntFieldUpdateOperationsInput | number
    stop_order?: IntFieldUpdateOperationsInput | number
    estimated_pickup_time?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_drop_time?: NullableStringFieldUpdateOperationsInput | string | null
    distance_from_previous?: NullableFloatFieldUpdateOperationsInput | number | null
    cumulative_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteManagementBookingCreateManyInput = {
    id?: number
    route_id: string
    booking_id: number
    stop_order: number
    estimated_pickup_time?: string | null
    estimated_drop_time?: string | null
    distance_from_previous?: number | null
    cumulative_distance?: number | null
    created_at?: Date | string
  }

  export type RouteManagementBookingUpdateManyMutationInput = {
    booking_id?: IntFieldUpdateOperationsInput | number
    stop_order?: IntFieldUpdateOperationsInput | number
    estimated_pickup_time?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_drop_time?: NullableStringFieldUpdateOperationsInput | string | null
    distance_from_previous?: NullableFloatFieldUpdateOperationsInput | number | null
    cumulative_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteManagementBookingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    route_id?: StringFieldUpdateOperationsInput | string
    booking_id?: IntFieldUpdateOperationsInput | number
    stop_order?: IntFieldUpdateOperationsInput | number
    estimated_pickup_time?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_drop_time?: NullableStringFieldUpdateOperationsInput | string | null
    distance_from_previous?: NullableFloatFieldUpdateOperationsInput | number | null
    cumulative_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteManagementCreateInput = {
    route_id: string
    tenant_id: string
    shift_id?: number | null
    route_code: string
    status?: $Enums.RouteManagementStatusEnum
    planned_distance_km?: number | null
    planned_duration_minutes?: number | null
    actual_distance_km?: number | null
    actual_duration_minutes?: number | null
    actual_start_time?: Date | string | null
    actual_end_time?: Date | string | null
    optimized_polyline?: string | null
    assigned_vendor_id?: number | null
    assigned_vehicle_id?: number | null
    assigned_driver_id?: number | null
    total_distance_km?: number | null
    total_time_minutes?: number | null
    is_active?: boolean
    version?: number
    created_at?: Date | string
    updated_at?: Date | string
    route_management_bookings?: RouteManagementBookingCreateNestedManyWithoutRoute_managementInput
  }

  export type RouteManagementUncheckedCreateInput = {
    route_id: string
    tenant_id: string
    shift_id?: number | null
    route_code: string
    status?: $Enums.RouteManagementStatusEnum
    planned_distance_km?: number | null
    planned_duration_minutes?: number | null
    actual_distance_km?: number | null
    actual_duration_minutes?: number | null
    actual_start_time?: Date | string | null
    actual_end_time?: Date | string | null
    optimized_polyline?: string | null
    assigned_vendor_id?: number | null
    assigned_vehicle_id?: number | null
    assigned_driver_id?: number | null
    total_distance_km?: number | null
    total_time_minutes?: number | null
    is_active?: boolean
    version?: number
    created_at?: Date | string
    updated_at?: Date | string
    route_management_bookings?: RouteManagementBookingUncheckedCreateNestedManyWithoutRoute_managementInput
  }

  export type RouteManagementUpdateInput = {
    route_id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    shift_id?: NullableIntFieldUpdateOperationsInput | number | null
    route_code?: StringFieldUpdateOperationsInput | string
    status?: EnumRouteManagementStatusEnumFieldUpdateOperationsInput | $Enums.RouteManagementStatusEnum
    planned_distance_km?: NullableFloatFieldUpdateOperationsInput | number | null
    planned_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    actual_distance_km?: NullableFloatFieldUpdateOperationsInput | number | null
    actual_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    actual_start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    optimized_polyline?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_vendor_id?: NullableIntFieldUpdateOperationsInput | number | null
    assigned_vehicle_id?: NullableIntFieldUpdateOperationsInput | number | null
    assigned_driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    total_distance_km?: NullableFloatFieldUpdateOperationsInput | number | null
    total_time_minutes?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    route_management_bookings?: RouteManagementBookingUpdateManyWithoutRoute_managementNestedInput
  }

  export type RouteManagementUncheckedUpdateInput = {
    route_id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    shift_id?: NullableIntFieldUpdateOperationsInput | number | null
    route_code?: StringFieldUpdateOperationsInput | string
    status?: EnumRouteManagementStatusEnumFieldUpdateOperationsInput | $Enums.RouteManagementStatusEnum
    planned_distance_km?: NullableFloatFieldUpdateOperationsInput | number | null
    planned_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    actual_distance_km?: NullableFloatFieldUpdateOperationsInput | number | null
    actual_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    actual_start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    optimized_polyline?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_vendor_id?: NullableIntFieldUpdateOperationsInput | number | null
    assigned_vehicle_id?: NullableIntFieldUpdateOperationsInput | number | null
    assigned_driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    total_distance_km?: NullableFloatFieldUpdateOperationsInput | number | null
    total_time_minutes?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    route_management_bookings?: RouteManagementBookingUncheckedUpdateManyWithoutRoute_managementNestedInput
  }

  export type RouteManagementCreateManyInput = {
    route_id: string
    tenant_id: string
    shift_id?: number | null
    route_code: string
    status?: $Enums.RouteManagementStatusEnum
    planned_distance_km?: number | null
    planned_duration_minutes?: number | null
    actual_distance_km?: number | null
    actual_duration_minutes?: number | null
    actual_start_time?: Date | string | null
    actual_end_time?: Date | string | null
    optimized_polyline?: string | null
    assigned_vendor_id?: number | null
    assigned_vehicle_id?: number | null
    assigned_driver_id?: number | null
    total_distance_km?: number | null
    total_time_minutes?: number | null
    is_active?: boolean
    version?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RouteManagementUpdateManyMutationInput = {
    route_id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    shift_id?: NullableIntFieldUpdateOperationsInput | number | null
    route_code?: StringFieldUpdateOperationsInput | string
    status?: EnumRouteManagementStatusEnumFieldUpdateOperationsInput | $Enums.RouteManagementStatusEnum
    planned_distance_km?: NullableFloatFieldUpdateOperationsInput | number | null
    planned_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    actual_distance_km?: NullableFloatFieldUpdateOperationsInput | number | null
    actual_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    actual_start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    optimized_polyline?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_vendor_id?: NullableIntFieldUpdateOperationsInput | number | null
    assigned_vehicle_id?: NullableIntFieldUpdateOperationsInput | number | null
    assigned_driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    total_distance_km?: NullableFloatFieldUpdateOperationsInput | number | null
    total_time_minutes?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteManagementUncheckedUpdateManyInput = {
    route_id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    shift_id?: NullableIntFieldUpdateOperationsInput | number | null
    route_code?: StringFieldUpdateOperationsInput | string
    status?: EnumRouteManagementStatusEnumFieldUpdateOperationsInput | $Enums.RouteManagementStatusEnum
    planned_distance_km?: NullableFloatFieldUpdateOperationsInput | number | null
    planned_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    actual_distance_km?: NullableFloatFieldUpdateOperationsInput | number | null
    actual_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    actual_start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    optimized_polyline?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_vendor_id?: NullableIntFieldUpdateOperationsInput | number | null
    assigned_vehicle_id?: NullableIntFieldUpdateOperationsInput | number | null
    assigned_driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    total_distance_km?: NullableFloatFieldUpdateOperationsInput | number | null
    total_time_minutes?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverCreateInput = {
    name: string
    code: string
    email: string
    phone: string
    gender?: $Enums.GenderEnum | null
    password: string
    date_of_birth?: Date | string | null
    date_of_joining?: Date | string | null
    permanent_address?: string | null
    current_address?: string | null
    photo_url?: string | null
    bg_verify_status?: $Enums.VerificationStatusEnum | null
    bg_expiry_date?: Date | string | null
    bg_verify_url?: string | null
    police_verify_status?: $Enums.VerificationStatusEnum | null
    police_expiry_date?: Date | string | null
    police_verify_url?: string | null
    medical_verify_status?: $Enums.VerificationStatusEnum | null
    medical_expiry_date?: Date | string | null
    medical_verify_url?: string | null
    training_verify_status?: $Enums.VerificationStatusEnum | null
    training_expiry_date?: Date | string | null
    training_verify_url?: string | null
    eye_verify_status?: $Enums.VerificationStatusEnum | null
    eye_expiry_date?: Date | string | null
    eye_verify_url?: string | null
    license_number?: string | null
    license_expiry_date?: Date | string | null
    license_url?: string | null
    badge_number?: string | null
    badge_expiry_date?: Date | string | null
    badge_url?: string | null
    alt_govt_id_number?: string | null
    alt_govt_id_type?: string | null
    alt_govt_id_url?: string | null
    induction_date?: Date | string | null
    induction_url?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    vendor: VendorCreateNestedOneWithoutDriversInput
    vehicles?: VehicleCreateNestedManyWithoutDriverInput
  }

  export type DriverUncheckedCreateInput = {
    driver_id?: number
    vendor_id: number
    name: string
    code: string
    email: string
    phone: string
    gender?: $Enums.GenderEnum | null
    password: string
    date_of_birth?: Date | string | null
    date_of_joining?: Date | string | null
    permanent_address?: string | null
    current_address?: string | null
    photo_url?: string | null
    bg_verify_status?: $Enums.VerificationStatusEnum | null
    bg_expiry_date?: Date | string | null
    bg_verify_url?: string | null
    police_verify_status?: $Enums.VerificationStatusEnum | null
    police_expiry_date?: Date | string | null
    police_verify_url?: string | null
    medical_verify_status?: $Enums.VerificationStatusEnum | null
    medical_expiry_date?: Date | string | null
    medical_verify_url?: string | null
    training_verify_status?: $Enums.VerificationStatusEnum | null
    training_expiry_date?: Date | string | null
    training_verify_url?: string | null
    eye_verify_status?: $Enums.VerificationStatusEnum | null
    eye_expiry_date?: Date | string | null
    eye_verify_url?: string | null
    license_number?: string | null
    license_expiry_date?: Date | string | null
    license_url?: string | null
    badge_number?: string | null
    badge_expiry_date?: Date | string | null
    badge_url?: string | null
    alt_govt_id_number?: string | null
    alt_govt_id_type?: string | null
    alt_govt_id_url?: string | null
    induction_date?: Date | string | null
    induction_url?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    vehicles?: VehicleUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    password?: StringFieldUpdateOperationsInput | string
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_of_joining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permanent_address?: NullableStringFieldUpdateOperationsInput | string | null
    current_address?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    bg_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    bg_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bg_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    police_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    police_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    police_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    medical_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    medical_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medical_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    training_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    training_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    training_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    eye_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    eye_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eye_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    license_number?: NullableStringFieldUpdateOperationsInput | string | null
    license_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    license_url?: NullableStringFieldUpdateOperationsInput | string | null
    badge_number?: NullableStringFieldUpdateOperationsInput | string | null
    badge_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge_url?: NullableStringFieldUpdateOperationsInput | string | null
    alt_govt_id_number?: NullableStringFieldUpdateOperationsInput | string | null
    alt_govt_id_type?: NullableStringFieldUpdateOperationsInput | string | null
    alt_govt_id_url?: NullableStringFieldUpdateOperationsInput | string | null
    induction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    induction_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutDriversNestedInput
    vehicles?: VehicleUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateInput = {
    driver_id?: IntFieldUpdateOperationsInput | number
    vendor_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    password?: StringFieldUpdateOperationsInput | string
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_of_joining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permanent_address?: NullableStringFieldUpdateOperationsInput | string | null
    current_address?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    bg_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    bg_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bg_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    police_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    police_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    police_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    medical_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    medical_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medical_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    training_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    training_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    training_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    eye_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    eye_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eye_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    license_number?: NullableStringFieldUpdateOperationsInput | string | null
    license_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    license_url?: NullableStringFieldUpdateOperationsInput | string | null
    badge_number?: NullableStringFieldUpdateOperationsInput | string | null
    badge_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge_url?: NullableStringFieldUpdateOperationsInput | string | null
    alt_govt_id_number?: NullableStringFieldUpdateOperationsInput | string | null
    alt_govt_id_type?: NullableStringFieldUpdateOperationsInput | string | null
    alt_govt_id_url?: NullableStringFieldUpdateOperationsInput | string | null
    induction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    induction_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicles?: VehicleUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type DriverCreateManyInput = {
    driver_id?: number
    vendor_id: number
    name: string
    code: string
    email: string
    phone: string
    gender?: $Enums.GenderEnum | null
    password: string
    date_of_birth?: Date | string | null
    date_of_joining?: Date | string | null
    permanent_address?: string | null
    current_address?: string | null
    photo_url?: string | null
    bg_verify_status?: $Enums.VerificationStatusEnum | null
    bg_expiry_date?: Date | string | null
    bg_verify_url?: string | null
    police_verify_status?: $Enums.VerificationStatusEnum | null
    police_expiry_date?: Date | string | null
    police_verify_url?: string | null
    medical_verify_status?: $Enums.VerificationStatusEnum | null
    medical_expiry_date?: Date | string | null
    medical_verify_url?: string | null
    training_verify_status?: $Enums.VerificationStatusEnum | null
    training_expiry_date?: Date | string | null
    training_verify_url?: string | null
    eye_verify_status?: $Enums.VerificationStatusEnum | null
    eye_expiry_date?: Date | string | null
    eye_verify_url?: string | null
    license_number?: string | null
    license_expiry_date?: Date | string | null
    license_url?: string | null
    badge_number?: string | null
    badge_expiry_date?: Date | string | null
    badge_url?: string | null
    alt_govt_id_number?: string | null
    alt_govt_id_type?: string | null
    alt_govt_id_url?: string | null
    induction_date?: Date | string | null
    induction_url?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DriverUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    password?: StringFieldUpdateOperationsInput | string
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_of_joining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permanent_address?: NullableStringFieldUpdateOperationsInput | string | null
    current_address?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    bg_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    bg_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bg_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    police_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    police_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    police_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    medical_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    medical_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medical_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    training_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    training_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    training_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    eye_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    eye_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eye_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    license_number?: NullableStringFieldUpdateOperationsInput | string | null
    license_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    license_url?: NullableStringFieldUpdateOperationsInput | string | null
    badge_number?: NullableStringFieldUpdateOperationsInput | string | null
    badge_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge_url?: NullableStringFieldUpdateOperationsInput | string | null
    alt_govt_id_number?: NullableStringFieldUpdateOperationsInput | string | null
    alt_govt_id_type?: NullableStringFieldUpdateOperationsInput | string | null
    alt_govt_id_url?: NullableStringFieldUpdateOperationsInput | string | null
    induction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    induction_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverUncheckedUpdateManyInput = {
    driver_id?: IntFieldUpdateOperationsInput | number
    vendor_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    password?: StringFieldUpdateOperationsInput | string
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_of_joining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permanent_address?: NullableStringFieldUpdateOperationsInput | string | null
    current_address?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    bg_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    bg_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bg_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    police_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    police_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    police_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    medical_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    medical_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medical_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    training_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    training_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    training_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    eye_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    eye_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eye_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    license_number?: NullableStringFieldUpdateOperationsInput | string | null
    license_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    license_url?: NullableStringFieldUpdateOperationsInput | string | null
    badge_number?: NullableStringFieldUpdateOperationsInput | string | null
    badge_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge_url?: NullableStringFieldUpdateOperationsInput | string | null
    alt_govt_id_number?: NullableStringFieldUpdateOperationsInput | string | null
    alt_govt_id_type?: NullableStringFieldUpdateOperationsInput | string | null
    alt_govt_id_url?: NullableStringFieldUpdateOperationsInput | string | null
    induction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    induction_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleCreateInput = {
    rc_number: string
    rc_expiry_date?: Date | string | null
    description?: string | null
    puc_number?: string | null
    puc_expiry_date?: Date | string | null
    puc_url?: string | null
    fitness_number?: string | null
    fitness_expiry_date?: Date | string | null
    fitness_url?: string | null
    tax_receipt_number?: string | null
    tax_receipt_date?: Date | string | null
    tax_receipt_url?: string | null
    insurance_number?: string | null
    insurance_expiry_date?: Date | string | null
    insurance_url?: string | null
    permit_number?: string | null
    permit_expiry_date?: Date | string | null
    permit_url?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    vehicle_type: VehicleTypeCreateNestedOneWithoutVehiclesInput
    vendor: VendorCreateNestedOneWithoutVehiclesInput
    driver?: DriverCreateNestedOneWithoutVehiclesInput
  }

  export type VehicleUncheckedCreateInput = {
    vehicle_id?: number
    vehicle_type_id: number
    vendor_id: number
    driver_id?: number | null
    rc_number: string
    rc_expiry_date?: Date | string | null
    description?: string | null
    puc_number?: string | null
    puc_expiry_date?: Date | string | null
    puc_url?: string | null
    fitness_number?: string | null
    fitness_expiry_date?: Date | string | null
    fitness_url?: string | null
    tax_receipt_number?: string | null
    tax_receipt_date?: Date | string | null
    tax_receipt_url?: string | null
    insurance_number?: string | null
    insurance_expiry_date?: Date | string | null
    insurance_url?: string | null
    permit_number?: string | null
    permit_expiry_date?: Date | string | null
    permit_url?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VehicleUpdateInput = {
    rc_number?: StringFieldUpdateOperationsInput | string
    rc_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    puc_number?: NullableStringFieldUpdateOperationsInput | string | null
    puc_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    puc_url?: NullableStringFieldUpdateOperationsInput | string | null
    fitness_number?: NullableStringFieldUpdateOperationsInput | string | null
    fitness_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fitness_url?: NullableStringFieldUpdateOperationsInput | string | null
    tax_receipt_number?: NullableStringFieldUpdateOperationsInput | string | null
    tax_receipt_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tax_receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_number?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurance_url?: NullableStringFieldUpdateOperationsInput | string | null
    permit_number?: NullableStringFieldUpdateOperationsInput | string | null
    permit_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permit_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle_type?: VehicleTypeUpdateOneRequiredWithoutVehiclesNestedInput
    vendor?: VendorUpdateOneRequiredWithoutVehiclesNestedInput
    driver?: DriverUpdateOneWithoutVehiclesNestedInput
  }

  export type VehicleUncheckedUpdateInput = {
    vehicle_id?: IntFieldUpdateOperationsInput | number
    vehicle_type_id?: IntFieldUpdateOperationsInput | number
    vendor_id?: IntFieldUpdateOperationsInput | number
    driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    rc_number?: StringFieldUpdateOperationsInput | string
    rc_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    puc_number?: NullableStringFieldUpdateOperationsInput | string | null
    puc_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    puc_url?: NullableStringFieldUpdateOperationsInput | string | null
    fitness_number?: NullableStringFieldUpdateOperationsInput | string | null
    fitness_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fitness_url?: NullableStringFieldUpdateOperationsInput | string | null
    tax_receipt_number?: NullableStringFieldUpdateOperationsInput | string | null
    tax_receipt_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tax_receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_number?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurance_url?: NullableStringFieldUpdateOperationsInput | string | null
    permit_number?: NullableStringFieldUpdateOperationsInput | string | null
    permit_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permit_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleCreateManyInput = {
    vehicle_id?: number
    vehicle_type_id: number
    vendor_id: number
    driver_id?: number | null
    rc_number: string
    rc_expiry_date?: Date | string | null
    description?: string | null
    puc_number?: string | null
    puc_expiry_date?: Date | string | null
    puc_url?: string | null
    fitness_number?: string | null
    fitness_expiry_date?: Date | string | null
    fitness_url?: string | null
    tax_receipt_number?: string | null
    tax_receipt_date?: Date | string | null
    tax_receipt_url?: string | null
    insurance_number?: string | null
    insurance_expiry_date?: Date | string | null
    insurance_url?: string | null
    permit_number?: string | null
    permit_expiry_date?: Date | string | null
    permit_url?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VehicleUpdateManyMutationInput = {
    rc_number?: StringFieldUpdateOperationsInput | string
    rc_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    puc_number?: NullableStringFieldUpdateOperationsInput | string | null
    puc_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    puc_url?: NullableStringFieldUpdateOperationsInput | string | null
    fitness_number?: NullableStringFieldUpdateOperationsInput | string | null
    fitness_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fitness_url?: NullableStringFieldUpdateOperationsInput | string | null
    tax_receipt_number?: NullableStringFieldUpdateOperationsInput | string | null
    tax_receipt_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tax_receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_number?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurance_url?: NullableStringFieldUpdateOperationsInput | string | null
    permit_number?: NullableStringFieldUpdateOperationsInput | string | null
    permit_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permit_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleUncheckedUpdateManyInput = {
    vehicle_id?: IntFieldUpdateOperationsInput | number
    vehicle_type_id?: IntFieldUpdateOperationsInput | number
    vendor_id?: IntFieldUpdateOperationsInput | number
    driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    rc_number?: StringFieldUpdateOperationsInput | string
    rc_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    puc_number?: NullableStringFieldUpdateOperationsInput | string | null
    puc_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    puc_url?: NullableStringFieldUpdateOperationsInput | string | null
    fitness_number?: NullableStringFieldUpdateOperationsInput | string | null
    fitness_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fitness_url?: NullableStringFieldUpdateOperationsInput | string | null
    tax_receipt_number?: NullableStringFieldUpdateOperationsInput | string | null
    tax_receipt_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tax_receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_number?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurance_url?: NullableStringFieldUpdateOperationsInput | string | null
    permit_number?: NullableStringFieldUpdateOperationsInput | string | null
    permit_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permit_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleTypeCreateInput = {
    name: string
    description?: string | null
    seats: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    vendor: VendorCreateNestedOneWithoutVehicle_typesInput
    vehicles?: VehicleCreateNestedManyWithoutVehicle_typeInput
  }

  export type VehicleTypeUncheckedCreateInput = {
    vehicle_type_id?: number
    vendor_id: number
    name: string
    description?: string | null
    seats: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    vehicles?: VehicleUncheckedCreateNestedManyWithoutVehicle_typeInput
  }

  export type VehicleTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutVehicle_typesNestedInput
    vehicles?: VehicleUpdateManyWithoutVehicle_typeNestedInput
  }

  export type VehicleTypeUncheckedUpdateInput = {
    vehicle_type_id?: IntFieldUpdateOperationsInput | number
    vendor_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicles?: VehicleUncheckedUpdateManyWithoutVehicle_typeNestedInput
  }

  export type VehicleTypeCreateManyInput = {
    vehicle_type_id?: number
    vendor_id: number
    name: string
    description?: string | null
    seats: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VehicleTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleTypeUncheckedUpdateManyInput = {
    vehicle_type_id?: IntFieldUpdateOperationsInput | number
    vendor_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorCreateInput = {
    name: string
    vendor_code: string
    email?: string | null
    phone?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutVendorsInput
    drivers?: DriverCreateNestedManyWithoutVendorInput
    vehicle_types?: VehicleTypeCreateNestedManyWithoutVendorInput
    vehicles?: VehicleCreateNestedManyWithoutVendorInput
    vendor_users?: VendorUserCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateInput = {
    vendor_id?: number
    tenant_id: string
    name: string
    vendor_code: string
    email?: string | null
    phone?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    drivers?: DriverUncheckedCreateNestedManyWithoutVendorInput
    vehicle_types?: VehicleTypeUncheckedCreateNestedManyWithoutVendorInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutVendorInput
    vendor_users?: VendorUserUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    vendor_code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutVendorsNestedInput
    drivers?: DriverUpdateManyWithoutVendorNestedInput
    vehicle_types?: VehicleTypeUpdateManyWithoutVendorNestedInput
    vehicles?: VehicleUpdateManyWithoutVendorNestedInput
    vendor_users?: VendorUserUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateInput = {
    vendor_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vendor_code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    drivers?: DriverUncheckedUpdateManyWithoutVendorNestedInput
    vehicle_types?: VehicleTypeUncheckedUpdateManyWithoutVendorNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutVendorNestedInput
    vendor_users?: VendorUserUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorCreateManyInput = {
    vendor_id?: number
    tenant_id: string
    name: string
    vendor_code: string
    email?: string | null
    phone?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    vendor_code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUncheckedUpdateManyInput = {
    vendor_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vendor_code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUserCreateInput = {
    tenant_id: string
    name: string
    email: string
    phone: string
    password: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    vendor: VendorCreateNestedOneWithoutVendor_usersInput
    role: RoleCreateNestedOneWithoutVendor_usersInput
  }

  export type VendorUserUncheckedCreateInput = {
    vendor_user_id?: number
    tenant_id: string
    vendor_id: number
    name: string
    email: string
    phone: string
    password: string
    role_id: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorUserUpdateInput = {
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutVendor_usersNestedInput
    role?: RoleUpdateOneRequiredWithoutVendor_usersNestedInput
  }

  export type VendorUserUncheckedUpdateInput = {
    vendor_user_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    vendor_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUserCreateManyInput = {
    vendor_user_id?: number
    tenant_id: string
    vendor_id: number
    name: string
    email: string
    phone: string
    password: string
    role_id: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorUserUpdateManyMutationInput = {
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUserUncheckedUpdateManyInput = {
    vendor_user_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    vendor_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CutoffCreateInput = {
    booking_cutoff?: number
    cancel_cutoff?: number
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutCutoffInput
  }

  export type CutoffUncheckedCreateInput = {
    tenant_id: string
    booking_cutoff?: number
    cancel_cutoff?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CutoffUpdateInput = {
    booking_cutoff?: IntFieldUpdateOperationsInput | number
    cancel_cutoff?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCutoffNestedInput
  }

  export type CutoffUncheckedUpdateInput = {
    tenant_id?: StringFieldUpdateOperationsInput | string
    booking_cutoff?: IntFieldUpdateOperationsInput | number
    cancel_cutoff?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CutoffCreateManyInput = {
    tenant_id: string
    booking_cutoff?: number
    cancel_cutoff?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CutoffUpdateManyMutationInput = {
    booking_cutoff?: IntFieldUpdateOperationsInput | number
    cancel_cutoff?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CutoffUncheckedUpdateManyInput = {
    tenant_id?: StringFieldUpdateOperationsInput | string
    booking_cutoff?: IntFieldUpdateOperationsInput | number
    cancel_cutoff?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateInput = {
    name: string
    employee_code: string
    email: string
    password: string
    phone: string
    alternate_phone?: string | null
    special_needs?: string | null
    special_needs_start_date?: Date | string | null
    special_needs_end_date?: Date | string | null
    address?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    gender?: $Enums.GenderEnum | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutEmployeesInput
    team?: TeamCreateNestedOneWithoutEmployeesInput
    role: RoleCreateNestedOneWithoutEmployeesInput
    bookings?: BookingCreateNestedManyWithoutEmployeeInput
    weekoff_config?: WeekoffConfigCreateNestedOneWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    employee_id?: number
    tenant_id: string
    role_id: number
    name: string
    employee_code: string
    email: string
    password: string
    team_id?: number | null
    phone: string
    alternate_phone?: string | null
    special_needs?: string | null
    special_needs_start_date?: Date | string | null
    special_needs_end_date?: Date | string | null
    address?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    gender?: $Enums.GenderEnum | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutEmployeeInput
    weekoff_config?: WeekoffConfigUncheckedCreateNestedOneWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    alternate_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    special_needs_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEmployeesNestedInput
    team?: TeamUpdateOneWithoutEmployeesNestedInput
    role?: RoleUpdateOneRequiredWithoutEmployeesNestedInput
    bookings?: BookingUpdateManyWithoutEmployeeNestedInput
    weekoff_config?: WeekoffConfigUpdateOneWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    team_id?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: StringFieldUpdateOperationsInput | string
    alternate_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    special_needs_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutEmployeeNestedInput
    weekoff_config?: WeekoffConfigUncheckedUpdateOneWithoutEmployeeNestedInput
  }

  export type EmployeeCreateManyInput = {
    employee_id?: number
    tenant_id: string
    role_id: number
    name: string
    employee_code: string
    email: string
    password: string
    team_id?: number | null
    phone: string
    alternate_phone?: string | null
    special_needs?: string | null
    special_needs_start_date?: Date | string | null
    special_needs_end_date?: Date | string | null
    address?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    gender?: $Enums.GenderEnum | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type EmployeeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    alternate_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    special_needs_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    team_id?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: StringFieldUpdateOperationsInput | string
    alternate_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    special_needs_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftCreateInput = {
    shift_code: string
    log_type: $Enums.ShiftLogTypeEnum
    shift_time: Date | string
    pickup_type?: $Enums.PickupTypeEnum | null
    gender?: $Enums.GenderEnum | null
    waiting_time_minutes?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutShiftsInput
    bookings?: BookingCreateNestedManyWithoutShiftInput
  }

  export type ShiftUncheckedCreateInput = {
    shift_id?: number
    tenant_id: string
    shift_code: string
    log_type: $Enums.ShiftLogTypeEnum
    shift_time: Date | string
    pickup_type?: $Enums.PickupTypeEnum | null
    gender?: $Enums.GenderEnum | null
    waiting_time_minutes?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutShiftInput
  }

  export type ShiftUpdateInput = {
    shift_code?: StringFieldUpdateOperationsInput | string
    log_type?: EnumShiftLogTypeEnumFieldUpdateOperationsInput | $Enums.ShiftLogTypeEnum
    shift_time?: DateTimeFieldUpdateOperationsInput | Date | string
    pickup_type?: NullableEnumPickupTypeEnumFieldUpdateOperationsInput | $Enums.PickupTypeEnum | null
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    waiting_time_minutes?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutShiftsNestedInput
    bookings?: BookingUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateInput = {
    shift_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    shift_code?: StringFieldUpdateOperationsInput | string
    log_type?: EnumShiftLogTypeEnumFieldUpdateOperationsInput | $Enums.ShiftLogTypeEnum
    shift_time?: DateTimeFieldUpdateOperationsInput | Date | string
    pickup_type?: NullableEnumPickupTypeEnumFieldUpdateOperationsInput | $Enums.PickupTypeEnum | null
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    waiting_time_minutes?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type ShiftCreateManyInput = {
    shift_id?: number
    tenant_id: string
    shift_code: string
    log_type: $Enums.ShiftLogTypeEnum
    shift_time: Date | string
    pickup_type?: $Enums.PickupTypeEnum | null
    gender?: $Enums.GenderEnum | null
    waiting_time_minutes?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ShiftUpdateManyMutationInput = {
    shift_code?: StringFieldUpdateOperationsInput | string
    log_type?: EnumShiftLogTypeEnumFieldUpdateOperationsInput | $Enums.ShiftLogTypeEnum
    shift_time?: DateTimeFieldUpdateOperationsInput | Date | string
    pickup_type?: NullableEnumPickupTypeEnumFieldUpdateOperationsInput | $Enums.PickupTypeEnum | null
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    waiting_time_minutes?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftUncheckedUpdateManyInput = {
    shift_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    shift_code?: StringFieldUpdateOperationsInput | string
    log_type?: EnumShiftLogTypeEnumFieldUpdateOperationsInput | $Enums.ShiftLogTypeEnum
    shift_time?: DateTimeFieldUpdateOperationsInput | Date | string
    pickup_type?: NullableEnumPickupTypeEnumFieldUpdateOperationsInput | $Enums.PickupTypeEnum | null
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    waiting_time_minutes?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateInput = {
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutTeamsInput
    employees?: EmployeeCreateNestedManyWithoutTeamInput
    bookings?: BookingCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    team_id?: number
    tenant_id: string
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutTeamInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTeamsNestedInput
    employees?: EmployeeUpdateManyWithoutTeamNestedInput
    bookings?: BookingUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    team_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutTeamNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    team_id?: number
    tenant_id: string
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TeamUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyInput = {
    team_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateInput = {
    tenant_id: string
    name: string
    address?: string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    teams?: TeamCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    shifts?: ShiftCreateNestedManyWithoutTenantInput
    bookings?: BookingCreateNestedManyWithoutTenantInput
    policies?: PolicyCreateNestedManyWithoutTenantInput
    cutoff?: CutoffCreateNestedOneWithoutTenantInput
    vendors?: VendorCreateNestedManyWithoutTenantInput
    roles?: RoleCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    tenant_id: string
    name: string
    address?: string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutTenantInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTenantInput
    policies?: PolicyUncheckedCreateNestedManyWithoutTenantInput
    cutoff?: CutoffUncheckedCreateNestedOneWithoutTenantInput
    vendors?: VendorUncheckedCreateNestedManyWithoutTenantInput
    roles?: RoleUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    shifts?: ShiftUpdateManyWithoutTenantNestedInput
    bookings?: BookingUpdateManyWithoutTenantNestedInput
    policies?: PolicyUpdateManyWithoutTenantNestedInput
    cutoff?: CutoffUpdateOneWithoutTenantNestedInput
    vendors?: VendorUpdateManyWithoutTenantNestedInput
    roles?: RoleUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutTenantNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTenantNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutTenantNestedInput
    cutoff?: CutoffUncheckedUpdateOneWithoutTenantNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutTenantNestedInput
    roles?: RoleUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    tenant_id: string
    name: string
    address?: string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TenantUpdateManyMutationInput = {
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeekoffConfigCreateInput = {
    monday?: boolean
    tuesday?: boolean
    wednesday?: boolean
    thursday?: boolean
    friday?: boolean
    saturday?: boolean
    sunday?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    employee: EmployeeCreateNestedOneWithoutWeekoff_configInput
  }

  export type WeekoffConfigUncheckedCreateInput = {
    weekoff_id?: number
    employee_id: number
    monday?: boolean
    tuesday?: boolean
    wednesday?: boolean
    thursday?: boolean
    friday?: boolean
    saturday?: boolean
    sunday?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WeekoffConfigUpdateInput = {
    monday?: BoolFieldUpdateOperationsInput | boolean
    tuesday?: BoolFieldUpdateOperationsInput | boolean
    wednesday?: BoolFieldUpdateOperationsInput | boolean
    thursday?: BoolFieldUpdateOperationsInput | boolean
    friday?: BoolFieldUpdateOperationsInput | boolean
    saturday?: BoolFieldUpdateOperationsInput | boolean
    sunday?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutWeekoff_configNestedInput
  }

  export type WeekoffConfigUncheckedUpdateInput = {
    weekoff_id?: IntFieldUpdateOperationsInput | number
    employee_id?: IntFieldUpdateOperationsInput | number
    monday?: BoolFieldUpdateOperationsInput | boolean
    tuesday?: BoolFieldUpdateOperationsInput | boolean
    wednesday?: BoolFieldUpdateOperationsInput | boolean
    thursday?: BoolFieldUpdateOperationsInput | boolean
    friday?: BoolFieldUpdateOperationsInput | boolean
    saturday?: BoolFieldUpdateOperationsInput | boolean
    sunday?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeekoffConfigCreateManyInput = {
    weekoff_id?: number
    employee_id: number
    monday?: boolean
    tuesday?: boolean
    wednesday?: boolean
    thursday?: boolean
    friday?: boolean
    saturday?: boolean
    sunday?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WeekoffConfigUpdateManyMutationInput = {
    monday?: BoolFieldUpdateOperationsInput | boolean
    tuesday?: BoolFieldUpdateOperationsInput | boolean
    wednesday?: BoolFieldUpdateOperationsInput | boolean
    thursday?: BoolFieldUpdateOperationsInput | boolean
    friday?: BoolFieldUpdateOperationsInput | boolean
    saturday?: BoolFieldUpdateOperationsInput | boolean
    sunday?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeekoffConfigUncheckedUpdateManyInput = {
    weekoff_id?: IntFieldUpdateOperationsInput | number
    employee_id?: IntFieldUpdateOperationsInput | number
    monday?: BoolFieldUpdateOperationsInput | boolean
    tuesday?: BoolFieldUpdateOperationsInput | boolean
    wednesday?: BoolFieldUpdateOperationsInput | boolean
    thursday?: BoolFieldUpdateOperationsInput | boolean
    friday?: BoolFieldUpdateOperationsInput | boolean
    saturday?: BoolFieldUpdateOperationsInput | boolean
    sunday?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateInput = {
    name: string
    email: string
    phone: string
    password: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    role: RoleCreateNestedOneWithoutAdminsInput
  }

  export type AdminUncheckedCreateInput = {
    admin_id?: number
    name: string
    email: string
    phone: string
    password: string
    role_id: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AdminUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutAdminsNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    admin_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateManyInput = {
    admin_id?: number
    name: string
    email: string
    phone: string
    password: string
    role_id: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AdminUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateManyInput = {
    admin_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionCreateInput = {
    module: string
    action: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    policy_permissions?: PolicyPermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    permission_id?: number
    module: string
    action: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    policy_permissions?: PolicyPermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    policy_permissions?: PolicyPermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    permission_id?: IntFieldUpdateOperationsInput | number
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    policy_permissions?: PolicyPermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    permission_id?: number
    module: string
    action: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PermissionUpdateManyMutationInput = {
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    permission_id?: IntFieldUpdateOperationsInput | number
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyCreateInput = {
    name: string
    description?: string | null
    is_active?: boolean
    is_system_policy?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    tenant?: TenantCreateNestedOneWithoutPoliciesInput
    policy_permissions?: PolicyPermissionCreateNestedManyWithoutPolicyInput
    role_policies?: RolePolicyCreateNestedManyWithoutPolicyInput
  }

  export type PolicyUncheckedCreateInput = {
    policy_id?: number
    tenant_id?: string | null
    name: string
    description?: string | null
    is_active?: boolean
    is_system_policy?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    policy_permissions?: PolicyPermissionUncheckedCreateNestedManyWithoutPolicyInput
    role_policies?: RolePolicyUncheckedCreateNestedManyWithoutPolicyInput
  }

  export type PolicyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_system_policy?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutPoliciesNestedInput
    policy_permissions?: PolicyPermissionUpdateManyWithoutPolicyNestedInput
    role_policies?: RolePolicyUpdateManyWithoutPolicyNestedInput
  }

  export type PolicyUncheckedUpdateInput = {
    policy_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_system_policy?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    policy_permissions?: PolicyPermissionUncheckedUpdateManyWithoutPolicyNestedInput
    role_policies?: RolePolicyUncheckedUpdateManyWithoutPolicyNestedInput
  }

  export type PolicyCreateManyInput = {
    policy_id?: number
    tenant_id?: string | null
    name: string
    description?: string | null
    is_active?: boolean
    is_system_policy?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PolicyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_system_policy?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyUncheckedUpdateManyInput = {
    policy_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_system_policy?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyPermissionCreateInput = {
    policy: PolicyCreateNestedOneWithoutPolicy_permissionsInput
    permission: PermissionCreateNestedOneWithoutPolicy_permissionsInput
  }

  export type PolicyPermissionUncheckedCreateInput = {
    policy_id: number
    permission_id: number
  }

  export type PolicyPermissionUpdateInput = {
    policy?: PolicyUpdateOneRequiredWithoutPolicy_permissionsNestedInput
    permission?: PermissionUpdateOneRequiredWithoutPolicy_permissionsNestedInput
  }

  export type PolicyPermissionUncheckedUpdateInput = {
    policy_id?: IntFieldUpdateOperationsInput | number
    permission_id?: IntFieldUpdateOperationsInput | number
  }

  export type PolicyPermissionCreateManyInput = {
    policy_id: number
    permission_id: number
  }

  export type PolicyPermissionUpdateManyMutationInput = {

  }

  export type PolicyPermissionUncheckedUpdateManyInput = {
    policy_id?: IntFieldUpdateOperationsInput | number
    permission_id?: IntFieldUpdateOperationsInput | number
  }

  export type RoleCreateInput = {
    name: string
    description?: string | null
    is_active?: boolean
    is_system_role?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    tenant?: TenantCreateNestedOneWithoutRolesInput
    role_policies?: RolePolicyCreateNestedManyWithoutRoleInput
    admins?: AdminCreateNestedManyWithoutRoleInput
    vendor_users?: VendorUserCreateNestedManyWithoutRoleInput
    employees?: EmployeeCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    role_id?: number
    name: string
    description?: string | null
    is_active?: boolean
    tenant_id?: string | null
    is_system_role?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    role_policies?: RolePolicyUncheckedCreateNestedManyWithoutRoleInput
    admins?: AdminUncheckedCreateNestedManyWithoutRoleInput
    vendor_users?: VendorUserUncheckedCreateNestedManyWithoutRoleInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_system_role?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutRolesNestedInput
    role_policies?: RolePolicyUpdateManyWithoutRoleNestedInput
    admins?: AdminUpdateManyWithoutRoleNestedInput
    vendor_users?: VendorUserUpdateManyWithoutRoleNestedInput
    employees?: EmployeeUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    tenant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_system_role?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role_policies?: RolePolicyUncheckedUpdateManyWithoutRoleNestedInput
    admins?: AdminUncheckedUpdateManyWithoutRoleNestedInput
    vendor_users?: VendorUserUncheckedUpdateManyWithoutRoleNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    role_id?: number
    name: string
    description?: string | null
    is_active?: boolean
    tenant_id?: string | null
    is_system_role?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_system_role?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    tenant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_system_role?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePolicyCreateInput = {
    role: RoleCreateNestedOneWithoutRole_policiesInput
    policy: PolicyCreateNestedOneWithoutRole_policiesInput
  }

  export type RolePolicyUncheckedCreateInput = {
    role_id: number
    policy_id: number
  }

  export type RolePolicyUpdateInput = {
    role?: RoleUpdateOneRequiredWithoutRole_policiesNestedInput
    policy?: PolicyUpdateOneRequiredWithoutRole_policiesNestedInput
  }

  export type RolePolicyUncheckedUpdateInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    policy_id?: IntFieldUpdateOperationsInput | number
  }

  export type RolePolicyCreateManyInput = {
    role_id: number
    policy_id: number
  }

  export type RolePolicyUpdateManyMutationInput = {

  }

  export type RolePolicyUncheckedUpdateManyInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    policy_id?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumBookingStatusEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatusEnum | EnumBookingStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatusEnum[] | ListEnumBookingStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatusEnum[] | ListEnumBookingStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusEnumFilter<$PrismaModel> | $Enums.BookingStatusEnum
  }

  export type TenantScalarRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type EmployeeScalarRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type ShiftNullableScalarRelationFilter = {
    is?: ShiftWhereInput | null
    isNot?: ShiftWhereInput | null
  }

  export type TeamNullableScalarRelationFilter = {
    is?: TeamWhereInput | null
    isNot?: TeamWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BookingCountOrderByAggregateInput = {
    booking_id?: SortOrder
    tenant_id?: SortOrder
    employee_id?: SortOrder
    employee_code?: SortOrder
    shift_id?: SortOrder
    team_id?: SortOrder
    booking_date?: SortOrder
    pickup_latitude?: SortOrder
    pickup_longitude?: SortOrder
    pickup_location?: SortOrder
    drop_latitude?: SortOrder
    drop_longitude?: SortOrder
    drop_location?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    booking_id?: SortOrder
    employee_id?: SortOrder
    shift_id?: SortOrder
    team_id?: SortOrder
    pickup_latitude?: SortOrder
    pickup_longitude?: SortOrder
    drop_latitude?: SortOrder
    drop_longitude?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    booking_id?: SortOrder
    tenant_id?: SortOrder
    employee_id?: SortOrder
    employee_code?: SortOrder
    shift_id?: SortOrder
    team_id?: SortOrder
    booking_date?: SortOrder
    pickup_latitude?: SortOrder
    pickup_longitude?: SortOrder
    pickup_location?: SortOrder
    drop_latitude?: SortOrder
    drop_longitude?: SortOrder
    drop_location?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    booking_id?: SortOrder
    tenant_id?: SortOrder
    employee_id?: SortOrder
    employee_code?: SortOrder
    shift_id?: SortOrder
    team_id?: SortOrder
    booking_date?: SortOrder
    pickup_latitude?: SortOrder
    pickup_longitude?: SortOrder
    pickup_location?: SortOrder
    drop_latitude?: SortOrder
    drop_longitude?: SortOrder
    drop_location?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    booking_id?: SortOrder
    employee_id?: SortOrder
    shift_id?: SortOrder
    team_id?: SortOrder
    pickup_latitude?: SortOrder
    pickup_longitude?: SortOrder
    drop_latitude?: SortOrder
    drop_longitude?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumBookingStatusEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatusEnum | EnumBookingStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatusEnum[] | ListEnumBookingStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatusEnum[] | ListEnumBookingStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusEnumWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatusEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusEnumFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusEnumFilter<$PrismaModel>
  }

  export type RouteCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RouteAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RouteMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RouteMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RouteSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RouteManagementScalarRelationFilter = {
    is?: RouteManagementWhereInput
    isNot?: RouteManagementWhereInput
  }

  export type RouteManagementBookingUq_route_management_booking_uniqueCompoundUniqueInput = {
    route_id: string
    booking_id: number
  }

  export type RouteManagementBookingCountOrderByAggregateInput = {
    id?: SortOrder
    route_id?: SortOrder
    booking_id?: SortOrder
    stop_order?: SortOrder
    estimated_pickup_time?: SortOrder
    estimated_drop_time?: SortOrder
    distance_from_previous?: SortOrder
    cumulative_distance?: SortOrder
    created_at?: SortOrder
  }

  export type RouteManagementBookingAvgOrderByAggregateInput = {
    id?: SortOrder
    booking_id?: SortOrder
    stop_order?: SortOrder
    distance_from_previous?: SortOrder
    cumulative_distance?: SortOrder
  }

  export type RouteManagementBookingMaxOrderByAggregateInput = {
    id?: SortOrder
    route_id?: SortOrder
    booking_id?: SortOrder
    stop_order?: SortOrder
    estimated_pickup_time?: SortOrder
    estimated_drop_time?: SortOrder
    distance_from_previous?: SortOrder
    cumulative_distance?: SortOrder
    created_at?: SortOrder
  }

  export type RouteManagementBookingMinOrderByAggregateInput = {
    id?: SortOrder
    route_id?: SortOrder
    booking_id?: SortOrder
    stop_order?: SortOrder
    estimated_pickup_time?: SortOrder
    estimated_drop_time?: SortOrder
    distance_from_previous?: SortOrder
    cumulative_distance?: SortOrder
    created_at?: SortOrder
  }

  export type RouteManagementBookingSumOrderByAggregateInput = {
    id?: SortOrder
    booking_id?: SortOrder
    stop_order?: SortOrder
    distance_from_previous?: SortOrder
    cumulative_distance?: SortOrder
  }

  export type EnumRouteManagementStatusEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.RouteManagementStatusEnum | EnumRouteManagementStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.RouteManagementStatusEnum[] | ListEnumRouteManagementStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.RouteManagementStatusEnum[] | ListEnumRouteManagementStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumRouteManagementStatusEnumFilter<$PrismaModel> | $Enums.RouteManagementStatusEnum
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type RouteManagementBookingListRelationFilter = {
    every?: RouteManagementBookingWhereInput
    some?: RouteManagementBookingWhereInput
    none?: RouteManagementBookingWhereInput
  }

  export type RouteManagementBookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RouteManagementUq_route_management_code_per_tenantCompoundUniqueInput = {
    tenant_id: string
    route_code: string
  }

  export type RouteManagementCountOrderByAggregateInput = {
    route_id?: SortOrder
    tenant_id?: SortOrder
    shift_id?: SortOrder
    route_code?: SortOrder
    status?: SortOrder
    planned_distance_km?: SortOrder
    planned_duration_minutes?: SortOrder
    actual_distance_km?: SortOrder
    actual_duration_minutes?: SortOrder
    actual_start_time?: SortOrder
    actual_end_time?: SortOrder
    optimized_polyline?: SortOrder
    assigned_vendor_id?: SortOrder
    assigned_vehicle_id?: SortOrder
    assigned_driver_id?: SortOrder
    total_distance_km?: SortOrder
    total_time_minutes?: SortOrder
    is_active?: SortOrder
    version?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RouteManagementAvgOrderByAggregateInput = {
    shift_id?: SortOrder
    planned_distance_km?: SortOrder
    planned_duration_minutes?: SortOrder
    actual_distance_km?: SortOrder
    actual_duration_minutes?: SortOrder
    assigned_vendor_id?: SortOrder
    assigned_vehicle_id?: SortOrder
    assigned_driver_id?: SortOrder
    total_distance_km?: SortOrder
    total_time_minutes?: SortOrder
    version?: SortOrder
  }

  export type RouteManagementMaxOrderByAggregateInput = {
    route_id?: SortOrder
    tenant_id?: SortOrder
    shift_id?: SortOrder
    route_code?: SortOrder
    status?: SortOrder
    planned_distance_km?: SortOrder
    planned_duration_minutes?: SortOrder
    actual_distance_km?: SortOrder
    actual_duration_minutes?: SortOrder
    actual_start_time?: SortOrder
    actual_end_time?: SortOrder
    optimized_polyline?: SortOrder
    assigned_vendor_id?: SortOrder
    assigned_vehicle_id?: SortOrder
    assigned_driver_id?: SortOrder
    total_distance_km?: SortOrder
    total_time_minutes?: SortOrder
    is_active?: SortOrder
    version?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RouteManagementMinOrderByAggregateInput = {
    route_id?: SortOrder
    tenant_id?: SortOrder
    shift_id?: SortOrder
    route_code?: SortOrder
    status?: SortOrder
    planned_distance_km?: SortOrder
    planned_duration_minutes?: SortOrder
    actual_distance_km?: SortOrder
    actual_duration_minutes?: SortOrder
    actual_start_time?: SortOrder
    actual_end_time?: SortOrder
    optimized_polyline?: SortOrder
    assigned_vendor_id?: SortOrder
    assigned_vehicle_id?: SortOrder
    assigned_driver_id?: SortOrder
    total_distance_km?: SortOrder
    total_time_minutes?: SortOrder
    is_active?: SortOrder
    version?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RouteManagementSumOrderByAggregateInput = {
    shift_id?: SortOrder
    planned_distance_km?: SortOrder
    planned_duration_minutes?: SortOrder
    actual_distance_km?: SortOrder
    actual_duration_minutes?: SortOrder
    assigned_vendor_id?: SortOrder
    assigned_vehicle_id?: SortOrder
    assigned_driver_id?: SortOrder
    total_distance_km?: SortOrder
    total_time_minutes?: SortOrder
    version?: SortOrder
  }

  export type EnumRouteManagementStatusEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RouteManagementStatusEnum | EnumRouteManagementStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.RouteManagementStatusEnum[] | ListEnumRouteManagementStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.RouteManagementStatusEnum[] | ListEnumRouteManagementStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumRouteManagementStatusEnumWithAggregatesFilter<$PrismaModel> | $Enums.RouteManagementStatusEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRouteManagementStatusEnumFilter<$PrismaModel>
    _max?: NestedEnumRouteManagementStatusEnumFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumGenderEnumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.GenderEnum | EnumGenderEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.GenderEnum[] | ListEnumGenderEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.GenderEnum[] | ListEnumGenderEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderEnumNullableFilter<$PrismaModel> | $Enums.GenderEnum | null
  }

  export type EnumVerificationStatusEnumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatusEnum | EnumVerificationStatusEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.VerificationStatusEnum[] | ListEnumVerificationStatusEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VerificationStatusEnum[] | ListEnumVerificationStatusEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVerificationStatusEnumNullableFilter<$PrismaModel> | $Enums.VerificationStatusEnum | null
  }

  export type VendorScalarRelationFilter = {
    is?: VendorWhereInput
    isNot?: VendorWhereInput
  }

  export type VehicleListRelationFilter = {
    every?: VehicleWhereInput
    some?: VehicleWhereInput
    none?: VehicleWhereInput
  }

  export type VehicleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DriverUq_vendor_driver_emailCompoundUniqueInput = {
    vendor_id: number
    email: string
  }

  export type DriverUq_vendor_driver_phoneCompoundUniqueInput = {
    vendor_id: number
    phone: string
  }

  export type DriverUq_vendor_driver_badgeCompoundUniqueInput = {
    vendor_id: number
    badge_number: string
  }

  export type DriverUq_vendor_driver_licenseCompoundUniqueInput = {
    vendor_id: number
    license_number: string
  }

  export type DriverUq_vendor_driver_codeCompoundUniqueInput = {
    vendor_id: number
    code: string
  }

  export type DriverUq_vendor_driver_alt_govt_idCompoundUniqueInput = {
    vendor_id: number
    alt_govt_id_number: string
  }

  export type DriverCountOrderByAggregateInput = {
    driver_id?: SortOrder
    vendor_id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    password?: SortOrder
    date_of_birth?: SortOrder
    date_of_joining?: SortOrder
    permanent_address?: SortOrder
    current_address?: SortOrder
    photo_url?: SortOrder
    bg_verify_status?: SortOrder
    bg_expiry_date?: SortOrder
    bg_verify_url?: SortOrder
    police_verify_status?: SortOrder
    police_expiry_date?: SortOrder
    police_verify_url?: SortOrder
    medical_verify_status?: SortOrder
    medical_expiry_date?: SortOrder
    medical_verify_url?: SortOrder
    training_verify_status?: SortOrder
    training_expiry_date?: SortOrder
    training_verify_url?: SortOrder
    eye_verify_status?: SortOrder
    eye_expiry_date?: SortOrder
    eye_verify_url?: SortOrder
    license_number?: SortOrder
    license_expiry_date?: SortOrder
    license_url?: SortOrder
    badge_number?: SortOrder
    badge_expiry_date?: SortOrder
    badge_url?: SortOrder
    alt_govt_id_number?: SortOrder
    alt_govt_id_type?: SortOrder
    alt_govt_id_url?: SortOrder
    induction_date?: SortOrder
    induction_url?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DriverAvgOrderByAggregateInput = {
    driver_id?: SortOrder
    vendor_id?: SortOrder
  }

  export type DriverMaxOrderByAggregateInput = {
    driver_id?: SortOrder
    vendor_id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    password?: SortOrder
    date_of_birth?: SortOrder
    date_of_joining?: SortOrder
    permanent_address?: SortOrder
    current_address?: SortOrder
    photo_url?: SortOrder
    bg_verify_status?: SortOrder
    bg_expiry_date?: SortOrder
    bg_verify_url?: SortOrder
    police_verify_status?: SortOrder
    police_expiry_date?: SortOrder
    police_verify_url?: SortOrder
    medical_verify_status?: SortOrder
    medical_expiry_date?: SortOrder
    medical_verify_url?: SortOrder
    training_verify_status?: SortOrder
    training_expiry_date?: SortOrder
    training_verify_url?: SortOrder
    eye_verify_status?: SortOrder
    eye_expiry_date?: SortOrder
    eye_verify_url?: SortOrder
    license_number?: SortOrder
    license_expiry_date?: SortOrder
    license_url?: SortOrder
    badge_number?: SortOrder
    badge_expiry_date?: SortOrder
    badge_url?: SortOrder
    alt_govt_id_number?: SortOrder
    alt_govt_id_type?: SortOrder
    alt_govt_id_url?: SortOrder
    induction_date?: SortOrder
    induction_url?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DriverMinOrderByAggregateInput = {
    driver_id?: SortOrder
    vendor_id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    password?: SortOrder
    date_of_birth?: SortOrder
    date_of_joining?: SortOrder
    permanent_address?: SortOrder
    current_address?: SortOrder
    photo_url?: SortOrder
    bg_verify_status?: SortOrder
    bg_expiry_date?: SortOrder
    bg_verify_url?: SortOrder
    police_verify_status?: SortOrder
    police_expiry_date?: SortOrder
    police_verify_url?: SortOrder
    medical_verify_status?: SortOrder
    medical_expiry_date?: SortOrder
    medical_verify_url?: SortOrder
    training_verify_status?: SortOrder
    training_expiry_date?: SortOrder
    training_verify_url?: SortOrder
    eye_verify_status?: SortOrder
    eye_expiry_date?: SortOrder
    eye_verify_url?: SortOrder
    license_number?: SortOrder
    license_expiry_date?: SortOrder
    license_url?: SortOrder
    badge_number?: SortOrder
    badge_expiry_date?: SortOrder
    badge_url?: SortOrder
    alt_govt_id_number?: SortOrder
    alt_govt_id_type?: SortOrder
    alt_govt_id_url?: SortOrder
    induction_date?: SortOrder
    induction_url?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DriverSumOrderByAggregateInput = {
    driver_id?: SortOrder
    vendor_id?: SortOrder
  }

  export type EnumGenderEnumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GenderEnum | EnumGenderEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.GenderEnum[] | ListEnumGenderEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.GenderEnum[] | ListEnumGenderEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderEnumNullableWithAggregatesFilter<$PrismaModel> | $Enums.GenderEnum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderEnumNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderEnumNullableFilter<$PrismaModel>
  }

  export type EnumVerificationStatusEnumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatusEnum | EnumVerificationStatusEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.VerificationStatusEnum[] | ListEnumVerificationStatusEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VerificationStatusEnum[] | ListEnumVerificationStatusEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVerificationStatusEnumNullableWithAggregatesFilter<$PrismaModel> | $Enums.VerificationStatusEnum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumVerificationStatusEnumNullableFilter<$PrismaModel>
    _max?: NestedEnumVerificationStatusEnumNullableFilter<$PrismaModel>
  }

  export type VehicleTypeScalarRelationFilter = {
    is?: VehicleTypeWhereInput
    isNot?: VehicleTypeWhereInput
  }

  export type DriverNullableScalarRelationFilter = {
    is?: DriverWhereInput | null
    isNot?: DriverWhereInput | null
  }

  export type VehicleUq_vendor_rc_numberCompoundUniqueInput = {
    vendor_id: number
    rc_number: string
  }

  export type VehicleUq_vendor_puc_numberCompoundUniqueInput = {
    vendor_id: number
    puc_number: string
  }

  export type VehicleUq_vendor_fitness_numberCompoundUniqueInput = {
    vendor_id: number
    fitness_number: string
  }

  export type VehicleUq_vendor_tax_receipt_numberCompoundUniqueInput = {
    vendor_id: number
    tax_receipt_number: string
  }

  export type VehicleUq_vendor_insurance_numberCompoundUniqueInput = {
    vendor_id: number
    insurance_number: string
  }

  export type VehicleUq_vendor_permit_numberCompoundUniqueInput = {
    vendor_id: number
    permit_number: string
  }

  export type VehicleCountOrderByAggregateInput = {
    vehicle_id?: SortOrder
    vehicle_type_id?: SortOrder
    vendor_id?: SortOrder
    driver_id?: SortOrder
    rc_number?: SortOrder
    rc_expiry_date?: SortOrder
    description?: SortOrder
    puc_number?: SortOrder
    puc_expiry_date?: SortOrder
    puc_url?: SortOrder
    fitness_number?: SortOrder
    fitness_expiry_date?: SortOrder
    fitness_url?: SortOrder
    tax_receipt_number?: SortOrder
    tax_receipt_date?: SortOrder
    tax_receipt_url?: SortOrder
    insurance_number?: SortOrder
    insurance_expiry_date?: SortOrder
    insurance_url?: SortOrder
    permit_number?: SortOrder
    permit_expiry_date?: SortOrder
    permit_url?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VehicleAvgOrderByAggregateInput = {
    vehicle_id?: SortOrder
    vehicle_type_id?: SortOrder
    vendor_id?: SortOrder
    driver_id?: SortOrder
  }

  export type VehicleMaxOrderByAggregateInput = {
    vehicle_id?: SortOrder
    vehicle_type_id?: SortOrder
    vendor_id?: SortOrder
    driver_id?: SortOrder
    rc_number?: SortOrder
    rc_expiry_date?: SortOrder
    description?: SortOrder
    puc_number?: SortOrder
    puc_expiry_date?: SortOrder
    puc_url?: SortOrder
    fitness_number?: SortOrder
    fitness_expiry_date?: SortOrder
    fitness_url?: SortOrder
    tax_receipt_number?: SortOrder
    tax_receipt_date?: SortOrder
    tax_receipt_url?: SortOrder
    insurance_number?: SortOrder
    insurance_expiry_date?: SortOrder
    insurance_url?: SortOrder
    permit_number?: SortOrder
    permit_expiry_date?: SortOrder
    permit_url?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VehicleMinOrderByAggregateInput = {
    vehicle_id?: SortOrder
    vehicle_type_id?: SortOrder
    vendor_id?: SortOrder
    driver_id?: SortOrder
    rc_number?: SortOrder
    rc_expiry_date?: SortOrder
    description?: SortOrder
    puc_number?: SortOrder
    puc_expiry_date?: SortOrder
    puc_url?: SortOrder
    fitness_number?: SortOrder
    fitness_expiry_date?: SortOrder
    fitness_url?: SortOrder
    tax_receipt_number?: SortOrder
    tax_receipt_date?: SortOrder
    tax_receipt_url?: SortOrder
    insurance_number?: SortOrder
    insurance_expiry_date?: SortOrder
    insurance_url?: SortOrder
    permit_number?: SortOrder
    permit_expiry_date?: SortOrder
    permit_url?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VehicleSumOrderByAggregateInput = {
    vehicle_id?: SortOrder
    vehicle_type_id?: SortOrder
    vendor_id?: SortOrder
    driver_id?: SortOrder
  }

  export type VehicleTypeUq_vendor_vehicle_type_nameCompoundUniqueInput = {
    vendor_id: number
    name: string
  }

  export type VehicleTypeCountOrderByAggregateInput = {
    vehicle_type_id?: SortOrder
    vendor_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    seats?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VehicleTypeAvgOrderByAggregateInput = {
    vehicle_type_id?: SortOrder
    vendor_id?: SortOrder
    seats?: SortOrder
  }

  export type VehicleTypeMaxOrderByAggregateInput = {
    vehicle_type_id?: SortOrder
    vendor_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    seats?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VehicleTypeMinOrderByAggregateInput = {
    vehicle_type_id?: SortOrder
    vendor_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    seats?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VehicleTypeSumOrderByAggregateInput = {
    vehicle_type_id?: SortOrder
    vendor_id?: SortOrder
    seats?: SortOrder
  }

  export type DriverListRelationFilter = {
    every?: DriverWhereInput
    some?: DriverWhereInput
    none?: DriverWhereInput
  }

  export type VehicleTypeListRelationFilter = {
    every?: VehicleTypeWhereInput
    some?: VehicleTypeWhereInput
    none?: VehicleTypeWhereInput
  }

  export type VendorUserListRelationFilter = {
    every?: VendorUserWhereInput
    some?: VendorUserWhereInput
    none?: VendorUserWhereInput
  }

  export type DriverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VehicleTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorUq_vendor_name_per_tenantCompoundUniqueInput = {
    tenant_id: string
    name: string
  }

  export type VendorUq_vendor_code_per_tenantCompoundUniqueInput = {
    tenant_id: string
    vendor_code: string
  }

  export type VendorUq_vendor_email_per_tenantCompoundUniqueInput = {
    tenant_id: string
    email: string
  }

  export type VendorUq_vendor_phone_per_tenantCompoundUniqueInput = {
    tenant_id: string
    phone: string
  }

  export type VendorCountOrderByAggregateInput = {
    vendor_id?: SortOrder
    tenant_id?: SortOrder
    name?: SortOrder
    vendor_code?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorAvgOrderByAggregateInput = {
    vendor_id?: SortOrder
  }

  export type VendorMaxOrderByAggregateInput = {
    vendor_id?: SortOrder
    tenant_id?: SortOrder
    name?: SortOrder
    vendor_code?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorMinOrderByAggregateInput = {
    vendor_id?: SortOrder
    tenant_id?: SortOrder
    name?: SortOrder
    vendor_code?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorSumOrderByAggregateInput = {
    vendor_id?: SortOrder
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type VendorUserUq_tenant_vendor_emailCompoundUniqueInput = {
    tenant_id: string
    email: string
  }

  export type VendorUserUq_tenant_vendor_phoneCompoundUniqueInput = {
    tenant_id: string
    phone: string
  }

  export type VendorUserCountOrderByAggregateInput = {
    vendor_user_id?: SortOrder
    tenant_id?: SortOrder
    vendor_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorUserAvgOrderByAggregateInput = {
    vendor_user_id?: SortOrder
    vendor_id?: SortOrder
    role_id?: SortOrder
  }

  export type VendorUserMaxOrderByAggregateInput = {
    vendor_user_id?: SortOrder
    tenant_id?: SortOrder
    vendor_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorUserMinOrderByAggregateInput = {
    vendor_user_id?: SortOrder
    tenant_id?: SortOrder
    vendor_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorUserSumOrderByAggregateInput = {
    vendor_user_id?: SortOrder
    vendor_id?: SortOrder
    role_id?: SortOrder
  }

  export type CutoffCountOrderByAggregateInput = {
    tenant_id?: SortOrder
    booking_cutoff?: SortOrder
    cancel_cutoff?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CutoffAvgOrderByAggregateInput = {
    booking_cutoff?: SortOrder
    cancel_cutoff?: SortOrder
  }

  export type CutoffMaxOrderByAggregateInput = {
    tenant_id?: SortOrder
    booking_cutoff?: SortOrder
    cancel_cutoff?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CutoffMinOrderByAggregateInput = {
    tenant_id?: SortOrder
    booking_cutoff?: SortOrder
    cancel_cutoff?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CutoffSumOrderByAggregateInput = {
    booking_cutoff?: SortOrder
    cancel_cutoff?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type WeekoffConfigNullableScalarRelationFilter = {
    is?: WeekoffConfigWhereInput | null
    isNot?: WeekoffConfigWhereInput | null
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeUq_employee_code_per_tenantCompoundUniqueInput = {
    tenant_id: string
    employee_code: string
  }

  export type EmployeeUq_employee_email_per_tenantCompoundUniqueInput = {
    tenant_id: string
    email: string
  }

  export type EmployeeUq_employee_phone_per_tenantCompoundUniqueInput = {
    tenant_id: string
    phone: string
  }

  export type EmployeeCountOrderByAggregateInput = {
    employee_id?: SortOrder
    tenant_id?: SortOrder
    role_id?: SortOrder
    name?: SortOrder
    employee_code?: SortOrder
    email?: SortOrder
    password?: SortOrder
    team_id?: SortOrder
    phone?: SortOrder
    alternate_phone?: SortOrder
    special_needs?: SortOrder
    special_needs_start_date?: SortOrder
    special_needs_end_date?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    gender?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EmployeeAvgOrderByAggregateInput = {
    employee_id?: SortOrder
    role_id?: SortOrder
    team_id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    employee_id?: SortOrder
    tenant_id?: SortOrder
    role_id?: SortOrder
    name?: SortOrder
    employee_code?: SortOrder
    email?: SortOrder
    password?: SortOrder
    team_id?: SortOrder
    phone?: SortOrder
    alternate_phone?: SortOrder
    special_needs?: SortOrder
    special_needs_start_date?: SortOrder
    special_needs_end_date?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    gender?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    employee_id?: SortOrder
    tenant_id?: SortOrder
    role_id?: SortOrder
    name?: SortOrder
    employee_code?: SortOrder
    email?: SortOrder
    password?: SortOrder
    team_id?: SortOrder
    phone?: SortOrder
    alternate_phone?: SortOrder
    special_needs?: SortOrder
    special_needs_start_date?: SortOrder
    special_needs_end_date?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    gender?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EmployeeSumOrderByAggregateInput = {
    employee_id?: SortOrder
    role_id?: SortOrder
    team_id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumShiftLogTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.ShiftLogTypeEnum | EnumShiftLogTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ShiftLogTypeEnum[] | ListEnumShiftLogTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShiftLogTypeEnum[] | ListEnumShiftLogTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumShiftLogTypeEnumFilter<$PrismaModel> | $Enums.ShiftLogTypeEnum
  }

  export type EnumPickupTypeEnumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PickupTypeEnum | EnumPickupTypeEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.PickupTypeEnum[] | ListEnumPickupTypeEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PickupTypeEnum[] | ListEnumPickupTypeEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPickupTypeEnumNullableFilter<$PrismaModel> | $Enums.PickupTypeEnum | null
  }

  export type ShiftUq_shift_code_per_tenantCompoundUniqueInput = {
    tenant_id: string
    shift_code: string
  }

  export type ShiftCountOrderByAggregateInput = {
    shift_id?: SortOrder
    tenant_id?: SortOrder
    shift_code?: SortOrder
    log_type?: SortOrder
    shift_time?: SortOrder
    pickup_type?: SortOrder
    gender?: SortOrder
    waiting_time_minutes?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ShiftAvgOrderByAggregateInput = {
    shift_id?: SortOrder
    waiting_time_minutes?: SortOrder
  }

  export type ShiftMaxOrderByAggregateInput = {
    shift_id?: SortOrder
    tenant_id?: SortOrder
    shift_code?: SortOrder
    log_type?: SortOrder
    shift_time?: SortOrder
    pickup_type?: SortOrder
    gender?: SortOrder
    waiting_time_minutes?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ShiftMinOrderByAggregateInput = {
    shift_id?: SortOrder
    tenant_id?: SortOrder
    shift_code?: SortOrder
    log_type?: SortOrder
    shift_time?: SortOrder
    pickup_type?: SortOrder
    gender?: SortOrder
    waiting_time_minutes?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ShiftSumOrderByAggregateInput = {
    shift_id?: SortOrder
    waiting_time_minutes?: SortOrder
  }

  export type EnumShiftLogTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShiftLogTypeEnum | EnumShiftLogTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ShiftLogTypeEnum[] | ListEnumShiftLogTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShiftLogTypeEnum[] | ListEnumShiftLogTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumShiftLogTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.ShiftLogTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShiftLogTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumShiftLogTypeEnumFilter<$PrismaModel>
  }

  export type EnumPickupTypeEnumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PickupTypeEnum | EnumPickupTypeEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.PickupTypeEnum[] | ListEnumPickupTypeEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PickupTypeEnum[] | ListEnumPickupTypeEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPickupTypeEnumNullableWithAggregatesFilter<$PrismaModel> | $Enums.PickupTypeEnum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPickupTypeEnumNullableFilter<$PrismaModel>
    _max?: NestedEnumPickupTypeEnumNullableFilter<$PrismaModel>
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type EmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamUq_team_name_per_tenantCompoundUniqueInput = {
    tenant_id: string
    name: string
  }

  export type TeamCountOrderByAggregateInput = {
    team_id?: SortOrder
    tenant_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TeamAvgOrderByAggregateInput = {
    team_id?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    team_id?: SortOrder
    tenant_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    team_id?: SortOrder
    tenant_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TeamSumOrderByAggregateInput = {
    team_id?: SortOrder
  }

  export type TeamListRelationFilter = {
    every?: TeamWhereInput
    some?: TeamWhereInput
    none?: TeamWhereInput
  }

  export type ShiftListRelationFilter = {
    every?: ShiftWhereInput
    some?: ShiftWhereInput
    none?: ShiftWhereInput
  }

  export type PolicyListRelationFilter = {
    every?: PolicyWhereInput
    some?: PolicyWhereInput
    none?: PolicyWhereInput
  }

  export type CutoffNullableScalarRelationFilter = {
    is?: CutoffWhereInput | null
    isNot?: CutoffWhereInput | null
  }

  export type VendorListRelationFilter = {
    every?: VendorWhereInput
    some?: VendorWhereInput
    none?: VendorWhereInput
  }

  export type RoleListRelationFilter = {
    every?: RoleWhereInput
    some?: RoleWhereInput
    none?: RoleWhereInput
  }

  export type TeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShiftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PolicyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    tenant_id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TenantAvgOrderByAggregateInput = {
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    tenant_id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    tenant_id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TenantSumOrderByAggregateInput = {
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type WeekoffConfigCountOrderByAggregateInput = {
    weekoff_id?: SortOrder
    employee_id?: SortOrder
    monday?: SortOrder
    tuesday?: SortOrder
    wednesday?: SortOrder
    thursday?: SortOrder
    friday?: SortOrder
    saturday?: SortOrder
    sunday?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WeekoffConfigAvgOrderByAggregateInput = {
    weekoff_id?: SortOrder
    employee_id?: SortOrder
  }

  export type WeekoffConfigMaxOrderByAggregateInput = {
    weekoff_id?: SortOrder
    employee_id?: SortOrder
    monday?: SortOrder
    tuesday?: SortOrder
    wednesday?: SortOrder
    thursday?: SortOrder
    friday?: SortOrder
    saturday?: SortOrder
    sunday?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WeekoffConfigMinOrderByAggregateInput = {
    weekoff_id?: SortOrder
    employee_id?: SortOrder
    monday?: SortOrder
    tuesday?: SortOrder
    wednesday?: SortOrder
    thursday?: SortOrder
    friday?: SortOrder
    saturday?: SortOrder
    sunday?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WeekoffConfigSumOrderByAggregateInput = {
    weekoff_id?: SortOrder
    employee_id?: SortOrder
  }

  export type AdminCountOrderByAggregateInput = {
    admin_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AdminAvgOrderByAggregateInput = {
    admin_id?: SortOrder
    role_id?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    admin_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    admin_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AdminSumOrderByAggregateInput = {
    admin_id?: SortOrder
    role_id?: SortOrder
  }

  export type PolicyPermissionListRelationFilter = {
    every?: PolicyPermissionWhereInput
    some?: PolicyPermissionWhereInput
    none?: PolicyPermissionWhereInput
  }

  export type PolicyPermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermissionUq_permission_module_actionCompoundUniqueInput = {
    module: string
    action: string
  }

  export type PermissionCountOrderByAggregateInput = {
    permission_id?: SortOrder
    module?: SortOrder
    action?: SortOrder
    description?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PermissionAvgOrderByAggregateInput = {
    permission_id?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    permission_id?: SortOrder
    module?: SortOrder
    action?: SortOrder
    description?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    permission_id?: SortOrder
    module?: SortOrder
    action?: SortOrder
    description?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PermissionSumOrderByAggregateInput = {
    permission_id?: SortOrder
  }

  export type TenantNullableScalarRelationFilter = {
    is?: TenantWhereInput | null
    isNot?: TenantWhereInput | null
  }

  export type RolePolicyListRelationFilter = {
    every?: RolePolicyWhereInput
    some?: RolePolicyWhereInput
    none?: RolePolicyWhereInput
  }

  export type RolePolicyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PolicyUq_policy_tenant_nameCompoundUniqueInput = {
    tenant_id: string
    name: string
  }

  export type PolicyCountOrderByAggregateInput = {
    policy_id?: SortOrder
    tenant_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    is_active?: SortOrder
    is_system_policy?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PolicyAvgOrderByAggregateInput = {
    policy_id?: SortOrder
  }

  export type PolicyMaxOrderByAggregateInput = {
    policy_id?: SortOrder
    tenant_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    is_active?: SortOrder
    is_system_policy?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PolicyMinOrderByAggregateInput = {
    policy_id?: SortOrder
    tenant_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    is_active?: SortOrder
    is_system_policy?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PolicySumOrderByAggregateInput = {
    policy_id?: SortOrder
  }

  export type PolicyScalarRelationFilter = {
    is?: PolicyWhereInput
    isNot?: PolicyWhereInput
  }

  export type PermissionScalarRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type PolicyPermissionPolicy_idPermission_idCompoundUniqueInput = {
    policy_id: number
    permission_id: number
  }

  export type PolicyPermissionCountOrderByAggregateInput = {
    policy_id?: SortOrder
    permission_id?: SortOrder
  }

  export type PolicyPermissionAvgOrderByAggregateInput = {
    policy_id?: SortOrder
    permission_id?: SortOrder
  }

  export type PolicyPermissionMaxOrderByAggregateInput = {
    policy_id?: SortOrder
    permission_id?: SortOrder
  }

  export type PolicyPermissionMinOrderByAggregateInput = {
    policy_id?: SortOrder
    permission_id?: SortOrder
  }

  export type PolicyPermissionSumOrderByAggregateInput = {
    policy_id?: SortOrder
    permission_id?: SortOrder
  }

  export type AdminListRelationFilter = {
    every?: AdminWhereInput
    some?: AdminWhereInput
    none?: AdminWhereInput
  }

  export type AdminOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleUq_role_tenant_nameCompoundUniqueInput = {
    tenant_id: string
    name: string
  }

  export type RoleCountOrderByAggregateInput = {
    role_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    is_active?: SortOrder
    tenant_id?: SortOrder
    is_system_role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    role_id?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    role_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    is_active?: SortOrder
    tenant_id?: SortOrder
    is_system_role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    role_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    is_active?: SortOrder
    tenant_id?: SortOrder
    is_system_role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    role_id?: SortOrder
  }

  export type RolePolicyRole_idPolicy_idCompoundUniqueInput = {
    role_id: number
    policy_id: number
  }

  export type RolePolicyCountOrderByAggregateInput = {
    role_id?: SortOrder
    policy_id?: SortOrder
  }

  export type RolePolicyAvgOrderByAggregateInput = {
    role_id?: SortOrder
    policy_id?: SortOrder
  }

  export type RolePolicyMaxOrderByAggregateInput = {
    role_id?: SortOrder
    policy_id?: SortOrder
  }

  export type RolePolicyMinOrderByAggregateInput = {
    role_id?: SortOrder
    policy_id?: SortOrder
  }

  export type RolePolicySumOrderByAggregateInput = {
    role_id?: SortOrder
    policy_id?: SortOrder
  }

  export type TenantCreateNestedOneWithoutBookingsInput = {
    create?: XOR<TenantCreateWithoutBookingsInput, TenantUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBookingsInput
    connect?: TenantWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutBookingsInput = {
    create?: XOR<EmployeeCreateWithoutBookingsInput, EmployeeUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutBookingsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type ShiftCreateNestedOneWithoutBookingsInput = {
    create?: XOR<ShiftCreateWithoutBookingsInput, ShiftUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ShiftCreateOrConnectWithoutBookingsInput
    connect?: ShiftWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutBookingsInput = {
    create?: XOR<TeamCreateWithoutBookingsInput, TeamUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutBookingsInput
    connect?: TeamWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumBookingStatusEnumFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatusEnum
  }

  export type TenantUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<TenantCreateWithoutBookingsInput, TenantUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBookingsInput
    upsert?: TenantUpsertWithoutBookingsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutBookingsInput, TenantUpdateWithoutBookingsInput>, TenantUncheckedUpdateWithoutBookingsInput>
  }

  export type EmployeeUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<EmployeeCreateWithoutBookingsInput, EmployeeUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutBookingsInput
    upsert?: EmployeeUpsertWithoutBookingsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutBookingsInput, EmployeeUpdateWithoutBookingsInput>, EmployeeUncheckedUpdateWithoutBookingsInput>
  }

  export type ShiftUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<ShiftCreateWithoutBookingsInput, ShiftUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ShiftCreateOrConnectWithoutBookingsInput
    upsert?: ShiftUpsertWithoutBookingsInput
    disconnect?: ShiftWhereInput | boolean
    delete?: ShiftWhereInput | boolean
    connect?: ShiftWhereUniqueInput
    update?: XOR<XOR<ShiftUpdateToOneWithWhereWithoutBookingsInput, ShiftUpdateWithoutBookingsInput>, ShiftUncheckedUpdateWithoutBookingsInput>
  }

  export type TeamUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<TeamCreateWithoutBookingsInput, TeamUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutBookingsInput
    upsert?: TeamUpsertWithoutBookingsInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutBookingsInput, TeamUpdateWithoutBookingsInput>, TeamUncheckedUpdateWithoutBookingsInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RouteManagementCreateNestedOneWithoutRoute_management_bookingsInput = {
    create?: XOR<RouteManagementCreateWithoutRoute_management_bookingsInput, RouteManagementUncheckedCreateWithoutRoute_management_bookingsInput>
    connectOrCreate?: RouteManagementCreateOrConnectWithoutRoute_management_bookingsInput
    connect?: RouteManagementWhereUniqueInput
  }

  export type RouteManagementUpdateOneRequiredWithoutRoute_management_bookingsNestedInput = {
    create?: XOR<RouteManagementCreateWithoutRoute_management_bookingsInput, RouteManagementUncheckedCreateWithoutRoute_management_bookingsInput>
    connectOrCreate?: RouteManagementCreateOrConnectWithoutRoute_management_bookingsInput
    upsert?: RouteManagementUpsertWithoutRoute_management_bookingsInput
    connect?: RouteManagementWhereUniqueInput
    update?: XOR<XOR<RouteManagementUpdateToOneWithWhereWithoutRoute_management_bookingsInput, RouteManagementUpdateWithoutRoute_management_bookingsInput>, RouteManagementUncheckedUpdateWithoutRoute_management_bookingsInput>
  }

  export type RouteManagementBookingCreateNestedManyWithoutRoute_managementInput = {
    create?: XOR<RouteManagementBookingCreateWithoutRoute_managementInput, RouteManagementBookingUncheckedCreateWithoutRoute_managementInput> | RouteManagementBookingCreateWithoutRoute_managementInput[] | RouteManagementBookingUncheckedCreateWithoutRoute_managementInput[]
    connectOrCreate?: RouteManagementBookingCreateOrConnectWithoutRoute_managementInput | RouteManagementBookingCreateOrConnectWithoutRoute_managementInput[]
    createMany?: RouteManagementBookingCreateManyRoute_managementInputEnvelope
    connect?: RouteManagementBookingWhereUniqueInput | RouteManagementBookingWhereUniqueInput[]
  }

  export type RouteManagementBookingUncheckedCreateNestedManyWithoutRoute_managementInput = {
    create?: XOR<RouteManagementBookingCreateWithoutRoute_managementInput, RouteManagementBookingUncheckedCreateWithoutRoute_managementInput> | RouteManagementBookingCreateWithoutRoute_managementInput[] | RouteManagementBookingUncheckedCreateWithoutRoute_managementInput[]
    connectOrCreate?: RouteManagementBookingCreateOrConnectWithoutRoute_managementInput | RouteManagementBookingCreateOrConnectWithoutRoute_managementInput[]
    createMany?: RouteManagementBookingCreateManyRoute_managementInputEnvelope
    connect?: RouteManagementBookingWhereUniqueInput | RouteManagementBookingWhereUniqueInput[]
  }

  export type EnumRouteManagementStatusEnumFieldUpdateOperationsInput = {
    set?: $Enums.RouteManagementStatusEnum
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type RouteManagementBookingUpdateManyWithoutRoute_managementNestedInput = {
    create?: XOR<RouteManagementBookingCreateWithoutRoute_managementInput, RouteManagementBookingUncheckedCreateWithoutRoute_managementInput> | RouteManagementBookingCreateWithoutRoute_managementInput[] | RouteManagementBookingUncheckedCreateWithoutRoute_managementInput[]
    connectOrCreate?: RouteManagementBookingCreateOrConnectWithoutRoute_managementInput | RouteManagementBookingCreateOrConnectWithoutRoute_managementInput[]
    upsert?: RouteManagementBookingUpsertWithWhereUniqueWithoutRoute_managementInput | RouteManagementBookingUpsertWithWhereUniqueWithoutRoute_managementInput[]
    createMany?: RouteManagementBookingCreateManyRoute_managementInputEnvelope
    set?: RouteManagementBookingWhereUniqueInput | RouteManagementBookingWhereUniqueInput[]
    disconnect?: RouteManagementBookingWhereUniqueInput | RouteManagementBookingWhereUniqueInput[]
    delete?: RouteManagementBookingWhereUniqueInput | RouteManagementBookingWhereUniqueInput[]
    connect?: RouteManagementBookingWhereUniqueInput | RouteManagementBookingWhereUniqueInput[]
    update?: RouteManagementBookingUpdateWithWhereUniqueWithoutRoute_managementInput | RouteManagementBookingUpdateWithWhereUniqueWithoutRoute_managementInput[]
    updateMany?: RouteManagementBookingUpdateManyWithWhereWithoutRoute_managementInput | RouteManagementBookingUpdateManyWithWhereWithoutRoute_managementInput[]
    deleteMany?: RouteManagementBookingScalarWhereInput | RouteManagementBookingScalarWhereInput[]
  }

  export type RouteManagementBookingUncheckedUpdateManyWithoutRoute_managementNestedInput = {
    create?: XOR<RouteManagementBookingCreateWithoutRoute_managementInput, RouteManagementBookingUncheckedCreateWithoutRoute_managementInput> | RouteManagementBookingCreateWithoutRoute_managementInput[] | RouteManagementBookingUncheckedCreateWithoutRoute_managementInput[]
    connectOrCreate?: RouteManagementBookingCreateOrConnectWithoutRoute_managementInput | RouteManagementBookingCreateOrConnectWithoutRoute_managementInput[]
    upsert?: RouteManagementBookingUpsertWithWhereUniqueWithoutRoute_managementInput | RouteManagementBookingUpsertWithWhereUniqueWithoutRoute_managementInput[]
    createMany?: RouteManagementBookingCreateManyRoute_managementInputEnvelope
    set?: RouteManagementBookingWhereUniqueInput | RouteManagementBookingWhereUniqueInput[]
    disconnect?: RouteManagementBookingWhereUniqueInput | RouteManagementBookingWhereUniqueInput[]
    delete?: RouteManagementBookingWhereUniqueInput | RouteManagementBookingWhereUniqueInput[]
    connect?: RouteManagementBookingWhereUniqueInput | RouteManagementBookingWhereUniqueInput[]
    update?: RouteManagementBookingUpdateWithWhereUniqueWithoutRoute_managementInput | RouteManagementBookingUpdateWithWhereUniqueWithoutRoute_managementInput[]
    updateMany?: RouteManagementBookingUpdateManyWithWhereWithoutRoute_managementInput | RouteManagementBookingUpdateManyWithWhereWithoutRoute_managementInput[]
    deleteMany?: RouteManagementBookingScalarWhereInput | RouteManagementBookingScalarWhereInput[]
  }

  export type VendorCreateNestedOneWithoutDriversInput = {
    create?: XOR<VendorCreateWithoutDriversInput, VendorUncheckedCreateWithoutDriversInput>
    connectOrCreate?: VendorCreateOrConnectWithoutDriversInput
    connect?: VendorWhereUniqueInput
  }

  export type VehicleCreateNestedManyWithoutDriverInput = {
    create?: XOR<VehicleCreateWithoutDriverInput, VehicleUncheckedCreateWithoutDriverInput> | VehicleCreateWithoutDriverInput[] | VehicleUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutDriverInput | VehicleCreateOrConnectWithoutDriverInput[]
    createMany?: VehicleCreateManyDriverInputEnvelope
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
  }

  export type VehicleUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<VehicleCreateWithoutDriverInput, VehicleUncheckedCreateWithoutDriverInput> | VehicleCreateWithoutDriverInput[] | VehicleUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutDriverInput | VehicleCreateOrConnectWithoutDriverInput[]
    createMany?: VehicleCreateManyDriverInputEnvelope
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
  }

  export type NullableEnumGenderEnumFieldUpdateOperationsInput = {
    set?: $Enums.GenderEnum | null
  }

  export type NullableEnumVerificationStatusEnumFieldUpdateOperationsInput = {
    set?: $Enums.VerificationStatusEnum | null
  }

  export type VendorUpdateOneRequiredWithoutDriversNestedInput = {
    create?: XOR<VendorCreateWithoutDriversInput, VendorUncheckedCreateWithoutDriversInput>
    connectOrCreate?: VendorCreateOrConnectWithoutDriversInput
    upsert?: VendorUpsertWithoutDriversInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutDriversInput, VendorUpdateWithoutDriversInput>, VendorUncheckedUpdateWithoutDriversInput>
  }

  export type VehicleUpdateManyWithoutDriverNestedInput = {
    create?: XOR<VehicleCreateWithoutDriverInput, VehicleUncheckedCreateWithoutDriverInput> | VehicleCreateWithoutDriverInput[] | VehicleUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutDriverInput | VehicleCreateOrConnectWithoutDriverInput[]
    upsert?: VehicleUpsertWithWhereUniqueWithoutDriverInput | VehicleUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: VehicleCreateManyDriverInputEnvelope
    set?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    disconnect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    delete?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    update?: VehicleUpdateWithWhereUniqueWithoutDriverInput | VehicleUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: VehicleUpdateManyWithWhereWithoutDriverInput | VehicleUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
  }

  export type VehicleUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<VehicleCreateWithoutDriverInput, VehicleUncheckedCreateWithoutDriverInput> | VehicleCreateWithoutDriverInput[] | VehicleUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutDriverInput | VehicleCreateOrConnectWithoutDriverInput[]
    upsert?: VehicleUpsertWithWhereUniqueWithoutDriverInput | VehicleUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: VehicleCreateManyDriverInputEnvelope
    set?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    disconnect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    delete?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    update?: VehicleUpdateWithWhereUniqueWithoutDriverInput | VehicleUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: VehicleUpdateManyWithWhereWithoutDriverInput | VehicleUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
  }

  export type VehicleTypeCreateNestedOneWithoutVehiclesInput = {
    create?: XOR<VehicleTypeCreateWithoutVehiclesInput, VehicleTypeUncheckedCreateWithoutVehiclesInput>
    connectOrCreate?: VehicleTypeCreateOrConnectWithoutVehiclesInput
    connect?: VehicleTypeWhereUniqueInput
  }

  export type VendorCreateNestedOneWithoutVehiclesInput = {
    create?: XOR<VendorCreateWithoutVehiclesInput, VendorUncheckedCreateWithoutVehiclesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutVehiclesInput
    connect?: VendorWhereUniqueInput
  }

  export type DriverCreateNestedOneWithoutVehiclesInput = {
    create?: XOR<DriverCreateWithoutVehiclesInput, DriverUncheckedCreateWithoutVehiclesInput>
    connectOrCreate?: DriverCreateOrConnectWithoutVehiclesInput
    connect?: DriverWhereUniqueInput
  }

  export type VehicleTypeUpdateOneRequiredWithoutVehiclesNestedInput = {
    create?: XOR<VehicleTypeCreateWithoutVehiclesInput, VehicleTypeUncheckedCreateWithoutVehiclesInput>
    connectOrCreate?: VehicleTypeCreateOrConnectWithoutVehiclesInput
    upsert?: VehicleTypeUpsertWithoutVehiclesInput
    connect?: VehicleTypeWhereUniqueInput
    update?: XOR<XOR<VehicleTypeUpdateToOneWithWhereWithoutVehiclesInput, VehicleTypeUpdateWithoutVehiclesInput>, VehicleTypeUncheckedUpdateWithoutVehiclesInput>
  }

  export type VendorUpdateOneRequiredWithoutVehiclesNestedInput = {
    create?: XOR<VendorCreateWithoutVehiclesInput, VendorUncheckedCreateWithoutVehiclesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutVehiclesInput
    upsert?: VendorUpsertWithoutVehiclesInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutVehiclesInput, VendorUpdateWithoutVehiclesInput>, VendorUncheckedUpdateWithoutVehiclesInput>
  }

  export type DriverUpdateOneWithoutVehiclesNestedInput = {
    create?: XOR<DriverCreateWithoutVehiclesInput, DriverUncheckedCreateWithoutVehiclesInput>
    connectOrCreate?: DriverCreateOrConnectWithoutVehiclesInput
    upsert?: DriverUpsertWithoutVehiclesInput
    disconnect?: DriverWhereInput | boolean
    delete?: DriverWhereInput | boolean
    connect?: DriverWhereUniqueInput
    update?: XOR<XOR<DriverUpdateToOneWithWhereWithoutVehiclesInput, DriverUpdateWithoutVehiclesInput>, DriverUncheckedUpdateWithoutVehiclesInput>
  }

  export type VendorCreateNestedOneWithoutVehicle_typesInput = {
    create?: XOR<VendorCreateWithoutVehicle_typesInput, VendorUncheckedCreateWithoutVehicle_typesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutVehicle_typesInput
    connect?: VendorWhereUniqueInput
  }

  export type VehicleCreateNestedManyWithoutVehicle_typeInput = {
    create?: XOR<VehicleCreateWithoutVehicle_typeInput, VehicleUncheckedCreateWithoutVehicle_typeInput> | VehicleCreateWithoutVehicle_typeInput[] | VehicleUncheckedCreateWithoutVehicle_typeInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutVehicle_typeInput | VehicleCreateOrConnectWithoutVehicle_typeInput[]
    createMany?: VehicleCreateManyVehicle_typeInputEnvelope
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
  }

  export type VehicleUncheckedCreateNestedManyWithoutVehicle_typeInput = {
    create?: XOR<VehicleCreateWithoutVehicle_typeInput, VehicleUncheckedCreateWithoutVehicle_typeInput> | VehicleCreateWithoutVehicle_typeInput[] | VehicleUncheckedCreateWithoutVehicle_typeInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutVehicle_typeInput | VehicleCreateOrConnectWithoutVehicle_typeInput[]
    createMany?: VehicleCreateManyVehicle_typeInputEnvelope
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
  }

  export type VendorUpdateOneRequiredWithoutVehicle_typesNestedInput = {
    create?: XOR<VendorCreateWithoutVehicle_typesInput, VendorUncheckedCreateWithoutVehicle_typesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutVehicle_typesInput
    upsert?: VendorUpsertWithoutVehicle_typesInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutVehicle_typesInput, VendorUpdateWithoutVehicle_typesInput>, VendorUncheckedUpdateWithoutVehicle_typesInput>
  }

  export type VehicleUpdateManyWithoutVehicle_typeNestedInput = {
    create?: XOR<VehicleCreateWithoutVehicle_typeInput, VehicleUncheckedCreateWithoutVehicle_typeInput> | VehicleCreateWithoutVehicle_typeInput[] | VehicleUncheckedCreateWithoutVehicle_typeInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutVehicle_typeInput | VehicleCreateOrConnectWithoutVehicle_typeInput[]
    upsert?: VehicleUpsertWithWhereUniqueWithoutVehicle_typeInput | VehicleUpsertWithWhereUniqueWithoutVehicle_typeInput[]
    createMany?: VehicleCreateManyVehicle_typeInputEnvelope
    set?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    disconnect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    delete?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    update?: VehicleUpdateWithWhereUniqueWithoutVehicle_typeInput | VehicleUpdateWithWhereUniqueWithoutVehicle_typeInput[]
    updateMany?: VehicleUpdateManyWithWhereWithoutVehicle_typeInput | VehicleUpdateManyWithWhereWithoutVehicle_typeInput[]
    deleteMany?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
  }

  export type VehicleUncheckedUpdateManyWithoutVehicle_typeNestedInput = {
    create?: XOR<VehicleCreateWithoutVehicle_typeInput, VehicleUncheckedCreateWithoutVehicle_typeInput> | VehicleCreateWithoutVehicle_typeInput[] | VehicleUncheckedCreateWithoutVehicle_typeInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutVehicle_typeInput | VehicleCreateOrConnectWithoutVehicle_typeInput[]
    upsert?: VehicleUpsertWithWhereUniqueWithoutVehicle_typeInput | VehicleUpsertWithWhereUniqueWithoutVehicle_typeInput[]
    createMany?: VehicleCreateManyVehicle_typeInputEnvelope
    set?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    disconnect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    delete?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    update?: VehicleUpdateWithWhereUniqueWithoutVehicle_typeInput | VehicleUpdateWithWhereUniqueWithoutVehicle_typeInput[]
    updateMany?: VehicleUpdateManyWithWhereWithoutVehicle_typeInput | VehicleUpdateManyWithWhereWithoutVehicle_typeInput[]
    deleteMany?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutVendorsInput = {
    create?: XOR<TenantCreateWithoutVendorsInput, TenantUncheckedCreateWithoutVendorsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutVendorsInput
    connect?: TenantWhereUniqueInput
  }

  export type DriverCreateNestedManyWithoutVendorInput = {
    create?: XOR<DriverCreateWithoutVendorInput, DriverUncheckedCreateWithoutVendorInput> | DriverCreateWithoutVendorInput[] | DriverUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: DriverCreateOrConnectWithoutVendorInput | DriverCreateOrConnectWithoutVendorInput[]
    createMany?: DriverCreateManyVendorInputEnvelope
    connect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
  }

  export type VehicleTypeCreateNestedManyWithoutVendorInput = {
    create?: XOR<VehicleTypeCreateWithoutVendorInput, VehicleTypeUncheckedCreateWithoutVendorInput> | VehicleTypeCreateWithoutVendorInput[] | VehicleTypeUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VehicleTypeCreateOrConnectWithoutVendorInput | VehicleTypeCreateOrConnectWithoutVendorInput[]
    createMany?: VehicleTypeCreateManyVendorInputEnvelope
    connect?: VehicleTypeWhereUniqueInput | VehicleTypeWhereUniqueInput[]
  }

  export type VehicleCreateNestedManyWithoutVendorInput = {
    create?: XOR<VehicleCreateWithoutVendorInput, VehicleUncheckedCreateWithoutVendorInput> | VehicleCreateWithoutVendorInput[] | VehicleUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutVendorInput | VehicleCreateOrConnectWithoutVendorInput[]
    createMany?: VehicleCreateManyVendorInputEnvelope
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
  }

  export type VendorUserCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorUserCreateWithoutVendorInput, VendorUserUncheckedCreateWithoutVendorInput> | VendorUserCreateWithoutVendorInput[] | VendorUserUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorUserCreateOrConnectWithoutVendorInput | VendorUserCreateOrConnectWithoutVendorInput[]
    createMany?: VendorUserCreateManyVendorInputEnvelope
    connect?: VendorUserWhereUniqueInput | VendorUserWhereUniqueInput[]
  }

  export type DriverUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<DriverCreateWithoutVendorInput, DriverUncheckedCreateWithoutVendorInput> | DriverCreateWithoutVendorInput[] | DriverUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: DriverCreateOrConnectWithoutVendorInput | DriverCreateOrConnectWithoutVendorInput[]
    createMany?: DriverCreateManyVendorInputEnvelope
    connect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
  }

  export type VehicleTypeUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<VehicleTypeCreateWithoutVendorInput, VehicleTypeUncheckedCreateWithoutVendorInput> | VehicleTypeCreateWithoutVendorInput[] | VehicleTypeUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VehicleTypeCreateOrConnectWithoutVendorInput | VehicleTypeCreateOrConnectWithoutVendorInput[]
    createMany?: VehicleTypeCreateManyVendorInputEnvelope
    connect?: VehicleTypeWhereUniqueInput | VehicleTypeWhereUniqueInput[]
  }

  export type VehicleUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<VehicleCreateWithoutVendorInput, VehicleUncheckedCreateWithoutVendorInput> | VehicleCreateWithoutVendorInput[] | VehicleUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutVendorInput | VehicleCreateOrConnectWithoutVendorInput[]
    createMany?: VehicleCreateManyVendorInputEnvelope
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
  }

  export type VendorUserUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorUserCreateWithoutVendorInput, VendorUserUncheckedCreateWithoutVendorInput> | VendorUserCreateWithoutVendorInput[] | VendorUserUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorUserCreateOrConnectWithoutVendorInput | VendorUserCreateOrConnectWithoutVendorInput[]
    createMany?: VendorUserCreateManyVendorInputEnvelope
    connect?: VendorUserWhereUniqueInput | VendorUserWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutVendorsNestedInput = {
    create?: XOR<TenantCreateWithoutVendorsInput, TenantUncheckedCreateWithoutVendorsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutVendorsInput
    upsert?: TenantUpsertWithoutVendorsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutVendorsInput, TenantUpdateWithoutVendorsInput>, TenantUncheckedUpdateWithoutVendorsInput>
  }

  export type DriverUpdateManyWithoutVendorNestedInput = {
    create?: XOR<DriverCreateWithoutVendorInput, DriverUncheckedCreateWithoutVendorInput> | DriverCreateWithoutVendorInput[] | DriverUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: DriverCreateOrConnectWithoutVendorInput | DriverCreateOrConnectWithoutVendorInput[]
    upsert?: DriverUpsertWithWhereUniqueWithoutVendorInput | DriverUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: DriverCreateManyVendorInputEnvelope
    set?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    disconnect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    delete?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    connect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    update?: DriverUpdateWithWhereUniqueWithoutVendorInput | DriverUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: DriverUpdateManyWithWhereWithoutVendorInput | DriverUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: DriverScalarWhereInput | DriverScalarWhereInput[]
  }

  export type VehicleTypeUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VehicleTypeCreateWithoutVendorInput, VehicleTypeUncheckedCreateWithoutVendorInput> | VehicleTypeCreateWithoutVendorInput[] | VehicleTypeUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VehicleTypeCreateOrConnectWithoutVendorInput | VehicleTypeCreateOrConnectWithoutVendorInput[]
    upsert?: VehicleTypeUpsertWithWhereUniqueWithoutVendorInput | VehicleTypeUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VehicleTypeCreateManyVendorInputEnvelope
    set?: VehicleTypeWhereUniqueInput | VehicleTypeWhereUniqueInput[]
    disconnect?: VehicleTypeWhereUniqueInput | VehicleTypeWhereUniqueInput[]
    delete?: VehicleTypeWhereUniqueInput | VehicleTypeWhereUniqueInput[]
    connect?: VehicleTypeWhereUniqueInput | VehicleTypeWhereUniqueInput[]
    update?: VehicleTypeUpdateWithWhereUniqueWithoutVendorInput | VehicleTypeUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VehicleTypeUpdateManyWithWhereWithoutVendorInput | VehicleTypeUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VehicleTypeScalarWhereInput | VehicleTypeScalarWhereInput[]
  }

  export type VehicleUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VehicleCreateWithoutVendorInput, VehicleUncheckedCreateWithoutVendorInput> | VehicleCreateWithoutVendorInput[] | VehicleUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutVendorInput | VehicleCreateOrConnectWithoutVendorInput[]
    upsert?: VehicleUpsertWithWhereUniqueWithoutVendorInput | VehicleUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VehicleCreateManyVendorInputEnvelope
    set?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    disconnect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    delete?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    update?: VehicleUpdateWithWhereUniqueWithoutVendorInput | VehicleUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VehicleUpdateManyWithWhereWithoutVendorInput | VehicleUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
  }

  export type VendorUserUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorUserCreateWithoutVendorInput, VendorUserUncheckedCreateWithoutVendorInput> | VendorUserCreateWithoutVendorInput[] | VendorUserUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorUserCreateOrConnectWithoutVendorInput | VendorUserCreateOrConnectWithoutVendorInput[]
    upsert?: VendorUserUpsertWithWhereUniqueWithoutVendorInput | VendorUserUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorUserCreateManyVendorInputEnvelope
    set?: VendorUserWhereUniqueInput | VendorUserWhereUniqueInput[]
    disconnect?: VendorUserWhereUniqueInput | VendorUserWhereUniqueInput[]
    delete?: VendorUserWhereUniqueInput | VendorUserWhereUniqueInput[]
    connect?: VendorUserWhereUniqueInput | VendorUserWhereUniqueInput[]
    update?: VendorUserUpdateWithWhereUniqueWithoutVendorInput | VendorUserUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorUserUpdateManyWithWhereWithoutVendorInput | VendorUserUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorUserScalarWhereInput | VendorUserScalarWhereInput[]
  }

  export type DriverUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<DriverCreateWithoutVendorInput, DriverUncheckedCreateWithoutVendorInput> | DriverCreateWithoutVendorInput[] | DriverUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: DriverCreateOrConnectWithoutVendorInput | DriverCreateOrConnectWithoutVendorInput[]
    upsert?: DriverUpsertWithWhereUniqueWithoutVendorInput | DriverUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: DriverCreateManyVendorInputEnvelope
    set?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    disconnect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    delete?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    connect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    update?: DriverUpdateWithWhereUniqueWithoutVendorInput | DriverUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: DriverUpdateManyWithWhereWithoutVendorInput | DriverUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: DriverScalarWhereInput | DriverScalarWhereInput[]
  }

  export type VehicleTypeUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VehicleTypeCreateWithoutVendorInput, VehicleTypeUncheckedCreateWithoutVendorInput> | VehicleTypeCreateWithoutVendorInput[] | VehicleTypeUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VehicleTypeCreateOrConnectWithoutVendorInput | VehicleTypeCreateOrConnectWithoutVendorInput[]
    upsert?: VehicleTypeUpsertWithWhereUniqueWithoutVendorInput | VehicleTypeUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VehicleTypeCreateManyVendorInputEnvelope
    set?: VehicleTypeWhereUniqueInput | VehicleTypeWhereUniqueInput[]
    disconnect?: VehicleTypeWhereUniqueInput | VehicleTypeWhereUniqueInput[]
    delete?: VehicleTypeWhereUniqueInput | VehicleTypeWhereUniqueInput[]
    connect?: VehicleTypeWhereUniqueInput | VehicleTypeWhereUniqueInput[]
    update?: VehicleTypeUpdateWithWhereUniqueWithoutVendorInput | VehicleTypeUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VehicleTypeUpdateManyWithWhereWithoutVendorInput | VehicleTypeUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VehicleTypeScalarWhereInput | VehicleTypeScalarWhereInput[]
  }

  export type VehicleUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VehicleCreateWithoutVendorInput, VehicleUncheckedCreateWithoutVendorInput> | VehicleCreateWithoutVendorInput[] | VehicleUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutVendorInput | VehicleCreateOrConnectWithoutVendorInput[]
    upsert?: VehicleUpsertWithWhereUniqueWithoutVendorInput | VehicleUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VehicleCreateManyVendorInputEnvelope
    set?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    disconnect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    delete?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    update?: VehicleUpdateWithWhereUniqueWithoutVendorInput | VehicleUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VehicleUpdateManyWithWhereWithoutVendorInput | VehicleUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
  }

  export type VendorUserUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorUserCreateWithoutVendorInput, VendorUserUncheckedCreateWithoutVendorInput> | VendorUserCreateWithoutVendorInput[] | VendorUserUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorUserCreateOrConnectWithoutVendorInput | VendorUserCreateOrConnectWithoutVendorInput[]
    upsert?: VendorUserUpsertWithWhereUniqueWithoutVendorInput | VendorUserUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorUserCreateManyVendorInputEnvelope
    set?: VendorUserWhereUniqueInput | VendorUserWhereUniqueInput[]
    disconnect?: VendorUserWhereUniqueInput | VendorUserWhereUniqueInput[]
    delete?: VendorUserWhereUniqueInput | VendorUserWhereUniqueInput[]
    connect?: VendorUserWhereUniqueInput | VendorUserWhereUniqueInput[]
    update?: VendorUserUpdateWithWhereUniqueWithoutVendorInput | VendorUserUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorUserUpdateManyWithWhereWithoutVendorInput | VendorUserUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorUserScalarWhereInput | VendorUserScalarWhereInput[]
  }

  export type VendorCreateNestedOneWithoutVendor_usersInput = {
    create?: XOR<VendorCreateWithoutVendor_usersInput, VendorUncheckedCreateWithoutVendor_usersInput>
    connectOrCreate?: VendorCreateOrConnectWithoutVendor_usersInput
    connect?: VendorWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutVendor_usersInput = {
    create?: XOR<RoleCreateWithoutVendor_usersInput, RoleUncheckedCreateWithoutVendor_usersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutVendor_usersInput
    connect?: RoleWhereUniqueInput
  }

  export type VendorUpdateOneRequiredWithoutVendor_usersNestedInput = {
    create?: XOR<VendorCreateWithoutVendor_usersInput, VendorUncheckedCreateWithoutVendor_usersInput>
    connectOrCreate?: VendorCreateOrConnectWithoutVendor_usersInput
    upsert?: VendorUpsertWithoutVendor_usersInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutVendor_usersInput, VendorUpdateWithoutVendor_usersInput>, VendorUncheckedUpdateWithoutVendor_usersInput>
  }

  export type RoleUpdateOneRequiredWithoutVendor_usersNestedInput = {
    create?: XOR<RoleCreateWithoutVendor_usersInput, RoleUncheckedCreateWithoutVendor_usersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutVendor_usersInput
    upsert?: RoleUpsertWithoutVendor_usersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutVendor_usersInput, RoleUpdateWithoutVendor_usersInput>, RoleUncheckedUpdateWithoutVendor_usersInput>
  }

  export type TenantCreateNestedOneWithoutCutoffInput = {
    create?: XOR<TenantCreateWithoutCutoffInput, TenantUncheckedCreateWithoutCutoffInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCutoffInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutCutoffNestedInput = {
    create?: XOR<TenantCreateWithoutCutoffInput, TenantUncheckedCreateWithoutCutoffInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCutoffInput
    upsert?: TenantUpsertWithoutCutoffInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCutoffInput, TenantUpdateWithoutCutoffInput>, TenantUncheckedUpdateWithoutCutoffInput>
  }

  export type TenantCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<TenantCreateWithoutEmployeesInput, TenantUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutEmployeesInput
    connect?: TenantWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<TeamCreateWithoutEmployeesInput, TeamUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutEmployeesInput
    connect?: TeamWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<RoleCreateWithoutEmployeesInput, RoleUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutEmployeesInput
    connect?: RoleWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<BookingCreateWithoutEmployeeInput, BookingUncheckedCreateWithoutEmployeeInput> | BookingCreateWithoutEmployeeInput[] | BookingUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutEmployeeInput | BookingCreateOrConnectWithoutEmployeeInput[]
    createMany?: BookingCreateManyEmployeeInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type WeekoffConfigCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<WeekoffConfigCreateWithoutEmployeeInput, WeekoffConfigUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: WeekoffConfigCreateOrConnectWithoutEmployeeInput
    connect?: WeekoffConfigWhereUniqueInput
  }

  export type BookingUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<BookingCreateWithoutEmployeeInput, BookingUncheckedCreateWithoutEmployeeInput> | BookingCreateWithoutEmployeeInput[] | BookingUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutEmployeeInput | BookingCreateOrConnectWithoutEmployeeInput[]
    createMany?: BookingCreateManyEmployeeInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type WeekoffConfigUncheckedCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<WeekoffConfigCreateWithoutEmployeeInput, WeekoffConfigUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: WeekoffConfigCreateOrConnectWithoutEmployeeInput
    connect?: WeekoffConfigWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type TenantUpdateOneRequiredWithoutEmployeesNestedInput = {
    create?: XOR<TenantCreateWithoutEmployeesInput, TenantUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutEmployeesInput
    upsert?: TenantUpsertWithoutEmployeesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutEmployeesInput, TenantUpdateWithoutEmployeesInput>, TenantUncheckedUpdateWithoutEmployeesInput>
  }

  export type TeamUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<TeamCreateWithoutEmployeesInput, TeamUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutEmployeesInput
    upsert?: TeamUpsertWithoutEmployeesInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutEmployeesInput, TeamUpdateWithoutEmployeesInput>, TeamUncheckedUpdateWithoutEmployeesInput>
  }

  export type RoleUpdateOneRequiredWithoutEmployeesNestedInput = {
    create?: XOR<RoleCreateWithoutEmployeesInput, RoleUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutEmployeesInput
    upsert?: RoleUpsertWithoutEmployeesInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutEmployeesInput, RoleUpdateWithoutEmployeesInput>, RoleUncheckedUpdateWithoutEmployeesInput>
  }

  export type BookingUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<BookingCreateWithoutEmployeeInput, BookingUncheckedCreateWithoutEmployeeInput> | BookingCreateWithoutEmployeeInput[] | BookingUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutEmployeeInput | BookingCreateOrConnectWithoutEmployeeInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutEmployeeInput | BookingUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: BookingCreateManyEmployeeInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutEmployeeInput | BookingUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutEmployeeInput | BookingUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type WeekoffConfigUpdateOneWithoutEmployeeNestedInput = {
    create?: XOR<WeekoffConfigCreateWithoutEmployeeInput, WeekoffConfigUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: WeekoffConfigCreateOrConnectWithoutEmployeeInput
    upsert?: WeekoffConfigUpsertWithoutEmployeeInput
    disconnect?: WeekoffConfigWhereInput | boolean
    delete?: WeekoffConfigWhereInput | boolean
    connect?: WeekoffConfigWhereUniqueInput
    update?: XOR<XOR<WeekoffConfigUpdateToOneWithWhereWithoutEmployeeInput, WeekoffConfigUpdateWithoutEmployeeInput>, WeekoffConfigUncheckedUpdateWithoutEmployeeInput>
  }

  export type BookingUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<BookingCreateWithoutEmployeeInput, BookingUncheckedCreateWithoutEmployeeInput> | BookingCreateWithoutEmployeeInput[] | BookingUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutEmployeeInput | BookingCreateOrConnectWithoutEmployeeInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutEmployeeInput | BookingUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: BookingCreateManyEmployeeInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutEmployeeInput | BookingUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutEmployeeInput | BookingUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type WeekoffConfigUncheckedUpdateOneWithoutEmployeeNestedInput = {
    create?: XOR<WeekoffConfigCreateWithoutEmployeeInput, WeekoffConfigUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: WeekoffConfigCreateOrConnectWithoutEmployeeInput
    upsert?: WeekoffConfigUpsertWithoutEmployeeInput
    disconnect?: WeekoffConfigWhereInput | boolean
    delete?: WeekoffConfigWhereInput | boolean
    connect?: WeekoffConfigWhereUniqueInput
    update?: XOR<XOR<WeekoffConfigUpdateToOneWithWhereWithoutEmployeeInput, WeekoffConfigUpdateWithoutEmployeeInput>, WeekoffConfigUncheckedUpdateWithoutEmployeeInput>
  }

  export type TenantCreateNestedOneWithoutShiftsInput = {
    create?: XOR<TenantCreateWithoutShiftsInput, TenantUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutShiftsInput
    connect?: TenantWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutShiftInput = {
    create?: XOR<BookingCreateWithoutShiftInput, BookingUncheckedCreateWithoutShiftInput> | BookingCreateWithoutShiftInput[] | BookingUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutShiftInput | BookingCreateOrConnectWithoutShiftInput[]
    createMany?: BookingCreateManyShiftInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutShiftInput = {
    create?: XOR<BookingCreateWithoutShiftInput, BookingUncheckedCreateWithoutShiftInput> | BookingCreateWithoutShiftInput[] | BookingUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutShiftInput | BookingCreateOrConnectWithoutShiftInput[]
    createMany?: BookingCreateManyShiftInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type EnumShiftLogTypeEnumFieldUpdateOperationsInput = {
    set?: $Enums.ShiftLogTypeEnum
  }

  export type NullableEnumPickupTypeEnumFieldUpdateOperationsInput = {
    set?: $Enums.PickupTypeEnum | null
  }

  export type TenantUpdateOneRequiredWithoutShiftsNestedInput = {
    create?: XOR<TenantCreateWithoutShiftsInput, TenantUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutShiftsInput
    upsert?: TenantUpsertWithoutShiftsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutShiftsInput, TenantUpdateWithoutShiftsInput>, TenantUncheckedUpdateWithoutShiftsInput>
  }

  export type BookingUpdateManyWithoutShiftNestedInput = {
    create?: XOR<BookingCreateWithoutShiftInput, BookingUncheckedCreateWithoutShiftInput> | BookingCreateWithoutShiftInput[] | BookingUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutShiftInput | BookingCreateOrConnectWithoutShiftInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutShiftInput | BookingUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: BookingCreateManyShiftInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutShiftInput | BookingUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutShiftInput | BookingUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutShiftNestedInput = {
    create?: XOR<BookingCreateWithoutShiftInput, BookingUncheckedCreateWithoutShiftInput> | BookingCreateWithoutShiftInput[] | BookingUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutShiftInput | BookingCreateOrConnectWithoutShiftInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutShiftInput | BookingUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: BookingCreateManyShiftInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutShiftInput | BookingUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutShiftInput | BookingUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutTeamsInput = {
    create?: XOR<TenantCreateWithoutTeamsInput, TenantUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTeamsInput
    connect?: TenantWhereUniqueInput
  }

  export type EmployeeCreateNestedManyWithoutTeamInput = {
    create?: XOR<EmployeeCreateWithoutTeamInput, EmployeeUncheckedCreateWithoutTeamInput> | EmployeeCreateWithoutTeamInput[] | EmployeeUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutTeamInput | EmployeeCreateOrConnectWithoutTeamInput[]
    createMany?: EmployeeCreateManyTeamInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutTeamInput = {
    create?: XOR<BookingCreateWithoutTeamInput, BookingUncheckedCreateWithoutTeamInput> | BookingCreateWithoutTeamInput[] | BookingUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTeamInput | BookingCreateOrConnectWithoutTeamInput[]
    createMany?: BookingCreateManyTeamInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<EmployeeCreateWithoutTeamInput, EmployeeUncheckedCreateWithoutTeamInput> | EmployeeCreateWithoutTeamInput[] | EmployeeUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutTeamInput | EmployeeCreateOrConnectWithoutTeamInput[]
    createMany?: EmployeeCreateManyTeamInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<BookingCreateWithoutTeamInput, BookingUncheckedCreateWithoutTeamInput> | BookingCreateWithoutTeamInput[] | BookingUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTeamInput | BookingCreateOrConnectWithoutTeamInput[]
    createMany?: BookingCreateManyTeamInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutTeamsNestedInput = {
    create?: XOR<TenantCreateWithoutTeamsInput, TenantUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTeamsInput
    upsert?: TenantUpsertWithoutTeamsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutTeamsInput, TenantUpdateWithoutTeamsInput>, TenantUncheckedUpdateWithoutTeamsInput>
  }

  export type EmployeeUpdateManyWithoutTeamNestedInput = {
    create?: XOR<EmployeeCreateWithoutTeamInput, EmployeeUncheckedCreateWithoutTeamInput> | EmployeeCreateWithoutTeamInput[] | EmployeeUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutTeamInput | EmployeeCreateOrConnectWithoutTeamInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutTeamInput | EmployeeUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: EmployeeCreateManyTeamInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutTeamInput | EmployeeUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutTeamInput | EmployeeUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutTeamNestedInput = {
    create?: XOR<BookingCreateWithoutTeamInput, BookingUncheckedCreateWithoutTeamInput> | BookingCreateWithoutTeamInput[] | BookingUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTeamInput | BookingCreateOrConnectWithoutTeamInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutTeamInput | BookingUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: BookingCreateManyTeamInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutTeamInput | BookingUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutTeamInput | BookingUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<EmployeeCreateWithoutTeamInput, EmployeeUncheckedCreateWithoutTeamInput> | EmployeeCreateWithoutTeamInput[] | EmployeeUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutTeamInput | EmployeeCreateOrConnectWithoutTeamInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutTeamInput | EmployeeUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: EmployeeCreateManyTeamInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutTeamInput | EmployeeUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutTeamInput | EmployeeUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<BookingCreateWithoutTeamInput, BookingUncheckedCreateWithoutTeamInput> | BookingCreateWithoutTeamInput[] | BookingUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTeamInput | BookingCreateOrConnectWithoutTeamInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutTeamInput | BookingUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: BookingCreateManyTeamInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutTeamInput | BookingUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutTeamInput | BookingUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type TeamCreateNestedManyWithoutTenantInput = {
    create?: XOR<TeamCreateWithoutTenantInput, TeamUncheckedCreateWithoutTenantInput> | TeamCreateWithoutTenantInput[] | TeamUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutTenantInput | TeamCreateOrConnectWithoutTenantInput[]
    createMany?: TeamCreateManyTenantInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type EmployeeCreateNestedManyWithoutTenantInput = {
    create?: XOR<EmployeeCreateWithoutTenantInput, EmployeeUncheckedCreateWithoutTenantInput> | EmployeeCreateWithoutTenantInput[] | EmployeeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutTenantInput | EmployeeCreateOrConnectWithoutTenantInput[]
    createMany?: EmployeeCreateManyTenantInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type ShiftCreateNestedManyWithoutTenantInput = {
    create?: XOR<ShiftCreateWithoutTenantInput, ShiftUncheckedCreateWithoutTenantInput> | ShiftCreateWithoutTenantInput[] | ShiftUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutTenantInput | ShiftCreateOrConnectWithoutTenantInput[]
    createMany?: ShiftCreateManyTenantInputEnvelope
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutTenantInput = {
    create?: XOR<BookingCreateWithoutTenantInput, BookingUncheckedCreateWithoutTenantInput> | BookingCreateWithoutTenantInput[] | BookingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTenantInput | BookingCreateOrConnectWithoutTenantInput[]
    createMany?: BookingCreateManyTenantInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type PolicyCreateNestedManyWithoutTenantInput = {
    create?: XOR<PolicyCreateWithoutTenantInput, PolicyUncheckedCreateWithoutTenantInput> | PolicyCreateWithoutTenantInput[] | PolicyUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutTenantInput | PolicyCreateOrConnectWithoutTenantInput[]
    createMany?: PolicyCreateManyTenantInputEnvelope
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
  }

  export type CutoffCreateNestedOneWithoutTenantInput = {
    create?: XOR<CutoffCreateWithoutTenantInput, CutoffUncheckedCreateWithoutTenantInput>
    connectOrCreate?: CutoffCreateOrConnectWithoutTenantInput
    connect?: CutoffWhereUniqueInput
  }

  export type VendorCreateNestedManyWithoutTenantInput = {
    create?: XOR<VendorCreateWithoutTenantInput, VendorUncheckedCreateWithoutTenantInput> | VendorCreateWithoutTenantInput[] | VendorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutTenantInput | VendorCreateOrConnectWithoutTenantInput[]
    createMany?: VendorCreateManyTenantInputEnvelope
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
  }

  export type RoleCreateNestedManyWithoutTenantInput = {
    create?: XOR<RoleCreateWithoutTenantInput, RoleUncheckedCreateWithoutTenantInput> | RoleCreateWithoutTenantInput[] | RoleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutTenantInput | RoleCreateOrConnectWithoutTenantInput[]
    createMany?: RoleCreateManyTenantInputEnvelope
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type TeamUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TeamCreateWithoutTenantInput, TeamUncheckedCreateWithoutTenantInput> | TeamCreateWithoutTenantInput[] | TeamUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutTenantInput | TeamCreateOrConnectWithoutTenantInput[]
    createMany?: TeamCreateManyTenantInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<EmployeeCreateWithoutTenantInput, EmployeeUncheckedCreateWithoutTenantInput> | EmployeeCreateWithoutTenantInput[] | EmployeeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutTenantInput | EmployeeCreateOrConnectWithoutTenantInput[]
    createMany?: EmployeeCreateManyTenantInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type ShiftUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ShiftCreateWithoutTenantInput, ShiftUncheckedCreateWithoutTenantInput> | ShiftCreateWithoutTenantInput[] | ShiftUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutTenantInput | ShiftCreateOrConnectWithoutTenantInput[]
    createMany?: ShiftCreateManyTenantInputEnvelope
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<BookingCreateWithoutTenantInput, BookingUncheckedCreateWithoutTenantInput> | BookingCreateWithoutTenantInput[] | BookingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTenantInput | BookingCreateOrConnectWithoutTenantInput[]
    createMany?: BookingCreateManyTenantInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type PolicyUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PolicyCreateWithoutTenantInput, PolicyUncheckedCreateWithoutTenantInput> | PolicyCreateWithoutTenantInput[] | PolicyUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutTenantInput | PolicyCreateOrConnectWithoutTenantInput[]
    createMany?: PolicyCreateManyTenantInputEnvelope
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
  }

  export type CutoffUncheckedCreateNestedOneWithoutTenantInput = {
    create?: XOR<CutoffCreateWithoutTenantInput, CutoffUncheckedCreateWithoutTenantInput>
    connectOrCreate?: CutoffCreateOrConnectWithoutTenantInput
    connect?: CutoffWhereUniqueInput
  }

  export type VendorUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<VendorCreateWithoutTenantInput, VendorUncheckedCreateWithoutTenantInput> | VendorCreateWithoutTenantInput[] | VendorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutTenantInput | VendorCreateOrConnectWithoutTenantInput[]
    createMany?: VendorCreateManyTenantInputEnvelope
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
  }

  export type RoleUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<RoleCreateWithoutTenantInput, RoleUncheckedCreateWithoutTenantInput> | RoleCreateWithoutTenantInput[] | RoleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutTenantInput | RoleCreateOrConnectWithoutTenantInput[]
    createMany?: RoleCreateManyTenantInputEnvelope
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type TeamUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TeamCreateWithoutTenantInput, TeamUncheckedCreateWithoutTenantInput> | TeamCreateWithoutTenantInput[] | TeamUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutTenantInput | TeamCreateOrConnectWithoutTenantInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutTenantInput | TeamUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TeamCreateManyTenantInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutTenantInput | TeamUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutTenantInput | TeamUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type EmployeeUpdateManyWithoutTenantNestedInput = {
    create?: XOR<EmployeeCreateWithoutTenantInput, EmployeeUncheckedCreateWithoutTenantInput> | EmployeeCreateWithoutTenantInput[] | EmployeeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutTenantInput | EmployeeCreateOrConnectWithoutTenantInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutTenantInput | EmployeeUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: EmployeeCreateManyTenantInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutTenantInput | EmployeeUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutTenantInput | EmployeeUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type ShiftUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ShiftCreateWithoutTenantInput, ShiftUncheckedCreateWithoutTenantInput> | ShiftCreateWithoutTenantInput[] | ShiftUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutTenantInput | ShiftCreateOrConnectWithoutTenantInput[]
    upsert?: ShiftUpsertWithWhereUniqueWithoutTenantInput | ShiftUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ShiftCreateManyTenantInputEnvelope
    set?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    disconnect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    delete?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    update?: ShiftUpdateWithWhereUniqueWithoutTenantInput | ShiftUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ShiftUpdateManyWithWhereWithoutTenantInput | ShiftUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutTenantNestedInput = {
    create?: XOR<BookingCreateWithoutTenantInput, BookingUncheckedCreateWithoutTenantInput> | BookingCreateWithoutTenantInput[] | BookingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTenantInput | BookingCreateOrConnectWithoutTenantInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutTenantInput | BookingUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: BookingCreateManyTenantInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutTenantInput | BookingUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutTenantInput | BookingUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type PolicyUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PolicyCreateWithoutTenantInput, PolicyUncheckedCreateWithoutTenantInput> | PolicyCreateWithoutTenantInput[] | PolicyUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutTenantInput | PolicyCreateOrConnectWithoutTenantInput[]
    upsert?: PolicyUpsertWithWhereUniqueWithoutTenantInput | PolicyUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PolicyCreateManyTenantInputEnvelope
    set?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    disconnect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    delete?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    update?: PolicyUpdateWithWhereUniqueWithoutTenantInput | PolicyUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PolicyUpdateManyWithWhereWithoutTenantInput | PolicyUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PolicyScalarWhereInput | PolicyScalarWhereInput[]
  }

  export type CutoffUpdateOneWithoutTenantNestedInput = {
    create?: XOR<CutoffCreateWithoutTenantInput, CutoffUncheckedCreateWithoutTenantInput>
    connectOrCreate?: CutoffCreateOrConnectWithoutTenantInput
    upsert?: CutoffUpsertWithoutTenantInput
    disconnect?: CutoffWhereInput | boolean
    delete?: CutoffWhereInput | boolean
    connect?: CutoffWhereUniqueInput
    update?: XOR<XOR<CutoffUpdateToOneWithWhereWithoutTenantInput, CutoffUpdateWithoutTenantInput>, CutoffUncheckedUpdateWithoutTenantInput>
  }

  export type VendorUpdateManyWithoutTenantNestedInput = {
    create?: XOR<VendorCreateWithoutTenantInput, VendorUncheckedCreateWithoutTenantInput> | VendorCreateWithoutTenantInput[] | VendorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutTenantInput | VendorCreateOrConnectWithoutTenantInput[]
    upsert?: VendorUpsertWithWhereUniqueWithoutTenantInput | VendorUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: VendorCreateManyTenantInputEnvelope
    set?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    disconnect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    delete?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    update?: VendorUpdateWithWhereUniqueWithoutTenantInput | VendorUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: VendorUpdateManyWithWhereWithoutTenantInput | VendorUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: VendorScalarWhereInput | VendorScalarWhereInput[]
  }

  export type RoleUpdateManyWithoutTenantNestedInput = {
    create?: XOR<RoleCreateWithoutTenantInput, RoleUncheckedCreateWithoutTenantInput> | RoleCreateWithoutTenantInput[] | RoleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutTenantInput | RoleCreateOrConnectWithoutTenantInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutTenantInput | RoleUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: RoleCreateManyTenantInputEnvelope
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutTenantInput | RoleUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutTenantInput | RoleUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type TeamUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TeamCreateWithoutTenantInput, TeamUncheckedCreateWithoutTenantInput> | TeamCreateWithoutTenantInput[] | TeamUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutTenantInput | TeamCreateOrConnectWithoutTenantInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutTenantInput | TeamUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TeamCreateManyTenantInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutTenantInput | TeamUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutTenantInput | TeamUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<EmployeeCreateWithoutTenantInput, EmployeeUncheckedCreateWithoutTenantInput> | EmployeeCreateWithoutTenantInput[] | EmployeeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutTenantInput | EmployeeCreateOrConnectWithoutTenantInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutTenantInput | EmployeeUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: EmployeeCreateManyTenantInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutTenantInput | EmployeeUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutTenantInput | EmployeeUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type ShiftUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ShiftCreateWithoutTenantInput, ShiftUncheckedCreateWithoutTenantInput> | ShiftCreateWithoutTenantInput[] | ShiftUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutTenantInput | ShiftCreateOrConnectWithoutTenantInput[]
    upsert?: ShiftUpsertWithWhereUniqueWithoutTenantInput | ShiftUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ShiftCreateManyTenantInputEnvelope
    set?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    disconnect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    delete?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    update?: ShiftUpdateWithWhereUniqueWithoutTenantInput | ShiftUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ShiftUpdateManyWithWhereWithoutTenantInput | ShiftUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<BookingCreateWithoutTenantInput, BookingUncheckedCreateWithoutTenantInput> | BookingCreateWithoutTenantInput[] | BookingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTenantInput | BookingCreateOrConnectWithoutTenantInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutTenantInput | BookingUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: BookingCreateManyTenantInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutTenantInput | BookingUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutTenantInput | BookingUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type PolicyUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PolicyCreateWithoutTenantInput, PolicyUncheckedCreateWithoutTenantInput> | PolicyCreateWithoutTenantInput[] | PolicyUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutTenantInput | PolicyCreateOrConnectWithoutTenantInput[]
    upsert?: PolicyUpsertWithWhereUniqueWithoutTenantInput | PolicyUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PolicyCreateManyTenantInputEnvelope
    set?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    disconnect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    delete?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    update?: PolicyUpdateWithWhereUniqueWithoutTenantInput | PolicyUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PolicyUpdateManyWithWhereWithoutTenantInput | PolicyUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PolicyScalarWhereInput | PolicyScalarWhereInput[]
  }

  export type CutoffUncheckedUpdateOneWithoutTenantNestedInput = {
    create?: XOR<CutoffCreateWithoutTenantInput, CutoffUncheckedCreateWithoutTenantInput>
    connectOrCreate?: CutoffCreateOrConnectWithoutTenantInput
    upsert?: CutoffUpsertWithoutTenantInput
    disconnect?: CutoffWhereInput | boolean
    delete?: CutoffWhereInput | boolean
    connect?: CutoffWhereUniqueInput
    update?: XOR<XOR<CutoffUpdateToOneWithWhereWithoutTenantInput, CutoffUpdateWithoutTenantInput>, CutoffUncheckedUpdateWithoutTenantInput>
  }

  export type VendorUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<VendorCreateWithoutTenantInput, VendorUncheckedCreateWithoutTenantInput> | VendorCreateWithoutTenantInput[] | VendorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutTenantInput | VendorCreateOrConnectWithoutTenantInput[]
    upsert?: VendorUpsertWithWhereUniqueWithoutTenantInput | VendorUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: VendorCreateManyTenantInputEnvelope
    set?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    disconnect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    delete?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    update?: VendorUpdateWithWhereUniqueWithoutTenantInput | VendorUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: VendorUpdateManyWithWhereWithoutTenantInput | VendorUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: VendorScalarWhereInput | VendorScalarWhereInput[]
  }

  export type RoleUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<RoleCreateWithoutTenantInput, RoleUncheckedCreateWithoutTenantInput> | RoleCreateWithoutTenantInput[] | RoleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutTenantInput | RoleCreateOrConnectWithoutTenantInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutTenantInput | RoleUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: RoleCreateManyTenantInputEnvelope
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutTenantInput | RoleUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutTenantInput | RoleUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type EmployeeCreateNestedOneWithoutWeekoff_configInput = {
    create?: XOR<EmployeeCreateWithoutWeekoff_configInput, EmployeeUncheckedCreateWithoutWeekoff_configInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutWeekoff_configInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutWeekoff_configNestedInput = {
    create?: XOR<EmployeeCreateWithoutWeekoff_configInput, EmployeeUncheckedCreateWithoutWeekoff_configInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutWeekoff_configInput
    upsert?: EmployeeUpsertWithoutWeekoff_configInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutWeekoff_configInput, EmployeeUpdateWithoutWeekoff_configInput>, EmployeeUncheckedUpdateWithoutWeekoff_configInput>
  }

  export type RoleCreateNestedOneWithoutAdminsInput = {
    create?: XOR<RoleCreateWithoutAdminsInput, RoleUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutAdminsInput
    connect?: RoleWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutAdminsNestedInput = {
    create?: XOR<RoleCreateWithoutAdminsInput, RoleUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutAdminsInput
    upsert?: RoleUpsertWithoutAdminsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutAdminsInput, RoleUpdateWithoutAdminsInput>, RoleUncheckedUpdateWithoutAdminsInput>
  }

  export type PolicyPermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<PolicyPermissionCreateWithoutPermissionInput, PolicyPermissionUncheckedCreateWithoutPermissionInput> | PolicyPermissionCreateWithoutPermissionInput[] | PolicyPermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: PolicyPermissionCreateOrConnectWithoutPermissionInput | PolicyPermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: PolicyPermissionCreateManyPermissionInputEnvelope
    connect?: PolicyPermissionWhereUniqueInput | PolicyPermissionWhereUniqueInput[]
  }

  export type PolicyPermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<PolicyPermissionCreateWithoutPermissionInput, PolicyPermissionUncheckedCreateWithoutPermissionInput> | PolicyPermissionCreateWithoutPermissionInput[] | PolicyPermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: PolicyPermissionCreateOrConnectWithoutPermissionInput | PolicyPermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: PolicyPermissionCreateManyPermissionInputEnvelope
    connect?: PolicyPermissionWhereUniqueInput | PolicyPermissionWhereUniqueInput[]
  }

  export type PolicyPermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<PolicyPermissionCreateWithoutPermissionInput, PolicyPermissionUncheckedCreateWithoutPermissionInput> | PolicyPermissionCreateWithoutPermissionInput[] | PolicyPermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: PolicyPermissionCreateOrConnectWithoutPermissionInput | PolicyPermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: PolicyPermissionUpsertWithWhereUniqueWithoutPermissionInput | PolicyPermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: PolicyPermissionCreateManyPermissionInputEnvelope
    set?: PolicyPermissionWhereUniqueInput | PolicyPermissionWhereUniqueInput[]
    disconnect?: PolicyPermissionWhereUniqueInput | PolicyPermissionWhereUniqueInput[]
    delete?: PolicyPermissionWhereUniqueInput | PolicyPermissionWhereUniqueInput[]
    connect?: PolicyPermissionWhereUniqueInput | PolicyPermissionWhereUniqueInput[]
    update?: PolicyPermissionUpdateWithWhereUniqueWithoutPermissionInput | PolicyPermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: PolicyPermissionUpdateManyWithWhereWithoutPermissionInput | PolicyPermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: PolicyPermissionScalarWhereInput | PolicyPermissionScalarWhereInput[]
  }

  export type PolicyPermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<PolicyPermissionCreateWithoutPermissionInput, PolicyPermissionUncheckedCreateWithoutPermissionInput> | PolicyPermissionCreateWithoutPermissionInput[] | PolicyPermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: PolicyPermissionCreateOrConnectWithoutPermissionInput | PolicyPermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: PolicyPermissionUpsertWithWhereUniqueWithoutPermissionInput | PolicyPermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: PolicyPermissionCreateManyPermissionInputEnvelope
    set?: PolicyPermissionWhereUniqueInput | PolicyPermissionWhereUniqueInput[]
    disconnect?: PolicyPermissionWhereUniqueInput | PolicyPermissionWhereUniqueInput[]
    delete?: PolicyPermissionWhereUniqueInput | PolicyPermissionWhereUniqueInput[]
    connect?: PolicyPermissionWhereUniqueInput | PolicyPermissionWhereUniqueInput[]
    update?: PolicyPermissionUpdateWithWhereUniqueWithoutPermissionInput | PolicyPermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: PolicyPermissionUpdateManyWithWhereWithoutPermissionInput | PolicyPermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: PolicyPermissionScalarWhereInput | PolicyPermissionScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutPoliciesInput = {
    create?: XOR<TenantCreateWithoutPoliciesInput, TenantUncheckedCreateWithoutPoliciesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPoliciesInput
    connect?: TenantWhereUniqueInput
  }

  export type PolicyPermissionCreateNestedManyWithoutPolicyInput = {
    create?: XOR<PolicyPermissionCreateWithoutPolicyInput, PolicyPermissionUncheckedCreateWithoutPolicyInput> | PolicyPermissionCreateWithoutPolicyInput[] | PolicyPermissionUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: PolicyPermissionCreateOrConnectWithoutPolicyInput | PolicyPermissionCreateOrConnectWithoutPolicyInput[]
    createMany?: PolicyPermissionCreateManyPolicyInputEnvelope
    connect?: PolicyPermissionWhereUniqueInput | PolicyPermissionWhereUniqueInput[]
  }

  export type RolePolicyCreateNestedManyWithoutPolicyInput = {
    create?: XOR<RolePolicyCreateWithoutPolicyInput, RolePolicyUncheckedCreateWithoutPolicyInput> | RolePolicyCreateWithoutPolicyInput[] | RolePolicyUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: RolePolicyCreateOrConnectWithoutPolicyInput | RolePolicyCreateOrConnectWithoutPolicyInput[]
    createMany?: RolePolicyCreateManyPolicyInputEnvelope
    connect?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
  }

  export type PolicyPermissionUncheckedCreateNestedManyWithoutPolicyInput = {
    create?: XOR<PolicyPermissionCreateWithoutPolicyInput, PolicyPermissionUncheckedCreateWithoutPolicyInput> | PolicyPermissionCreateWithoutPolicyInput[] | PolicyPermissionUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: PolicyPermissionCreateOrConnectWithoutPolicyInput | PolicyPermissionCreateOrConnectWithoutPolicyInput[]
    createMany?: PolicyPermissionCreateManyPolicyInputEnvelope
    connect?: PolicyPermissionWhereUniqueInput | PolicyPermissionWhereUniqueInput[]
  }

  export type RolePolicyUncheckedCreateNestedManyWithoutPolicyInput = {
    create?: XOR<RolePolicyCreateWithoutPolicyInput, RolePolicyUncheckedCreateWithoutPolicyInput> | RolePolicyCreateWithoutPolicyInput[] | RolePolicyUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: RolePolicyCreateOrConnectWithoutPolicyInput | RolePolicyCreateOrConnectWithoutPolicyInput[]
    createMany?: RolePolicyCreateManyPolicyInputEnvelope
    connect?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
  }

  export type TenantUpdateOneWithoutPoliciesNestedInput = {
    create?: XOR<TenantCreateWithoutPoliciesInput, TenantUncheckedCreateWithoutPoliciesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPoliciesInput
    upsert?: TenantUpsertWithoutPoliciesInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPoliciesInput, TenantUpdateWithoutPoliciesInput>, TenantUncheckedUpdateWithoutPoliciesInput>
  }

  export type PolicyPermissionUpdateManyWithoutPolicyNestedInput = {
    create?: XOR<PolicyPermissionCreateWithoutPolicyInput, PolicyPermissionUncheckedCreateWithoutPolicyInput> | PolicyPermissionCreateWithoutPolicyInput[] | PolicyPermissionUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: PolicyPermissionCreateOrConnectWithoutPolicyInput | PolicyPermissionCreateOrConnectWithoutPolicyInput[]
    upsert?: PolicyPermissionUpsertWithWhereUniqueWithoutPolicyInput | PolicyPermissionUpsertWithWhereUniqueWithoutPolicyInput[]
    createMany?: PolicyPermissionCreateManyPolicyInputEnvelope
    set?: PolicyPermissionWhereUniqueInput | PolicyPermissionWhereUniqueInput[]
    disconnect?: PolicyPermissionWhereUniqueInput | PolicyPermissionWhereUniqueInput[]
    delete?: PolicyPermissionWhereUniqueInput | PolicyPermissionWhereUniqueInput[]
    connect?: PolicyPermissionWhereUniqueInput | PolicyPermissionWhereUniqueInput[]
    update?: PolicyPermissionUpdateWithWhereUniqueWithoutPolicyInput | PolicyPermissionUpdateWithWhereUniqueWithoutPolicyInput[]
    updateMany?: PolicyPermissionUpdateManyWithWhereWithoutPolicyInput | PolicyPermissionUpdateManyWithWhereWithoutPolicyInput[]
    deleteMany?: PolicyPermissionScalarWhereInput | PolicyPermissionScalarWhereInput[]
  }

  export type RolePolicyUpdateManyWithoutPolicyNestedInput = {
    create?: XOR<RolePolicyCreateWithoutPolicyInput, RolePolicyUncheckedCreateWithoutPolicyInput> | RolePolicyCreateWithoutPolicyInput[] | RolePolicyUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: RolePolicyCreateOrConnectWithoutPolicyInput | RolePolicyCreateOrConnectWithoutPolicyInput[]
    upsert?: RolePolicyUpsertWithWhereUniqueWithoutPolicyInput | RolePolicyUpsertWithWhereUniqueWithoutPolicyInput[]
    createMany?: RolePolicyCreateManyPolicyInputEnvelope
    set?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    disconnect?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    delete?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    connect?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    update?: RolePolicyUpdateWithWhereUniqueWithoutPolicyInput | RolePolicyUpdateWithWhereUniqueWithoutPolicyInput[]
    updateMany?: RolePolicyUpdateManyWithWhereWithoutPolicyInput | RolePolicyUpdateManyWithWhereWithoutPolicyInput[]
    deleteMany?: RolePolicyScalarWhereInput | RolePolicyScalarWhereInput[]
  }

  export type PolicyPermissionUncheckedUpdateManyWithoutPolicyNestedInput = {
    create?: XOR<PolicyPermissionCreateWithoutPolicyInput, PolicyPermissionUncheckedCreateWithoutPolicyInput> | PolicyPermissionCreateWithoutPolicyInput[] | PolicyPermissionUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: PolicyPermissionCreateOrConnectWithoutPolicyInput | PolicyPermissionCreateOrConnectWithoutPolicyInput[]
    upsert?: PolicyPermissionUpsertWithWhereUniqueWithoutPolicyInput | PolicyPermissionUpsertWithWhereUniqueWithoutPolicyInput[]
    createMany?: PolicyPermissionCreateManyPolicyInputEnvelope
    set?: PolicyPermissionWhereUniqueInput | PolicyPermissionWhereUniqueInput[]
    disconnect?: PolicyPermissionWhereUniqueInput | PolicyPermissionWhereUniqueInput[]
    delete?: PolicyPermissionWhereUniqueInput | PolicyPermissionWhereUniqueInput[]
    connect?: PolicyPermissionWhereUniqueInput | PolicyPermissionWhereUniqueInput[]
    update?: PolicyPermissionUpdateWithWhereUniqueWithoutPolicyInput | PolicyPermissionUpdateWithWhereUniqueWithoutPolicyInput[]
    updateMany?: PolicyPermissionUpdateManyWithWhereWithoutPolicyInput | PolicyPermissionUpdateManyWithWhereWithoutPolicyInput[]
    deleteMany?: PolicyPermissionScalarWhereInput | PolicyPermissionScalarWhereInput[]
  }

  export type RolePolicyUncheckedUpdateManyWithoutPolicyNestedInput = {
    create?: XOR<RolePolicyCreateWithoutPolicyInput, RolePolicyUncheckedCreateWithoutPolicyInput> | RolePolicyCreateWithoutPolicyInput[] | RolePolicyUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: RolePolicyCreateOrConnectWithoutPolicyInput | RolePolicyCreateOrConnectWithoutPolicyInput[]
    upsert?: RolePolicyUpsertWithWhereUniqueWithoutPolicyInput | RolePolicyUpsertWithWhereUniqueWithoutPolicyInput[]
    createMany?: RolePolicyCreateManyPolicyInputEnvelope
    set?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    disconnect?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    delete?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    connect?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    update?: RolePolicyUpdateWithWhereUniqueWithoutPolicyInput | RolePolicyUpdateWithWhereUniqueWithoutPolicyInput[]
    updateMany?: RolePolicyUpdateManyWithWhereWithoutPolicyInput | RolePolicyUpdateManyWithWhereWithoutPolicyInput[]
    deleteMany?: RolePolicyScalarWhereInput | RolePolicyScalarWhereInput[]
  }

  export type PolicyCreateNestedOneWithoutPolicy_permissionsInput = {
    create?: XOR<PolicyCreateWithoutPolicy_permissionsInput, PolicyUncheckedCreateWithoutPolicy_permissionsInput>
    connectOrCreate?: PolicyCreateOrConnectWithoutPolicy_permissionsInput
    connect?: PolicyWhereUniqueInput
  }

  export type PermissionCreateNestedOneWithoutPolicy_permissionsInput = {
    create?: XOR<PermissionCreateWithoutPolicy_permissionsInput, PermissionUncheckedCreateWithoutPolicy_permissionsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutPolicy_permissionsInput
    connect?: PermissionWhereUniqueInput
  }

  export type PolicyUpdateOneRequiredWithoutPolicy_permissionsNestedInput = {
    create?: XOR<PolicyCreateWithoutPolicy_permissionsInput, PolicyUncheckedCreateWithoutPolicy_permissionsInput>
    connectOrCreate?: PolicyCreateOrConnectWithoutPolicy_permissionsInput
    upsert?: PolicyUpsertWithoutPolicy_permissionsInput
    connect?: PolicyWhereUniqueInput
    update?: XOR<XOR<PolicyUpdateToOneWithWhereWithoutPolicy_permissionsInput, PolicyUpdateWithoutPolicy_permissionsInput>, PolicyUncheckedUpdateWithoutPolicy_permissionsInput>
  }

  export type PermissionUpdateOneRequiredWithoutPolicy_permissionsNestedInput = {
    create?: XOR<PermissionCreateWithoutPolicy_permissionsInput, PermissionUncheckedCreateWithoutPolicy_permissionsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutPolicy_permissionsInput
    upsert?: PermissionUpsertWithoutPolicy_permissionsInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutPolicy_permissionsInput, PermissionUpdateWithoutPolicy_permissionsInput>, PermissionUncheckedUpdateWithoutPolicy_permissionsInput>
  }

  export type TenantCreateNestedOneWithoutRolesInput = {
    create?: XOR<TenantCreateWithoutRolesInput, TenantUncheckedCreateWithoutRolesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutRolesInput
    connect?: TenantWhereUniqueInput
  }

  export type RolePolicyCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePolicyCreateWithoutRoleInput, RolePolicyUncheckedCreateWithoutRoleInput> | RolePolicyCreateWithoutRoleInput[] | RolePolicyUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePolicyCreateOrConnectWithoutRoleInput | RolePolicyCreateOrConnectWithoutRoleInput[]
    createMany?: RolePolicyCreateManyRoleInputEnvelope
    connect?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
  }

  export type AdminCreateNestedManyWithoutRoleInput = {
    create?: XOR<AdminCreateWithoutRoleInput, AdminUncheckedCreateWithoutRoleInput> | AdminCreateWithoutRoleInput[] | AdminUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutRoleInput | AdminCreateOrConnectWithoutRoleInput[]
    createMany?: AdminCreateManyRoleInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type VendorUserCreateNestedManyWithoutRoleInput = {
    create?: XOR<VendorUserCreateWithoutRoleInput, VendorUserUncheckedCreateWithoutRoleInput> | VendorUserCreateWithoutRoleInput[] | VendorUserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: VendorUserCreateOrConnectWithoutRoleInput | VendorUserCreateOrConnectWithoutRoleInput[]
    createMany?: VendorUserCreateManyRoleInputEnvelope
    connect?: VendorUserWhereUniqueInput | VendorUserWhereUniqueInput[]
  }

  export type EmployeeCreateNestedManyWithoutRoleInput = {
    create?: XOR<EmployeeCreateWithoutRoleInput, EmployeeUncheckedCreateWithoutRoleInput> | EmployeeCreateWithoutRoleInput[] | EmployeeUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutRoleInput | EmployeeCreateOrConnectWithoutRoleInput[]
    createMany?: EmployeeCreateManyRoleInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type RolePolicyUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePolicyCreateWithoutRoleInput, RolePolicyUncheckedCreateWithoutRoleInput> | RolePolicyCreateWithoutRoleInput[] | RolePolicyUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePolicyCreateOrConnectWithoutRoleInput | RolePolicyCreateOrConnectWithoutRoleInput[]
    createMany?: RolePolicyCreateManyRoleInputEnvelope
    connect?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
  }

  export type AdminUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<AdminCreateWithoutRoleInput, AdminUncheckedCreateWithoutRoleInput> | AdminCreateWithoutRoleInput[] | AdminUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutRoleInput | AdminCreateOrConnectWithoutRoleInput[]
    createMany?: AdminCreateManyRoleInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type VendorUserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<VendorUserCreateWithoutRoleInput, VendorUserUncheckedCreateWithoutRoleInput> | VendorUserCreateWithoutRoleInput[] | VendorUserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: VendorUserCreateOrConnectWithoutRoleInput | VendorUserCreateOrConnectWithoutRoleInput[]
    createMany?: VendorUserCreateManyRoleInputEnvelope
    connect?: VendorUserWhereUniqueInput | VendorUserWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<EmployeeCreateWithoutRoleInput, EmployeeUncheckedCreateWithoutRoleInput> | EmployeeCreateWithoutRoleInput[] | EmployeeUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutRoleInput | EmployeeCreateOrConnectWithoutRoleInput[]
    createMany?: EmployeeCreateManyRoleInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type TenantUpdateOneWithoutRolesNestedInput = {
    create?: XOR<TenantCreateWithoutRolesInput, TenantUncheckedCreateWithoutRolesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutRolesInput
    upsert?: TenantUpsertWithoutRolesInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutRolesInput, TenantUpdateWithoutRolesInput>, TenantUncheckedUpdateWithoutRolesInput>
  }

  export type RolePolicyUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePolicyCreateWithoutRoleInput, RolePolicyUncheckedCreateWithoutRoleInput> | RolePolicyCreateWithoutRoleInput[] | RolePolicyUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePolicyCreateOrConnectWithoutRoleInput | RolePolicyCreateOrConnectWithoutRoleInput[]
    upsert?: RolePolicyUpsertWithWhereUniqueWithoutRoleInput | RolePolicyUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePolicyCreateManyRoleInputEnvelope
    set?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    disconnect?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    delete?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    connect?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    update?: RolePolicyUpdateWithWhereUniqueWithoutRoleInput | RolePolicyUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePolicyUpdateManyWithWhereWithoutRoleInput | RolePolicyUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePolicyScalarWhereInput | RolePolicyScalarWhereInput[]
  }

  export type AdminUpdateManyWithoutRoleNestedInput = {
    create?: XOR<AdminCreateWithoutRoleInput, AdminUncheckedCreateWithoutRoleInput> | AdminCreateWithoutRoleInput[] | AdminUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutRoleInput | AdminCreateOrConnectWithoutRoleInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutRoleInput | AdminUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: AdminCreateManyRoleInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutRoleInput | AdminUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutRoleInput | AdminUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type VendorUserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<VendorUserCreateWithoutRoleInput, VendorUserUncheckedCreateWithoutRoleInput> | VendorUserCreateWithoutRoleInput[] | VendorUserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: VendorUserCreateOrConnectWithoutRoleInput | VendorUserCreateOrConnectWithoutRoleInput[]
    upsert?: VendorUserUpsertWithWhereUniqueWithoutRoleInput | VendorUserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: VendorUserCreateManyRoleInputEnvelope
    set?: VendorUserWhereUniqueInput | VendorUserWhereUniqueInput[]
    disconnect?: VendorUserWhereUniqueInput | VendorUserWhereUniqueInput[]
    delete?: VendorUserWhereUniqueInput | VendorUserWhereUniqueInput[]
    connect?: VendorUserWhereUniqueInput | VendorUserWhereUniqueInput[]
    update?: VendorUserUpdateWithWhereUniqueWithoutRoleInput | VendorUserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: VendorUserUpdateManyWithWhereWithoutRoleInput | VendorUserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: VendorUserScalarWhereInput | VendorUserScalarWhereInput[]
  }

  export type EmployeeUpdateManyWithoutRoleNestedInput = {
    create?: XOR<EmployeeCreateWithoutRoleInput, EmployeeUncheckedCreateWithoutRoleInput> | EmployeeCreateWithoutRoleInput[] | EmployeeUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutRoleInput | EmployeeCreateOrConnectWithoutRoleInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutRoleInput | EmployeeUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: EmployeeCreateManyRoleInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutRoleInput | EmployeeUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutRoleInput | EmployeeUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type RolePolicyUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePolicyCreateWithoutRoleInput, RolePolicyUncheckedCreateWithoutRoleInput> | RolePolicyCreateWithoutRoleInput[] | RolePolicyUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePolicyCreateOrConnectWithoutRoleInput | RolePolicyCreateOrConnectWithoutRoleInput[]
    upsert?: RolePolicyUpsertWithWhereUniqueWithoutRoleInput | RolePolicyUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePolicyCreateManyRoleInputEnvelope
    set?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    disconnect?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    delete?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    connect?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    update?: RolePolicyUpdateWithWhereUniqueWithoutRoleInput | RolePolicyUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePolicyUpdateManyWithWhereWithoutRoleInput | RolePolicyUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePolicyScalarWhereInput | RolePolicyScalarWhereInput[]
  }

  export type AdminUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<AdminCreateWithoutRoleInput, AdminUncheckedCreateWithoutRoleInput> | AdminCreateWithoutRoleInput[] | AdminUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutRoleInput | AdminCreateOrConnectWithoutRoleInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutRoleInput | AdminUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: AdminCreateManyRoleInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutRoleInput | AdminUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutRoleInput | AdminUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type VendorUserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<VendorUserCreateWithoutRoleInput, VendorUserUncheckedCreateWithoutRoleInput> | VendorUserCreateWithoutRoleInput[] | VendorUserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: VendorUserCreateOrConnectWithoutRoleInput | VendorUserCreateOrConnectWithoutRoleInput[]
    upsert?: VendorUserUpsertWithWhereUniqueWithoutRoleInput | VendorUserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: VendorUserCreateManyRoleInputEnvelope
    set?: VendorUserWhereUniqueInput | VendorUserWhereUniqueInput[]
    disconnect?: VendorUserWhereUniqueInput | VendorUserWhereUniqueInput[]
    delete?: VendorUserWhereUniqueInput | VendorUserWhereUniqueInput[]
    connect?: VendorUserWhereUniqueInput | VendorUserWhereUniqueInput[]
    update?: VendorUserUpdateWithWhereUniqueWithoutRoleInput | VendorUserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: VendorUserUpdateManyWithWhereWithoutRoleInput | VendorUserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: VendorUserScalarWhereInput | VendorUserScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<EmployeeCreateWithoutRoleInput, EmployeeUncheckedCreateWithoutRoleInput> | EmployeeCreateWithoutRoleInput[] | EmployeeUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutRoleInput | EmployeeCreateOrConnectWithoutRoleInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutRoleInput | EmployeeUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: EmployeeCreateManyRoleInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutRoleInput | EmployeeUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutRoleInput | EmployeeUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutRole_policiesInput = {
    create?: XOR<RoleCreateWithoutRole_policiesInput, RoleUncheckedCreateWithoutRole_policiesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRole_policiesInput
    connect?: RoleWhereUniqueInput
  }

  export type PolicyCreateNestedOneWithoutRole_policiesInput = {
    create?: XOR<PolicyCreateWithoutRole_policiesInput, PolicyUncheckedCreateWithoutRole_policiesInput>
    connectOrCreate?: PolicyCreateOrConnectWithoutRole_policiesInput
    connect?: PolicyWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutRole_policiesNestedInput = {
    create?: XOR<RoleCreateWithoutRole_policiesInput, RoleUncheckedCreateWithoutRole_policiesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRole_policiesInput
    upsert?: RoleUpsertWithoutRole_policiesInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutRole_policiesInput, RoleUpdateWithoutRole_policiesInput>, RoleUncheckedUpdateWithoutRole_policiesInput>
  }

  export type PolicyUpdateOneRequiredWithoutRole_policiesNestedInput = {
    create?: XOR<PolicyCreateWithoutRole_policiesInput, PolicyUncheckedCreateWithoutRole_policiesInput>
    connectOrCreate?: PolicyCreateOrConnectWithoutRole_policiesInput
    upsert?: PolicyUpsertWithoutRole_policiesInput
    connect?: PolicyWhereUniqueInput
    update?: XOR<XOR<PolicyUpdateToOneWithWhereWithoutRole_policiesInput, PolicyUpdateWithoutRole_policiesInput>, PolicyUncheckedUpdateWithoutRole_policiesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumBookingStatusEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatusEnum | EnumBookingStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatusEnum[] | ListEnumBookingStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatusEnum[] | ListEnumBookingStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusEnumFilter<$PrismaModel> | $Enums.BookingStatusEnum
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatusEnum | EnumBookingStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatusEnum[] | ListEnumBookingStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatusEnum[] | ListEnumBookingStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusEnumWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatusEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusEnumFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusEnumFilter<$PrismaModel>
  }

  export type NestedEnumRouteManagementStatusEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.RouteManagementStatusEnum | EnumRouteManagementStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.RouteManagementStatusEnum[] | ListEnumRouteManagementStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.RouteManagementStatusEnum[] | ListEnumRouteManagementStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumRouteManagementStatusEnumFilter<$PrismaModel> | $Enums.RouteManagementStatusEnum
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumRouteManagementStatusEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RouteManagementStatusEnum | EnumRouteManagementStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.RouteManagementStatusEnum[] | ListEnumRouteManagementStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.RouteManagementStatusEnum[] | ListEnumRouteManagementStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumRouteManagementStatusEnumWithAggregatesFilter<$PrismaModel> | $Enums.RouteManagementStatusEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRouteManagementStatusEnumFilter<$PrismaModel>
    _max?: NestedEnumRouteManagementStatusEnumFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumGenderEnumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.GenderEnum | EnumGenderEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.GenderEnum[] | ListEnumGenderEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.GenderEnum[] | ListEnumGenderEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderEnumNullableFilter<$PrismaModel> | $Enums.GenderEnum | null
  }

  export type NestedEnumVerificationStatusEnumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatusEnum | EnumVerificationStatusEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.VerificationStatusEnum[] | ListEnumVerificationStatusEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VerificationStatusEnum[] | ListEnumVerificationStatusEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVerificationStatusEnumNullableFilter<$PrismaModel> | $Enums.VerificationStatusEnum | null
  }

  export type NestedEnumGenderEnumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GenderEnum | EnumGenderEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.GenderEnum[] | ListEnumGenderEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.GenderEnum[] | ListEnumGenderEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderEnumNullableWithAggregatesFilter<$PrismaModel> | $Enums.GenderEnum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderEnumNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderEnumNullableFilter<$PrismaModel>
  }

  export type NestedEnumVerificationStatusEnumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatusEnum | EnumVerificationStatusEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.VerificationStatusEnum[] | ListEnumVerificationStatusEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VerificationStatusEnum[] | ListEnumVerificationStatusEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVerificationStatusEnumNullableWithAggregatesFilter<$PrismaModel> | $Enums.VerificationStatusEnum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumVerificationStatusEnumNullableFilter<$PrismaModel>
    _max?: NestedEnumVerificationStatusEnumNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumShiftLogTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.ShiftLogTypeEnum | EnumShiftLogTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ShiftLogTypeEnum[] | ListEnumShiftLogTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShiftLogTypeEnum[] | ListEnumShiftLogTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumShiftLogTypeEnumFilter<$PrismaModel> | $Enums.ShiftLogTypeEnum
  }

  export type NestedEnumPickupTypeEnumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PickupTypeEnum | EnumPickupTypeEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.PickupTypeEnum[] | ListEnumPickupTypeEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PickupTypeEnum[] | ListEnumPickupTypeEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPickupTypeEnumNullableFilter<$PrismaModel> | $Enums.PickupTypeEnum | null
  }

  export type NestedEnumShiftLogTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShiftLogTypeEnum | EnumShiftLogTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ShiftLogTypeEnum[] | ListEnumShiftLogTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShiftLogTypeEnum[] | ListEnumShiftLogTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumShiftLogTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.ShiftLogTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShiftLogTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumShiftLogTypeEnumFilter<$PrismaModel>
  }

  export type NestedEnumPickupTypeEnumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PickupTypeEnum | EnumPickupTypeEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.PickupTypeEnum[] | ListEnumPickupTypeEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PickupTypeEnum[] | ListEnumPickupTypeEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPickupTypeEnumNullableWithAggregatesFilter<$PrismaModel> | $Enums.PickupTypeEnum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPickupTypeEnumNullableFilter<$PrismaModel>
    _max?: NestedEnumPickupTypeEnumNullableFilter<$PrismaModel>
  }

  export type TenantCreateWithoutBookingsInput = {
    tenant_id: string
    name: string
    address?: string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    teams?: TeamCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    shifts?: ShiftCreateNestedManyWithoutTenantInput
    policies?: PolicyCreateNestedManyWithoutTenantInput
    cutoff?: CutoffCreateNestedOneWithoutTenantInput
    vendors?: VendorCreateNestedManyWithoutTenantInput
    roles?: RoleCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutBookingsInput = {
    tenant_id: string
    name: string
    address?: string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutTenantInput
    policies?: PolicyUncheckedCreateNestedManyWithoutTenantInput
    cutoff?: CutoffUncheckedCreateNestedOneWithoutTenantInput
    vendors?: VendorUncheckedCreateNestedManyWithoutTenantInput
    roles?: RoleUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutBookingsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutBookingsInput, TenantUncheckedCreateWithoutBookingsInput>
  }

  export type EmployeeCreateWithoutBookingsInput = {
    name: string
    employee_code: string
    email: string
    password: string
    phone: string
    alternate_phone?: string | null
    special_needs?: string | null
    special_needs_start_date?: Date | string | null
    special_needs_end_date?: Date | string | null
    address?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    gender?: $Enums.GenderEnum | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutEmployeesInput
    team?: TeamCreateNestedOneWithoutEmployeesInput
    role: RoleCreateNestedOneWithoutEmployeesInput
    weekoff_config?: WeekoffConfigCreateNestedOneWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutBookingsInput = {
    employee_id?: number
    tenant_id: string
    role_id: number
    name: string
    employee_code: string
    email: string
    password: string
    team_id?: number | null
    phone: string
    alternate_phone?: string | null
    special_needs?: string | null
    special_needs_start_date?: Date | string | null
    special_needs_end_date?: Date | string | null
    address?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    gender?: $Enums.GenderEnum | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    weekoff_config?: WeekoffConfigUncheckedCreateNestedOneWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutBookingsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutBookingsInput, EmployeeUncheckedCreateWithoutBookingsInput>
  }

  export type ShiftCreateWithoutBookingsInput = {
    shift_code: string
    log_type: $Enums.ShiftLogTypeEnum
    shift_time: Date | string
    pickup_type?: $Enums.PickupTypeEnum | null
    gender?: $Enums.GenderEnum | null
    waiting_time_minutes?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutShiftsInput
  }

  export type ShiftUncheckedCreateWithoutBookingsInput = {
    shift_id?: number
    tenant_id: string
    shift_code: string
    log_type: $Enums.ShiftLogTypeEnum
    shift_time: Date | string
    pickup_type?: $Enums.PickupTypeEnum | null
    gender?: $Enums.GenderEnum | null
    waiting_time_minutes?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ShiftCreateOrConnectWithoutBookingsInput = {
    where: ShiftWhereUniqueInput
    create: XOR<ShiftCreateWithoutBookingsInput, ShiftUncheckedCreateWithoutBookingsInput>
  }

  export type TeamCreateWithoutBookingsInput = {
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutTeamsInput
    employees?: EmployeeCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutBookingsInput = {
    team_id?: number
    tenant_id: string
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutBookingsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutBookingsInput, TeamUncheckedCreateWithoutBookingsInput>
  }

  export type TenantUpsertWithoutBookingsInput = {
    update: XOR<TenantUpdateWithoutBookingsInput, TenantUncheckedUpdateWithoutBookingsInput>
    create: XOR<TenantCreateWithoutBookingsInput, TenantUncheckedCreateWithoutBookingsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutBookingsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutBookingsInput, TenantUncheckedUpdateWithoutBookingsInput>
  }

  export type TenantUpdateWithoutBookingsInput = {
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    shifts?: ShiftUpdateManyWithoutTenantNestedInput
    policies?: PolicyUpdateManyWithoutTenantNestedInput
    cutoff?: CutoffUpdateOneWithoutTenantNestedInput
    vendors?: VendorUpdateManyWithoutTenantNestedInput
    roles?: RoleUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutBookingsInput = {
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutTenantNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutTenantNestedInput
    cutoff?: CutoffUncheckedUpdateOneWithoutTenantNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutTenantNestedInput
    roles?: RoleUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type EmployeeUpsertWithoutBookingsInput = {
    update: XOR<EmployeeUpdateWithoutBookingsInput, EmployeeUncheckedUpdateWithoutBookingsInput>
    create: XOR<EmployeeCreateWithoutBookingsInput, EmployeeUncheckedCreateWithoutBookingsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutBookingsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutBookingsInput, EmployeeUncheckedUpdateWithoutBookingsInput>
  }

  export type EmployeeUpdateWithoutBookingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    alternate_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    special_needs_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEmployeesNestedInput
    team?: TeamUpdateOneWithoutEmployeesNestedInput
    role?: RoleUpdateOneRequiredWithoutEmployeesNestedInput
    weekoff_config?: WeekoffConfigUpdateOneWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutBookingsInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    team_id?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: StringFieldUpdateOperationsInput | string
    alternate_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    special_needs_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    weekoff_config?: WeekoffConfigUncheckedUpdateOneWithoutEmployeeNestedInput
  }

  export type ShiftUpsertWithoutBookingsInput = {
    update: XOR<ShiftUpdateWithoutBookingsInput, ShiftUncheckedUpdateWithoutBookingsInput>
    create: XOR<ShiftCreateWithoutBookingsInput, ShiftUncheckedCreateWithoutBookingsInput>
    where?: ShiftWhereInput
  }

  export type ShiftUpdateToOneWithWhereWithoutBookingsInput = {
    where?: ShiftWhereInput
    data: XOR<ShiftUpdateWithoutBookingsInput, ShiftUncheckedUpdateWithoutBookingsInput>
  }

  export type ShiftUpdateWithoutBookingsInput = {
    shift_code?: StringFieldUpdateOperationsInput | string
    log_type?: EnumShiftLogTypeEnumFieldUpdateOperationsInput | $Enums.ShiftLogTypeEnum
    shift_time?: DateTimeFieldUpdateOperationsInput | Date | string
    pickup_type?: NullableEnumPickupTypeEnumFieldUpdateOperationsInput | $Enums.PickupTypeEnum | null
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    waiting_time_minutes?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutShiftsNestedInput
  }

  export type ShiftUncheckedUpdateWithoutBookingsInput = {
    shift_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    shift_code?: StringFieldUpdateOperationsInput | string
    log_type?: EnumShiftLogTypeEnumFieldUpdateOperationsInput | $Enums.ShiftLogTypeEnum
    shift_time?: DateTimeFieldUpdateOperationsInput | Date | string
    pickup_type?: NullableEnumPickupTypeEnumFieldUpdateOperationsInput | $Enums.PickupTypeEnum | null
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    waiting_time_minutes?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUpsertWithoutBookingsInput = {
    update: XOR<TeamUpdateWithoutBookingsInput, TeamUncheckedUpdateWithoutBookingsInput>
    create: XOR<TeamCreateWithoutBookingsInput, TeamUncheckedCreateWithoutBookingsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutBookingsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutBookingsInput, TeamUncheckedUpdateWithoutBookingsInput>
  }

  export type TeamUpdateWithoutBookingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTeamsNestedInput
    employees?: EmployeeUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutBookingsInput = {
    team_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type RouteManagementCreateWithoutRoute_management_bookingsInput = {
    route_id: string
    tenant_id: string
    shift_id?: number | null
    route_code: string
    status?: $Enums.RouteManagementStatusEnum
    planned_distance_km?: number | null
    planned_duration_minutes?: number | null
    actual_distance_km?: number | null
    actual_duration_minutes?: number | null
    actual_start_time?: Date | string | null
    actual_end_time?: Date | string | null
    optimized_polyline?: string | null
    assigned_vendor_id?: number | null
    assigned_vehicle_id?: number | null
    assigned_driver_id?: number | null
    total_distance_km?: number | null
    total_time_minutes?: number | null
    is_active?: boolean
    version?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RouteManagementUncheckedCreateWithoutRoute_management_bookingsInput = {
    route_id: string
    tenant_id: string
    shift_id?: number | null
    route_code: string
    status?: $Enums.RouteManagementStatusEnum
    planned_distance_km?: number | null
    planned_duration_minutes?: number | null
    actual_distance_km?: number | null
    actual_duration_minutes?: number | null
    actual_start_time?: Date | string | null
    actual_end_time?: Date | string | null
    optimized_polyline?: string | null
    assigned_vendor_id?: number | null
    assigned_vehicle_id?: number | null
    assigned_driver_id?: number | null
    total_distance_km?: number | null
    total_time_minutes?: number | null
    is_active?: boolean
    version?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RouteManagementCreateOrConnectWithoutRoute_management_bookingsInput = {
    where: RouteManagementWhereUniqueInput
    create: XOR<RouteManagementCreateWithoutRoute_management_bookingsInput, RouteManagementUncheckedCreateWithoutRoute_management_bookingsInput>
  }

  export type RouteManagementUpsertWithoutRoute_management_bookingsInput = {
    update: XOR<RouteManagementUpdateWithoutRoute_management_bookingsInput, RouteManagementUncheckedUpdateWithoutRoute_management_bookingsInput>
    create: XOR<RouteManagementCreateWithoutRoute_management_bookingsInput, RouteManagementUncheckedCreateWithoutRoute_management_bookingsInput>
    where?: RouteManagementWhereInput
  }

  export type RouteManagementUpdateToOneWithWhereWithoutRoute_management_bookingsInput = {
    where?: RouteManagementWhereInput
    data: XOR<RouteManagementUpdateWithoutRoute_management_bookingsInput, RouteManagementUncheckedUpdateWithoutRoute_management_bookingsInput>
  }

  export type RouteManagementUpdateWithoutRoute_management_bookingsInput = {
    route_id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    shift_id?: NullableIntFieldUpdateOperationsInput | number | null
    route_code?: StringFieldUpdateOperationsInput | string
    status?: EnumRouteManagementStatusEnumFieldUpdateOperationsInput | $Enums.RouteManagementStatusEnum
    planned_distance_km?: NullableFloatFieldUpdateOperationsInput | number | null
    planned_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    actual_distance_km?: NullableFloatFieldUpdateOperationsInput | number | null
    actual_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    actual_start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    optimized_polyline?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_vendor_id?: NullableIntFieldUpdateOperationsInput | number | null
    assigned_vehicle_id?: NullableIntFieldUpdateOperationsInput | number | null
    assigned_driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    total_distance_km?: NullableFloatFieldUpdateOperationsInput | number | null
    total_time_minutes?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteManagementUncheckedUpdateWithoutRoute_management_bookingsInput = {
    route_id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    shift_id?: NullableIntFieldUpdateOperationsInput | number | null
    route_code?: StringFieldUpdateOperationsInput | string
    status?: EnumRouteManagementStatusEnumFieldUpdateOperationsInput | $Enums.RouteManagementStatusEnum
    planned_distance_km?: NullableFloatFieldUpdateOperationsInput | number | null
    planned_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    actual_distance_km?: NullableFloatFieldUpdateOperationsInput | number | null
    actual_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    actual_start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    optimized_polyline?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_vendor_id?: NullableIntFieldUpdateOperationsInput | number | null
    assigned_vehicle_id?: NullableIntFieldUpdateOperationsInput | number | null
    assigned_driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    total_distance_km?: NullableFloatFieldUpdateOperationsInput | number | null
    total_time_minutes?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteManagementBookingCreateWithoutRoute_managementInput = {
    booking_id: number
    stop_order: number
    estimated_pickup_time?: string | null
    estimated_drop_time?: string | null
    distance_from_previous?: number | null
    cumulative_distance?: number | null
    created_at?: Date | string
  }

  export type RouteManagementBookingUncheckedCreateWithoutRoute_managementInput = {
    id?: number
    booking_id: number
    stop_order: number
    estimated_pickup_time?: string | null
    estimated_drop_time?: string | null
    distance_from_previous?: number | null
    cumulative_distance?: number | null
    created_at?: Date | string
  }

  export type RouteManagementBookingCreateOrConnectWithoutRoute_managementInput = {
    where: RouteManagementBookingWhereUniqueInput
    create: XOR<RouteManagementBookingCreateWithoutRoute_managementInput, RouteManagementBookingUncheckedCreateWithoutRoute_managementInput>
  }

  export type RouteManagementBookingCreateManyRoute_managementInputEnvelope = {
    data: RouteManagementBookingCreateManyRoute_managementInput | RouteManagementBookingCreateManyRoute_managementInput[]
    skipDuplicates?: boolean
  }

  export type RouteManagementBookingUpsertWithWhereUniqueWithoutRoute_managementInput = {
    where: RouteManagementBookingWhereUniqueInput
    update: XOR<RouteManagementBookingUpdateWithoutRoute_managementInput, RouteManagementBookingUncheckedUpdateWithoutRoute_managementInput>
    create: XOR<RouteManagementBookingCreateWithoutRoute_managementInput, RouteManagementBookingUncheckedCreateWithoutRoute_managementInput>
  }

  export type RouteManagementBookingUpdateWithWhereUniqueWithoutRoute_managementInput = {
    where: RouteManagementBookingWhereUniqueInput
    data: XOR<RouteManagementBookingUpdateWithoutRoute_managementInput, RouteManagementBookingUncheckedUpdateWithoutRoute_managementInput>
  }

  export type RouteManagementBookingUpdateManyWithWhereWithoutRoute_managementInput = {
    where: RouteManagementBookingScalarWhereInput
    data: XOR<RouteManagementBookingUpdateManyMutationInput, RouteManagementBookingUncheckedUpdateManyWithoutRoute_managementInput>
  }

  export type RouteManagementBookingScalarWhereInput = {
    AND?: RouteManagementBookingScalarWhereInput | RouteManagementBookingScalarWhereInput[]
    OR?: RouteManagementBookingScalarWhereInput[]
    NOT?: RouteManagementBookingScalarWhereInput | RouteManagementBookingScalarWhereInput[]
    id?: IntFilter<"RouteManagementBooking"> | number
    route_id?: StringFilter<"RouteManagementBooking"> | string
    booking_id?: IntFilter<"RouteManagementBooking"> | number
    stop_order?: IntFilter<"RouteManagementBooking"> | number
    estimated_pickup_time?: StringNullableFilter<"RouteManagementBooking"> | string | null
    estimated_drop_time?: StringNullableFilter<"RouteManagementBooking"> | string | null
    distance_from_previous?: FloatNullableFilter<"RouteManagementBooking"> | number | null
    cumulative_distance?: FloatNullableFilter<"RouteManagementBooking"> | number | null
    created_at?: DateTimeFilter<"RouteManagementBooking"> | Date | string
  }

  export type VendorCreateWithoutDriversInput = {
    name: string
    vendor_code: string
    email?: string | null
    phone?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutVendorsInput
    vehicle_types?: VehicleTypeCreateNestedManyWithoutVendorInput
    vehicles?: VehicleCreateNestedManyWithoutVendorInput
    vendor_users?: VendorUserCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutDriversInput = {
    vendor_id?: number
    tenant_id: string
    name: string
    vendor_code: string
    email?: string | null
    phone?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    vehicle_types?: VehicleTypeUncheckedCreateNestedManyWithoutVendorInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutVendorInput
    vendor_users?: VendorUserUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutDriversInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutDriversInput, VendorUncheckedCreateWithoutDriversInput>
  }

  export type VehicleCreateWithoutDriverInput = {
    rc_number: string
    rc_expiry_date?: Date | string | null
    description?: string | null
    puc_number?: string | null
    puc_expiry_date?: Date | string | null
    puc_url?: string | null
    fitness_number?: string | null
    fitness_expiry_date?: Date | string | null
    fitness_url?: string | null
    tax_receipt_number?: string | null
    tax_receipt_date?: Date | string | null
    tax_receipt_url?: string | null
    insurance_number?: string | null
    insurance_expiry_date?: Date | string | null
    insurance_url?: string | null
    permit_number?: string | null
    permit_expiry_date?: Date | string | null
    permit_url?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    vehicle_type: VehicleTypeCreateNestedOneWithoutVehiclesInput
    vendor: VendorCreateNestedOneWithoutVehiclesInput
  }

  export type VehicleUncheckedCreateWithoutDriverInput = {
    vehicle_id?: number
    vehicle_type_id: number
    vendor_id: number
    rc_number: string
    rc_expiry_date?: Date | string | null
    description?: string | null
    puc_number?: string | null
    puc_expiry_date?: Date | string | null
    puc_url?: string | null
    fitness_number?: string | null
    fitness_expiry_date?: Date | string | null
    fitness_url?: string | null
    tax_receipt_number?: string | null
    tax_receipt_date?: Date | string | null
    tax_receipt_url?: string | null
    insurance_number?: string | null
    insurance_expiry_date?: Date | string | null
    insurance_url?: string | null
    permit_number?: string | null
    permit_expiry_date?: Date | string | null
    permit_url?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VehicleCreateOrConnectWithoutDriverInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutDriverInput, VehicleUncheckedCreateWithoutDriverInput>
  }

  export type VehicleCreateManyDriverInputEnvelope = {
    data: VehicleCreateManyDriverInput | VehicleCreateManyDriverInput[]
    skipDuplicates?: boolean
  }

  export type VendorUpsertWithoutDriversInput = {
    update: XOR<VendorUpdateWithoutDriversInput, VendorUncheckedUpdateWithoutDriversInput>
    create: XOR<VendorCreateWithoutDriversInput, VendorUncheckedCreateWithoutDriversInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutDriversInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutDriversInput, VendorUncheckedUpdateWithoutDriversInput>
  }

  export type VendorUpdateWithoutDriversInput = {
    name?: StringFieldUpdateOperationsInput | string
    vendor_code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutVendorsNestedInput
    vehicle_types?: VehicleTypeUpdateManyWithoutVendorNestedInput
    vehicles?: VehicleUpdateManyWithoutVendorNestedInput
    vendor_users?: VendorUserUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutDriversInput = {
    vendor_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vendor_code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle_types?: VehicleTypeUncheckedUpdateManyWithoutVendorNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutVendorNestedInput
    vendor_users?: VendorUserUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VehicleUpsertWithWhereUniqueWithoutDriverInput = {
    where: VehicleWhereUniqueInput
    update: XOR<VehicleUpdateWithoutDriverInput, VehicleUncheckedUpdateWithoutDriverInput>
    create: XOR<VehicleCreateWithoutDriverInput, VehicleUncheckedCreateWithoutDriverInput>
  }

  export type VehicleUpdateWithWhereUniqueWithoutDriverInput = {
    where: VehicleWhereUniqueInput
    data: XOR<VehicleUpdateWithoutDriverInput, VehicleUncheckedUpdateWithoutDriverInput>
  }

  export type VehicleUpdateManyWithWhereWithoutDriverInput = {
    where: VehicleScalarWhereInput
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyWithoutDriverInput>
  }

  export type VehicleScalarWhereInput = {
    AND?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
    OR?: VehicleScalarWhereInput[]
    NOT?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
    vehicle_id?: IntFilter<"Vehicle"> | number
    vehicle_type_id?: IntFilter<"Vehicle"> | number
    vendor_id?: IntFilter<"Vehicle"> | number
    driver_id?: IntNullableFilter<"Vehicle"> | number | null
    rc_number?: StringFilter<"Vehicle"> | string
    rc_expiry_date?: DateTimeNullableFilter<"Vehicle"> | Date | string | null
    description?: StringNullableFilter<"Vehicle"> | string | null
    puc_number?: StringNullableFilter<"Vehicle"> | string | null
    puc_expiry_date?: DateTimeNullableFilter<"Vehicle"> | Date | string | null
    puc_url?: StringNullableFilter<"Vehicle"> | string | null
    fitness_number?: StringNullableFilter<"Vehicle"> | string | null
    fitness_expiry_date?: DateTimeNullableFilter<"Vehicle"> | Date | string | null
    fitness_url?: StringNullableFilter<"Vehicle"> | string | null
    tax_receipt_number?: StringNullableFilter<"Vehicle"> | string | null
    tax_receipt_date?: DateTimeNullableFilter<"Vehicle"> | Date | string | null
    tax_receipt_url?: StringNullableFilter<"Vehicle"> | string | null
    insurance_number?: StringNullableFilter<"Vehicle"> | string | null
    insurance_expiry_date?: DateTimeNullableFilter<"Vehicle"> | Date | string | null
    insurance_url?: StringNullableFilter<"Vehicle"> | string | null
    permit_number?: StringNullableFilter<"Vehicle"> | string | null
    permit_expiry_date?: DateTimeNullableFilter<"Vehicle"> | Date | string | null
    permit_url?: StringNullableFilter<"Vehicle"> | string | null
    is_active?: BoolFilter<"Vehicle"> | boolean
    created_at?: DateTimeFilter<"Vehicle"> | Date | string
    updated_at?: DateTimeFilter<"Vehicle"> | Date | string
  }

  export type VehicleTypeCreateWithoutVehiclesInput = {
    name: string
    description?: string | null
    seats: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    vendor: VendorCreateNestedOneWithoutVehicle_typesInput
  }

  export type VehicleTypeUncheckedCreateWithoutVehiclesInput = {
    vehicle_type_id?: number
    vendor_id: number
    name: string
    description?: string | null
    seats: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VehicleTypeCreateOrConnectWithoutVehiclesInput = {
    where: VehicleTypeWhereUniqueInput
    create: XOR<VehicleTypeCreateWithoutVehiclesInput, VehicleTypeUncheckedCreateWithoutVehiclesInput>
  }

  export type VendorCreateWithoutVehiclesInput = {
    name: string
    vendor_code: string
    email?: string | null
    phone?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutVendorsInput
    drivers?: DriverCreateNestedManyWithoutVendorInput
    vehicle_types?: VehicleTypeCreateNestedManyWithoutVendorInput
    vendor_users?: VendorUserCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutVehiclesInput = {
    vendor_id?: number
    tenant_id: string
    name: string
    vendor_code: string
    email?: string | null
    phone?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    drivers?: DriverUncheckedCreateNestedManyWithoutVendorInput
    vehicle_types?: VehicleTypeUncheckedCreateNestedManyWithoutVendorInput
    vendor_users?: VendorUserUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutVehiclesInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutVehiclesInput, VendorUncheckedCreateWithoutVehiclesInput>
  }

  export type DriverCreateWithoutVehiclesInput = {
    name: string
    code: string
    email: string
    phone: string
    gender?: $Enums.GenderEnum | null
    password: string
    date_of_birth?: Date | string | null
    date_of_joining?: Date | string | null
    permanent_address?: string | null
    current_address?: string | null
    photo_url?: string | null
    bg_verify_status?: $Enums.VerificationStatusEnum | null
    bg_expiry_date?: Date | string | null
    bg_verify_url?: string | null
    police_verify_status?: $Enums.VerificationStatusEnum | null
    police_expiry_date?: Date | string | null
    police_verify_url?: string | null
    medical_verify_status?: $Enums.VerificationStatusEnum | null
    medical_expiry_date?: Date | string | null
    medical_verify_url?: string | null
    training_verify_status?: $Enums.VerificationStatusEnum | null
    training_expiry_date?: Date | string | null
    training_verify_url?: string | null
    eye_verify_status?: $Enums.VerificationStatusEnum | null
    eye_expiry_date?: Date | string | null
    eye_verify_url?: string | null
    license_number?: string | null
    license_expiry_date?: Date | string | null
    license_url?: string | null
    badge_number?: string | null
    badge_expiry_date?: Date | string | null
    badge_url?: string | null
    alt_govt_id_number?: string | null
    alt_govt_id_type?: string | null
    alt_govt_id_url?: string | null
    induction_date?: Date | string | null
    induction_url?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    vendor: VendorCreateNestedOneWithoutDriversInput
  }

  export type DriverUncheckedCreateWithoutVehiclesInput = {
    driver_id?: number
    vendor_id: number
    name: string
    code: string
    email: string
    phone: string
    gender?: $Enums.GenderEnum | null
    password: string
    date_of_birth?: Date | string | null
    date_of_joining?: Date | string | null
    permanent_address?: string | null
    current_address?: string | null
    photo_url?: string | null
    bg_verify_status?: $Enums.VerificationStatusEnum | null
    bg_expiry_date?: Date | string | null
    bg_verify_url?: string | null
    police_verify_status?: $Enums.VerificationStatusEnum | null
    police_expiry_date?: Date | string | null
    police_verify_url?: string | null
    medical_verify_status?: $Enums.VerificationStatusEnum | null
    medical_expiry_date?: Date | string | null
    medical_verify_url?: string | null
    training_verify_status?: $Enums.VerificationStatusEnum | null
    training_expiry_date?: Date | string | null
    training_verify_url?: string | null
    eye_verify_status?: $Enums.VerificationStatusEnum | null
    eye_expiry_date?: Date | string | null
    eye_verify_url?: string | null
    license_number?: string | null
    license_expiry_date?: Date | string | null
    license_url?: string | null
    badge_number?: string | null
    badge_expiry_date?: Date | string | null
    badge_url?: string | null
    alt_govt_id_number?: string | null
    alt_govt_id_type?: string | null
    alt_govt_id_url?: string | null
    induction_date?: Date | string | null
    induction_url?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DriverCreateOrConnectWithoutVehiclesInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutVehiclesInput, DriverUncheckedCreateWithoutVehiclesInput>
  }

  export type VehicleTypeUpsertWithoutVehiclesInput = {
    update: XOR<VehicleTypeUpdateWithoutVehiclesInput, VehicleTypeUncheckedUpdateWithoutVehiclesInput>
    create: XOR<VehicleTypeCreateWithoutVehiclesInput, VehicleTypeUncheckedCreateWithoutVehiclesInput>
    where?: VehicleTypeWhereInput
  }

  export type VehicleTypeUpdateToOneWithWhereWithoutVehiclesInput = {
    where?: VehicleTypeWhereInput
    data: XOR<VehicleTypeUpdateWithoutVehiclesInput, VehicleTypeUncheckedUpdateWithoutVehiclesInput>
  }

  export type VehicleTypeUpdateWithoutVehiclesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutVehicle_typesNestedInput
  }

  export type VehicleTypeUncheckedUpdateWithoutVehiclesInput = {
    vehicle_type_id?: IntFieldUpdateOperationsInput | number
    vendor_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUpsertWithoutVehiclesInput = {
    update: XOR<VendorUpdateWithoutVehiclesInput, VendorUncheckedUpdateWithoutVehiclesInput>
    create: XOR<VendorCreateWithoutVehiclesInput, VendorUncheckedCreateWithoutVehiclesInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutVehiclesInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutVehiclesInput, VendorUncheckedUpdateWithoutVehiclesInput>
  }

  export type VendorUpdateWithoutVehiclesInput = {
    name?: StringFieldUpdateOperationsInput | string
    vendor_code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutVendorsNestedInput
    drivers?: DriverUpdateManyWithoutVendorNestedInput
    vehicle_types?: VehicleTypeUpdateManyWithoutVendorNestedInput
    vendor_users?: VendorUserUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutVehiclesInput = {
    vendor_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vendor_code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    drivers?: DriverUncheckedUpdateManyWithoutVendorNestedInput
    vehicle_types?: VehicleTypeUncheckedUpdateManyWithoutVendorNestedInput
    vendor_users?: VendorUserUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type DriverUpsertWithoutVehiclesInput = {
    update: XOR<DriverUpdateWithoutVehiclesInput, DriverUncheckedUpdateWithoutVehiclesInput>
    create: XOR<DriverCreateWithoutVehiclesInput, DriverUncheckedCreateWithoutVehiclesInput>
    where?: DriverWhereInput
  }

  export type DriverUpdateToOneWithWhereWithoutVehiclesInput = {
    where?: DriverWhereInput
    data: XOR<DriverUpdateWithoutVehiclesInput, DriverUncheckedUpdateWithoutVehiclesInput>
  }

  export type DriverUpdateWithoutVehiclesInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    password?: StringFieldUpdateOperationsInput | string
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_of_joining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permanent_address?: NullableStringFieldUpdateOperationsInput | string | null
    current_address?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    bg_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    bg_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bg_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    police_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    police_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    police_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    medical_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    medical_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medical_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    training_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    training_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    training_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    eye_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    eye_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eye_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    license_number?: NullableStringFieldUpdateOperationsInput | string | null
    license_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    license_url?: NullableStringFieldUpdateOperationsInput | string | null
    badge_number?: NullableStringFieldUpdateOperationsInput | string | null
    badge_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge_url?: NullableStringFieldUpdateOperationsInput | string | null
    alt_govt_id_number?: NullableStringFieldUpdateOperationsInput | string | null
    alt_govt_id_type?: NullableStringFieldUpdateOperationsInput | string | null
    alt_govt_id_url?: NullableStringFieldUpdateOperationsInput | string | null
    induction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    induction_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutDriversNestedInput
  }

  export type DriverUncheckedUpdateWithoutVehiclesInput = {
    driver_id?: IntFieldUpdateOperationsInput | number
    vendor_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    password?: StringFieldUpdateOperationsInput | string
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_of_joining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permanent_address?: NullableStringFieldUpdateOperationsInput | string | null
    current_address?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    bg_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    bg_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bg_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    police_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    police_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    police_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    medical_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    medical_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medical_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    training_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    training_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    training_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    eye_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    eye_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eye_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    license_number?: NullableStringFieldUpdateOperationsInput | string | null
    license_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    license_url?: NullableStringFieldUpdateOperationsInput | string | null
    badge_number?: NullableStringFieldUpdateOperationsInput | string | null
    badge_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge_url?: NullableStringFieldUpdateOperationsInput | string | null
    alt_govt_id_number?: NullableStringFieldUpdateOperationsInput | string | null
    alt_govt_id_type?: NullableStringFieldUpdateOperationsInput | string | null
    alt_govt_id_url?: NullableStringFieldUpdateOperationsInput | string | null
    induction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    induction_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorCreateWithoutVehicle_typesInput = {
    name: string
    vendor_code: string
    email?: string | null
    phone?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutVendorsInput
    drivers?: DriverCreateNestedManyWithoutVendorInput
    vehicles?: VehicleCreateNestedManyWithoutVendorInput
    vendor_users?: VendorUserCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutVehicle_typesInput = {
    vendor_id?: number
    tenant_id: string
    name: string
    vendor_code: string
    email?: string | null
    phone?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    drivers?: DriverUncheckedCreateNestedManyWithoutVendorInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutVendorInput
    vendor_users?: VendorUserUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutVehicle_typesInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutVehicle_typesInput, VendorUncheckedCreateWithoutVehicle_typesInput>
  }

  export type VehicleCreateWithoutVehicle_typeInput = {
    rc_number: string
    rc_expiry_date?: Date | string | null
    description?: string | null
    puc_number?: string | null
    puc_expiry_date?: Date | string | null
    puc_url?: string | null
    fitness_number?: string | null
    fitness_expiry_date?: Date | string | null
    fitness_url?: string | null
    tax_receipt_number?: string | null
    tax_receipt_date?: Date | string | null
    tax_receipt_url?: string | null
    insurance_number?: string | null
    insurance_expiry_date?: Date | string | null
    insurance_url?: string | null
    permit_number?: string | null
    permit_expiry_date?: Date | string | null
    permit_url?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    vendor: VendorCreateNestedOneWithoutVehiclesInput
    driver?: DriverCreateNestedOneWithoutVehiclesInput
  }

  export type VehicleUncheckedCreateWithoutVehicle_typeInput = {
    vehicle_id?: number
    vendor_id: number
    driver_id?: number | null
    rc_number: string
    rc_expiry_date?: Date | string | null
    description?: string | null
    puc_number?: string | null
    puc_expiry_date?: Date | string | null
    puc_url?: string | null
    fitness_number?: string | null
    fitness_expiry_date?: Date | string | null
    fitness_url?: string | null
    tax_receipt_number?: string | null
    tax_receipt_date?: Date | string | null
    tax_receipt_url?: string | null
    insurance_number?: string | null
    insurance_expiry_date?: Date | string | null
    insurance_url?: string | null
    permit_number?: string | null
    permit_expiry_date?: Date | string | null
    permit_url?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VehicleCreateOrConnectWithoutVehicle_typeInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutVehicle_typeInput, VehicleUncheckedCreateWithoutVehicle_typeInput>
  }

  export type VehicleCreateManyVehicle_typeInputEnvelope = {
    data: VehicleCreateManyVehicle_typeInput | VehicleCreateManyVehicle_typeInput[]
    skipDuplicates?: boolean
  }

  export type VendorUpsertWithoutVehicle_typesInput = {
    update: XOR<VendorUpdateWithoutVehicle_typesInput, VendorUncheckedUpdateWithoutVehicle_typesInput>
    create: XOR<VendorCreateWithoutVehicle_typesInput, VendorUncheckedCreateWithoutVehicle_typesInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutVehicle_typesInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutVehicle_typesInput, VendorUncheckedUpdateWithoutVehicle_typesInput>
  }

  export type VendorUpdateWithoutVehicle_typesInput = {
    name?: StringFieldUpdateOperationsInput | string
    vendor_code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutVendorsNestedInput
    drivers?: DriverUpdateManyWithoutVendorNestedInput
    vehicles?: VehicleUpdateManyWithoutVendorNestedInput
    vendor_users?: VendorUserUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutVehicle_typesInput = {
    vendor_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vendor_code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    drivers?: DriverUncheckedUpdateManyWithoutVendorNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutVendorNestedInput
    vendor_users?: VendorUserUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VehicleUpsertWithWhereUniqueWithoutVehicle_typeInput = {
    where: VehicleWhereUniqueInput
    update: XOR<VehicleUpdateWithoutVehicle_typeInput, VehicleUncheckedUpdateWithoutVehicle_typeInput>
    create: XOR<VehicleCreateWithoutVehicle_typeInput, VehicleUncheckedCreateWithoutVehicle_typeInput>
  }

  export type VehicleUpdateWithWhereUniqueWithoutVehicle_typeInput = {
    where: VehicleWhereUniqueInput
    data: XOR<VehicleUpdateWithoutVehicle_typeInput, VehicleUncheckedUpdateWithoutVehicle_typeInput>
  }

  export type VehicleUpdateManyWithWhereWithoutVehicle_typeInput = {
    where: VehicleScalarWhereInput
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyWithoutVehicle_typeInput>
  }

  export type TenantCreateWithoutVendorsInput = {
    tenant_id: string
    name: string
    address?: string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    teams?: TeamCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    shifts?: ShiftCreateNestedManyWithoutTenantInput
    bookings?: BookingCreateNestedManyWithoutTenantInput
    policies?: PolicyCreateNestedManyWithoutTenantInput
    cutoff?: CutoffCreateNestedOneWithoutTenantInput
    roles?: RoleCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutVendorsInput = {
    tenant_id: string
    name: string
    address?: string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutTenantInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTenantInput
    policies?: PolicyUncheckedCreateNestedManyWithoutTenantInput
    cutoff?: CutoffUncheckedCreateNestedOneWithoutTenantInput
    roles?: RoleUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutVendorsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutVendorsInput, TenantUncheckedCreateWithoutVendorsInput>
  }

  export type DriverCreateWithoutVendorInput = {
    name: string
    code: string
    email: string
    phone: string
    gender?: $Enums.GenderEnum | null
    password: string
    date_of_birth?: Date | string | null
    date_of_joining?: Date | string | null
    permanent_address?: string | null
    current_address?: string | null
    photo_url?: string | null
    bg_verify_status?: $Enums.VerificationStatusEnum | null
    bg_expiry_date?: Date | string | null
    bg_verify_url?: string | null
    police_verify_status?: $Enums.VerificationStatusEnum | null
    police_expiry_date?: Date | string | null
    police_verify_url?: string | null
    medical_verify_status?: $Enums.VerificationStatusEnum | null
    medical_expiry_date?: Date | string | null
    medical_verify_url?: string | null
    training_verify_status?: $Enums.VerificationStatusEnum | null
    training_expiry_date?: Date | string | null
    training_verify_url?: string | null
    eye_verify_status?: $Enums.VerificationStatusEnum | null
    eye_expiry_date?: Date | string | null
    eye_verify_url?: string | null
    license_number?: string | null
    license_expiry_date?: Date | string | null
    license_url?: string | null
    badge_number?: string | null
    badge_expiry_date?: Date | string | null
    badge_url?: string | null
    alt_govt_id_number?: string | null
    alt_govt_id_type?: string | null
    alt_govt_id_url?: string | null
    induction_date?: Date | string | null
    induction_url?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    vehicles?: VehicleCreateNestedManyWithoutDriverInput
  }

  export type DriverUncheckedCreateWithoutVendorInput = {
    driver_id?: number
    name: string
    code: string
    email: string
    phone: string
    gender?: $Enums.GenderEnum | null
    password: string
    date_of_birth?: Date | string | null
    date_of_joining?: Date | string | null
    permanent_address?: string | null
    current_address?: string | null
    photo_url?: string | null
    bg_verify_status?: $Enums.VerificationStatusEnum | null
    bg_expiry_date?: Date | string | null
    bg_verify_url?: string | null
    police_verify_status?: $Enums.VerificationStatusEnum | null
    police_expiry_date?: Date | string | null
    police_verify_url?: string | null
    medical_verify_status?: $Enums.VerificationStatusEnum | null
    medical_expiry_date?: Date | string | null
    medical_verify_url?: string | null
    training_verify_status?: $Enums.VerificationStatusEnum | null
    training_expiry_date?: Date | string | null
    training_verify_url?: string | null
    eye_verify_status?: $Enums.VerificationStatusEnum | null
    eye_expiry_date?: Date | string | null
    eye_verify_url?: string | null
    license_number?: string | null
    license_expiry_date?: Date | string | null
    license_url?: string | null
    badge_number?: string | null
    badge_expiry_date?: Date | string | null
    badge_url?: string | null
    alt_govt_id_number?: string | null
    alt_govt_id_type?: string | null
    alt_govt_id_url?: string | null
    induction_date?: Date | string | null
    induction_url?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    vehicles?: VehicleUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverCreateOrConnectWithoutVendorInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutVendorInput, DriverUncheckedCreateWithoutVendorInput>
  }

  export type DriverCreateManyVendorInputEnvelope = {
    data: DriverCreateManyVendorInput | DriverCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type VehicleTypeCreateWithoutVendorInput = {
    name: string
    description?: string | null
    seats: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    vehicles?: VehicleCreateNestedManyWithoutVehicle_typeInput
  }

  export type VehicleTypeUncheckedCreateWithoutVendorInput = {
    vehicle_type_id?: number
    name: string
    description?: string | null
    seats: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    vehicles?: VehicleUncheckedCreateNestedManyWithoutVehicle_typeInput
  }

  export type VehicleTypeCreateOrConnectWithoutVendorInput = {
    where: VehicleTypeWhereUniqueInput
    create: XOR<VehicleTypeCreateWithoutVendorInput, VehicleTypeUncheckedCreateWithoutVendorInput>
  }

  export type VehicleTypeCreateManyVendorInputEnvelope = {
    data: VehicleTypeCreateManyVendorInput | VehicleTypeCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type VehicleCreateWithoutVendorInput = {
    rc_number: string
    rc_expiry_date?: Date | string | null
    description?: string | null
    puc_number?: string | null
    puc_expiry_date?: Date | string | null
    puc_url?: string | null
    fitness_number?: string | null
    fitness_expiry_date?: Date | string | null
    fitness_url?: string | null
    tax_receipt_number?: string | null
    tax_receipt_date?: Date | string | null
    tax_receipt_url?: string | null
    insurance_number?: string | null
    insurance_expiry_date?: Date | string | null
    insurance_url?: string | null
    permit_number?: string | null
    permit_expiry_date?: Date | string | null
    permit_url?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    vehicle_type: VehicleTypeCreateNestedOneWithoutVehiclesInput
    driver?: DriverCreateNestedOneWithoutVehiclesInput
  }

  export type VehicleUncheckedCreateWithoutVendorInput = {
    vehicle_id?: number
    vehicle_type_id: number
    driver_id?: number | null
    rc_number: string
    rc_expiry_date?: Date | string | null
    description?: string | null
    puc_number?: string | null
    puc_expiry_date?: Date | string | null
    puc_url?: string | null
    fitness_number?: string | null
    fitness_expiry_date?: Date | string | null
    fitness_url?: string | null
    tax_receipt_number?: string | null
    tax_receipt_date?: Date | string | null
    tax_receipt_url?: string | null
    insurance_number?: string | null
    insurance_expiry_date?: Date | string | null
    insurance_url?: string | null
    permit_number?: string | null
    permit_expiry_date?: Date | string | null
    permit_url?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VehicleCreateOrConnectWithoutVendorInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutVendorInput, VehicleUncheckedCreateWithoutVendorInput>
  }

  export type VehicleCreateManyVendorInputEnvelope = {
    data: VehicleCreateManyVendorInput | VehicleCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type VendorUserCreateWithoutVendorInput = {
    tenant_id: string
    name: string
    email: string
    phone: string
    password: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    role: RoleCreateNestedOneWithoutVendor_usersInput
  }

  export type VendorUserUncheckedCreateWithoutVendorInput = {
    vendor_user_id?: number
    tenant_id: string
    name: string
    email: string
    phone: string
    password: string
    role_id: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorUserCreateOrConnectWithoutVendorInput = {
    where: VendorUserWhereUniqueInput
    create: XOR<VendorUserCreateWithoutVendorInput, VendorUserUncheckedCreateWithoutVendorInput>
  }

  export type VendorUserCreateManyVendorInputEnvelope = {
    data: VendorUserCreateManyVendorInput | VendorUserCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutVendorsInput = {
    update: XOR<TenantUpdateWithoutVendorsInput, TenantUncheckedUpdateWithoutVendorsInput>
    create: XOR<TenantCreateWithoutVendorsInput, TenantUncheckedCreateWithoutVendorsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutVendorsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutVendorsInput, TenantUncheckedUpdateWithoutVendorsInput>
  }

  export type TenantUpdateWithoutVendorsInput = {
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    shifts?: ShiftUpdateManyWithoutTenantNestedInput
    bookings?: BookingUpdateManyWithoutTenantNestedInput
    policies?: PolicyUpdateManyWithoutTenantNestedInput
    cutoff?: CutoffUpdateOneWithoutTenantNestedInput
    roles?: RoleUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutVendorsInput = {
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutTenantNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTenantNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutTenantNestedInput
    cutoff?: CutoffUncheckedUpdateOneWithoutTenantNestedInput
    roles?: RoleUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type DriverUpsertWithWhereUniqueWithoutVendorInput = {
    where: DriverWhereUniqueInput
    update: XOR<DriverUpdateWithoutVendorInput, DriverUncheckedUpdateWithoutVendorInput>
    create: XOR<DriverCreateWithoutVendorInput, DriverUncheckedCreateWithoutVendorInput>
  }

  export type DriverUpdateWithWhereUniqueWithoutVendorInput = {
    where: DriverWhereUniqueInput
    data: XOR<DriverUpdateWithoutVendorInput, DriverUncheckedUpdateWithoutVendorInput>
  }

  export type DriverUpdateManyWithWhereWithoutVendorInput = {
    where: DriverScalarWhereInput
    data: XOR<DriverUpdateManyMutationInput, DriverUncheckedUpdateManyWithoutVendorInput>
  }

  export type DriverScalarWhereInput = {
    AND?: DriverScalarWhereInput | DriverScalarWhereInput[]
    OR?: DriverScalarWhereInput[]
    NOT?: DriverScalarWhereInput | DriverScalarWhereInput[]
    driver_id?: IntFilter<"Driver"> | number
    vendor_id?: IntFilter<"Driver"> | number
    name?: StringFilter<"Driver"> | string
    code?: StringFilter<"Driver"> | string
    email?: StringFilter<"Driver"> | string
    phone?: StringFilter<"Driver"> | string
    gender?: EnumGenderEnumNullableFilter<"Driver"> | $Enums.GenderEnum | null
    password?: StringFilter<"Driver"> | string
    date_of_birth?: DateTimeNullableFilter<"Driver"> | Date | string | null
    date_of_joining?: DateTimeNullableFilter<"Driver"> | Date | string | null
    permanent_address?: StringNullableFilter<"Driver"> | string | null
    current_address?: StringNullableFilter<"Driver"> | string | null
    photo_url?: StringNullableFilter<"Driver"> | string | null
    bg_verify_status?: EnumVerificationStatusEnumNullableFilter<"Driver"> | $Enums.VerificationStatusEnum | null
    bg_expiry_date?: DateTimeNullableFilter<"Driver"> | Date | string | null
    bg_verify_url?: StringNullableFilter<"Driver"> | string | null
    police_verify_status?: EnumVerificationStatusEnumNullableFilter<"Driver"> | $Enums.VerificationStatusEnum | null
    police_expiry_date?: DateTimeNullableFilter<"Driver"> | Date | string | null
    police_verify_url?: StringNullableFilter<"Driver"> | string | null
    medical_verify_status?: EnumVerificationStatusEnumNullableFilter<"Driver"> | $Enums.VerificationStatusEnum | null
    medical_expiry_date?: DateTimeNullableFilter<"Driver"> | Date | string | null
    medical_verify_url?: StringNullableFilter<"Driver"> | string | null
    training_verify_status?: EnumVerificationStatusEnumNullableFilter<"Driver"> | $Enums.VerificationStatusEnum | null
    training_expiry_date?: DateTimeNullableFilter<"Driver"> | Date | string | null
    training_verify_url?: StringNullableFilter<"Driver"> | string | null
    eye_verify_status?: EnumVerificationStatusEnumNullableFilter<"Driver"> | $Enums.VerificationStatusEnum | null
    eye_expiry_date?: DateTimeNullableFilter<"Driver"> | Date | string | null
    eye_verify_url?: StringNullableFilter<"Driver"> | string | null
    license_number?: StringNullableFilter<"Driver"> | string | null
    license_expiry_date?: DateTimeNullableFilter<"Driver"> | Date | string | null
    license_url?: StringNullableFilter<"Driver"> | string | null
    badge_number?: StringNullableFilter<"Driver"> | string | null
    badge_expiry_date?: DateTimeNullableFilter<"Driver"> | Date | string | null
    badge_url?: StringNullableFilter<"Driver"> | string | null
    alt_govt_id_number?: StringNullableFilter<"Driver"> | string | null
    alt_govt_id_type?: StringNullableFilter<"Driver"> | string | null
    alt_govt_id_url?: StringNullableFilter<"Driver"> | string | null
    induction_date?: DateTimeNullableFilter<"Driver"> | Date | string | null
    induction_url?: StringNullableFilter<"Driver"> | string | null
    is_active?: BoolFilter<"Driver"> | boolean
    created_at?: DateTimeFilter<"Driver"> | Date | string
    updated_at?: DateTimeFilter<"Driver"> | Date | string
  }

  export type VehicleTypeUpsertWithWhereUniqueWithoutVendorInput = {
    where: VehicleTypeWhereUniqueInput
    update: XOR<VehicleTypeUpdateWithoutVendorInput, VehicleTypeUncheckedUpdateWithoutVendorInput>
    create: XOR<VehicleTypeCreateWithoutVendorInput, VehicleTypeUncheckedCreateWithoutVendorInput>
  }

  export type VehicleTypeUpdateWithWhereUniqueWithoutVendorInput = {
    where: VehicleTypeWhereUniqueInput
    data: XOR<VehicleTypeUpdateWithoutVendorInput, VehicleTypeUncheckedUpdateWithoutVendorInput>
  }

  export type VehicleTypeUpdateManyWithWhereWithoutVendorInput = {
    where: VehicleTypeScalarWhereInput
    data: XOR<VehicleTypeUpdateManyMutationInput, VehicleTypeUncheckedUpdateManyWithoutVendorInput>
  }

  export type VehicleTypeScalarWhereInput = {
    AND?: VehicleTypeScalarWhereInput | VehicleTypeScalarWhereInput[]
    OR?: VehicleTypeScalarWhereInput[]
    NOT?: VehicleTypeScalarWhereInput | VehicleTypeScalarWhereInput[]
    vehicle_type_id?: IntFilter<"VehicleType"> | number
    vendor_id?: IntFilter<"VehicleType"> | number
    name?: StringFilter<"VehicleType"> | string
    description?: StringNullableFilter<"VehicleType"> | string | null
    seats?: IntFilter<"VehicleType"> | number
    is_active?: BoolFilter<"VehicleType"> | boolean
    created_at?: DateTimeFilter<"VehicleType"> | Date | string
    updated_at?: DateTimeFilter<"VehicleType"> | Date | string
  }

  export type VehicleUpsertWithWhereUniqueWithoutVendorInput = {
    where: VehicleWhereUniqueInput
    update: XOR<VehicleUpdateWithoutVendorInput, VehicleUncheckedUpdateWithoutVendorInput>
    create: XOR<VehicleCreateWithoutVendorInput, VehicleUncheckedCreateWithoutVendorInput>
  }

  export type VehicleUpdateWithWhereUniqueWithoutVendorInput = {
    where: VehicleWhereUniqueInput
    data: XOR<VehicleUpdateWithoutVendorInput, VehicleUncheckedUpdateWithoutVendorInput>
  }

  export type VehicleUpdateManyWithWhereWithoutVendorInput = {
    where: VehicleScalarWhereInput
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyWithoutVendorInput>
  }

  export type VendorUserUpsertWithWhereUniqueWithoutVendorInput = {
    where: VendorUserWhereUniqueInput
    update: XOR<VendorUserUpdateWithoutVendorInput, VendorUserUncheckedUpdateWithoutVendorInput>
    create: XOR<VendorUserCreateWithoutVendorInput, VendorUserUncheckedCreateWithoutVendorInput>
  }

  export type VendorUserUpdateWithWhereUniqueWithoutVendorInput = {
    where: VendorUserWhereUniqueInput
    data: XOR<VendorUserUpdateWithoutVendorInput, VendorUserUncheckedUpdateWithoutVendorInput>
  }

  export type VendorUserUpdateManyWithWhereWithoutVendorInput = {
    where: VendorUserScalarWhereInput
    data: XOR<VendorUserUpdateManyMutationInput, VendorUserUncheckedUpdateManyWithoutVendorInput>
  }

  export type VendorUserScalarWhereInput = {
    AND?: VendorUserScalarWhereInput | VendorUserScalarWhereInput[]
    OR?: VendorUserScalarWhereInput[]
    NOT?: VendorUserScalarWhereInput | VendorUserScalarWhereInput[]
    vendor_user_id?: IntFilter<"VendorUser"> | number
    tenant_id?: StringFilter<"VendorUser"> | string
    vendor_id?: IntFilter<"VendorUser"> | number
    name?: StringFilter<"VendorUser"> | string
    email?: StringFilter<"VendorUser"> | string
    phone?: StringFilter<"VendorUser"> | string
    password?: StringFilter<"VendorUser"> | string
    role_id?: IntFilter<"VendorUser"> | number
    is_active?: BoolFilter<"VendorUser"> | boolean
    created_at?: DateTimeFilter<"VendorUser"> | Date | string
    updated_at?: DateTimeFilter<"VendorUser"> | Date | string
  }

  export type VendorCreateWithoutVendor_usersInput = {
    name: string
    vendor_code: string
    email?: string | null
    phone?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutVendorsInput
    drivers?: DriverCreateNestedManyWithoutVendorInput
    vehicle_types?: VehicleTypeCreateNestedManyWithoutVendorInput
    vehicles?: VehicleCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutVendor_usersInput = {
    vendor_id?: number
    tenant_id: string
    name: string
    vendor_code: string
    email?: string | null
    phone?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    drivers?: DriverUncheckedCreateNestedManyWithoutVendorInput
    vehicle_types?: VehicleTypeUncheckedCreateNestedManyWithoutVendorInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutVendor_usersInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutVendor_usersInput, VendorUncheckedCreateWithoutVendor_usersInput>
  }

  export type RoleCreateWithoutVendor_usersInput = {
    name: string
    description?: string | null
    is_active?: boolean
    is_system_role?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    tenant?: TenantCreateNestedOneWithoutRolesInput
    role_policies?: RolePolicyCreateNestedManyWithoutRoleInput
    admins?: AdminCreateNestedManyWithoutRoleInput
    employees?: EmployeeCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutVendor_usersInput = {
    role_id?: number
    name: string
    description?: string | null
    is_active?: boolean
    tenant_id?: string | null
    is_system_role?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    role_policies?: RolePolicyUncheckedCreateNestedManyWithoutRoleInput
    admins?: AdminUncheckedCreateNestedManyWithoutRoleInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutVendor_usersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutVendor_usersInput, RoleUncheckedCreateWithoutVendor_usersInput>
  }

  export type VendorUpsertWithoutVendor_usersInput = {
    update: XOR<VendorUpdateWithoutVendor_usersInput, VendorUncheckedUpdateWithoutVendor_usersInput>
    create: XOR<VendorCreateWithoutVendor_usersInput, VendorUncheckedCreateWithoutVendor_usersInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutVendor_usersInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutVendor_usersInput, VendorUncheckedUpdateWithoutVendor_usersInput>
  }

  export type VendorUpdateWithoutVendor_usersInput = {
    name?: StringFieldUpdateOperationsInput | string
    vendor_code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutVendorsNestedInput
    drivers?: DriverUpdateManyWithoutVendorNestedInput
    vehicle_types?: VehicleTypeUpdateManyWithoutVendorNestedInput
    vehicles?: VehicleUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutVendor_usersInput = {
    vendor_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vendor_code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    drivers?: DriverUncheckedUpdateManyWithoutVendorNestedInput
    vehicle_types?: VehicleTypeUncheckedUpdateManyWithoutVendorNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type RoleUpsertWithoutVendor_usersInput = {
    update: XOR<RoleUpdateWithoutVendor_usersInput, RoleUncheckedUpdateWithoutVendor_usersInput>
    create: XOR<RoleCreateWithoutVendor_usersInput, RoleUncheckedCreateWithoutVendor_usersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutVendor_usersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutVendor_usersInput, RoleUncheckedUpdateWithoutVendor_usersInput>
  }

  export type RoleUpdateWithoutVendor_usersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_system_role?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutRolesNestedInput
    role_policies?: RolePolicyUpdateManyWithoutRoleNestedInput
    admins?: AdminUpdateManyWithoutRoleNestedInput
    employees?: EmployeeUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutVendor_usersInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    tenant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_system_role?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role_policies?: RolePolicyUncheckedUpdateManyWithoutRoleNestedInput
    admins?: AdminUncheckedUpdateManyWithoutRoleNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type TenantCreateWithoutCutoffInput = {
    tenant_id: string
    name: string
    address?: string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    teams?: TeamCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    shifts?: ShiftCreateNestedManyWithoutTenantInput
    bookings?: BookingCreateNestedManyWithoutTenantInput
    policies?: PolicyCreateNestedManyWithoutTenantInput
    vendors?: VendorCreateNestedManyWithoutTenantInput
    roles?: RoleCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCutoffInput = {
    tenant_id: string
    name: string
    address?: string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutTenantInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTenantInput
    policies?: PolicyUncheckedCreateNestedManyWithoutTenantInput
    vendors?: VendorUncheckedCreateNestedManyWithoutTenantInput
    roles?: RoleUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCutoffInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCutoffInput, TenantUncheckedCreateWithoutCutoffInput>
  }

  export type TenantUpsertWithoutCutoffInput = {
    update: XOR<TenantUpdateWithoutCutoffInput, TenantUncheckedUpdateWithoutCutoffInput>
    create: XOR<TenantCreateWithoutCutoffInput, TenantUncheckedCreateWithoutCutoffInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCutoffInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCutoffInput, TenantUncheckedUpdateWithoutCutoffInput>
  }

  export type TenantUpdateWithoutCutoffInput = {
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    shifts?: ShiftUpdateManyWithoutTenantNestedInput
    bookings?: BookingUpdateManyWithoutTenantNestedInput
    policies?: PolicyUpdateManyWithoutTenantNestedInput
    vendors?: VendorUpdateManyWithoutTenantNestedInput
    roles?: RoleUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCutoffInput = {
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutTenantNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTenantNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutTenantNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutTenantNestedInput
    roles?: RoleUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutEmployeesInput = {
    tenant_id: string
    name: string
    address?: string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    teams?: TeamCreateNestedManyWithoutTenantInput
    shifts?: ShiftCreateNestedManyWithoutTenantInput
    bookings?: BookingCreateNestedManyWithoutTenantInput
    policies?: PolicyCreateNestedManyWithoutTenantInput
    cutoff?: CutoffCreateNestedOneWithoutTenantInput
    vendors?: VendorCreateNestedManyWithoutTenantInput
    roles?: RoleCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutEmployeesInput = {
    tenant_id: string
    name: string
    address?: string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutTenantInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutTenantInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTenantInput
    policies?: PolicyUncheckedCreateNestedManyWithoutTenantInput
    cutoff?: CutoffUncheckedCreateNestedOneWithoutTenantInput
    vendors?: VendorUncheckedCreateNestedManyWithoutTenantInput
    roles?: RoleUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutEmployeesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutEmployeesInput, TenantUncheckedCreateWithoutEmployeesInput>
  }

  export type TeamCreateWithoutEmployeesInput = {
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutTeamsInput
    bookings?: BookingCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutEmployeesInput = {
    team_id?: number
    tenant_id: string
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutEmployeesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutEmployeesInput, TeamUncheckedCreateWithoutEmployeesInput>
  }

  export type RoleCreateWithoutEmployeesInput = {
    name: string
    description?: string | null
    is_active?: boolean
    is_system_role?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    tenant?: TenantCreateNestedOneWithoutRolesInput
    role_policies?: RolePolicyCreateNestedManyWithoutRoleInput
    admins?: AdminCreateNestedManyWithoutRoleInput
    vendor_users?: VendorUserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutEmployeesInput = {
    role_id?: number
    name: string
    description?: string | null
    is_active?: boolean
    tenant_id?: string | null
    is_system_role?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    role_policies?: RolePolicyUncheckedCreateNestedManyWithoutRoleInput
    admins?: AdminUncheckedCreateNestedManyWithoutRoleInput
    vendor_users?: VendorUserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutEmployeesInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutEmployeesInput, RoleUncheckedCreateWithoutEmployeesInput>
  }

  export type BookingCreateWithoutEmployeeInput = {
    employee_code: string
    booking_date: Date | string
    pickup_latitude?: number | null
    pickup_longitude?: number | null
    pickup_location?: string | null
    drop_latitude?: number | null
    drop_longitude?: number | null
    drop_location?: string | null
    status?: $Enums.BookingStatusEnum
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutBookingsInput
    shift?: ShiftCreateNestedOneWithoutBookingsInput
    team?: TeamCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutEmployeeInput = {
    booking_id?: number
    tenant_id: string
    employee_code: string
    shift_id?: number | null
    team_id?: number | null
    booking_date: Date | string
    pickup_latitude?: number | null
    pickup_longitude?: number | null
    pickup_location?: string | null
    drop_latitude?: number | null
    drop_longitude?: number | null
    drop_location?: string | null
    status?: $Enums.BookingStatusEnum
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingCreateOrConnectWithoutEmployeeInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutEmployeeInput, BookingUncheckedCreateWithoutEmployeeInput>
  }

  export type BookingCreateManyEmployeeInputEnvelope = {
    data: BookingCreateManyEmployeeInput | BookingCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type WeekoffConfigCreateWithoutEmployeeInput = {
    monday?: boolean
    tuesday?: boolean
    wednesday?: boolean
    thursday?: boolean
    friday?: boolean
    saturday?: boolean
    sunday?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WeekoffConfigUncheckedCreateWithoutEmployeeInput = {
    weekoff_id?: number
    monday?: boolean
    tuesday?: boolean
    wednesday?: boolean
    thursday?: boolean
    friday?: boolean
    saturday?: boolean
    sunday?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WeekoffConfigCreateOrConnectWithoutEmployeeInput = {
    where: WeekoffConfigWhereUniqueInput
    create: XOR<WeekoffConfigCreateWithoutEmployeeInput, WeekoffConfigUncheckedCreateWithoutEmployeeInput>
  }

  export type TenantUpsertWithoutEmployeesInput = {
    update: XOR<TenantUpdateWithoutEmployeesInput, TenantUncheckedUpdateWithoutEmployeesInput>
    create: XOR<TenantCreateWithoutEmployeesInput, TenantUncheckedCreateWithoutEmployeesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutEmployeesInput, TenantUncheckedUpdateWithoutEmployeesInput>
  }

  export type TenantUpdateWithoutEmployeesInput = {
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUpdateManyWithoutTenantNestedInput
    shifts?: ShiftUpdateManyWithoutTenantNestedInput
    bookings?: BookingUpdateManyWithoutTenantNestedInput
    policies?: PolicyUpdateManyWithoutTenantNestedInput
    cutoff?: CutoffUpdateOneWithoutTenantNestedInput
    vendors?: VendorUpdateManyWithoutTenantNestedInput
    roles?: RoleUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutEmployeesInput = {
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutTenantNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutTenantNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTenantNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutTenantNestedInput
    cutoff?: CutoffUncheckedUpdateOneWithoutTenantNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutTenantNestedInput
    roles?: RoleUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TeamUpsertWithoutEmployeesInput = {
    update: XOR<TeamUpdateWithoutEmployeesInput, TeamUncheckedUpdateWithoutEmployeesInput>
    create: XOR<TeamCreateWithoutEmployeesInput, TeamUncheckedCreateWithoutEmployeesInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutEmployeesInput, TeamUncheckedUpdateWithoutEmployeesInput>
  }

  export type TeamUpdateWithoutEmployeesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTeamsNestedInput
    bookings?: BookingUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutEmployeesInput = {
    team_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type RoleUpsertWithoutEmployeesInput = {
    update: XOR<RoleUpdateWithoutEmployeesInput, RoleUncheckedUpdateWithoutEmployeesInput>
    create: XOR<RoleCreateWithoutEmployeesInput, RoleUncheckedCreateWithoutEmployeesInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutEmployeesInput, RoleUncheckedUpdateWithoutEmployeesInput>
  }

  export type RoleUpdateWithoutEmployeesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_system_role?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutRolesNestedInput
    role_policies?: RolePolicyUpdateManyWithoutRoleNestedInput
    admins?: AdminUpdateManyWithoutRoleNestedInput
    vendor_users?: VendorUserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutEmployeesInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    tenant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_system_role?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role_policies?: RolePolicyUncheckedUpdateManyWithoutRoleNestedInput
    admins?: AdminUncheckedUpdateManyWithoutRoleNestedInput
    vendor_users?: VendorUserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type BookingUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutEmployeeInput, BookingUncheckedUpdateWithoutEmployeeInput>
    create: XOR<BookingCreateWithoutEmployeeInput, BookingUncheckedCreateWithoutEmployeeInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutEmployeeInput, BookingUncheckedUpdateWithoutEmployeeInput>
  }

  export type BookingUpdateManyWithWhereWithoutEmployeeInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    booking_id?: IntFilter<"Booking"> | number
    tenant_id?: StringFilter<"Booking"> | string
    employee_id?: IntFilter<"Booking"> | number
    employee_code?: StringFilter<"Booking"> | string
    shift_id?: IntNullableFilter<"Booking"> | number | null
    team_id?: IntNullableFilter<"Booking"> | number | null
    booking_date?: DateTimeFilter<"Booking"> | Date | string
    pickup_latitude?: FloatNullableFilter<"Booking"> | number | null
    pickup_longitude?: FloatNullableFilter<"Booking"> | number | null
    pickup_location?: StringNullableFilter<"Booking"> | string | null
    drop_latitude?: FloatNullableFilter<"Booking"> | number | null
    drop_longitude?: FloatNullableFilter<"Booking"> | number | null
    drop_location?: StringNullableFilter<"Booking"> | string | null
    status?: EnumBookingStatusEnumFilter<"Booking"> | $Enums.BookingStatusEnum
    reason?: StringNullableFilter<"Booking"> | string | null
    created_at?: DateTimeFilter<"Booking"> | Date | string
    updated_at?: DateTimeFilter<"Booking"> | Date | string
  }

  export type WeekoffConfigUpsertWithoutEmployeeInput = {
    update: XOR<WeekoffConfigUpdateWithoutEmployeeInput, WeekoffConfigUncheckedUpdateWithoutEmployeeInput>
    create: XOR<WeekoffConfigCreateWithoutEmployeeInput, WeekoffConfigUncheckedCreateWithoutEmployeeInput>
    where?: WeekoffConfigWhereInput
  }

  export type WeekoffConfigUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: WeekoffConfigWhereInput
    data: XOR<WeekoffConfigUpdateWithoutEmployeeInput, WeekoffConfigUncheckedUpdateWithoutEmployeeInput>
  }

  export type WeekoffConfigUpdateWithoutEmployeeInput = {
    monday?: BoolFieldUpdateOperationsInput | boolean
    tuesday?: BoolFieldUpdateOperationsInput | boolean
    wednesday?: BoolFieldUpdateOperationsInput | boolean
    thursday?: BoolFieldUpdateOperationsInput | boolean
    friday?: BoolFieldUpdateOperationsInput | boolean
    saturday?: BoolFieldUpdateOperationsInput | boolean
    sunday?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeekoffConfigUncheckedUpdateWithoutEmployeeInput = {
    weekoff_id?: IntFieldUpdateOperationsInput | number
    monday?: BoolFieldUpdateOperationsInput | boolean
    tuesday?: BoolFieldUpdateOperationsInput | boolean
    wednesday?: BoolFieldUpdateOperationsInput | boolean
    thursday?: BoolFieldUpdateOperationsInput | boolean
    friday?: BoolFieldUpdateOperationsInput | boolean
    saturday?: BoolFieldUpdateOperationsInput | boolean
    sunday?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutShiftsInput = {
    tenant_id: string
    name: string
    address?: string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    teams?: TeamCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    bookings?: BookingCreateNestedManyWithoutTenantInput
    policies?: PolicyCreateNestedManyWithoutTenantInput
    cutoff?: CutoffCreateNestedOneWithoutTenantInput
    vendors?: VendorCreateNestedManyWithoutTenantInput
    roles?: RoleCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutShiftsInput = {
    tenant_id: string
    name: string
    address?: string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTenantInput
    policies?: PolicyUncheckedCreateNestedManyWithoutTenantInput
    cutoff?: CutoffUncheckedCreateNestedOneWithoutTenantInput
    vendors?: VendorUncheckedCreateNestedManyWithoutTenantInput
    roles?: RoleUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutShiftsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutShiftsInput, TenantUncheckedCreateWithoutShiftsInput>
  }

  export type BookingCreateWithoutShiftInput = {
    employee_code: string
    booking_date: Date | string
    pickup_latitude?: number | null
    pickup_longitude?: number | null
    pickup_location?: string | null
    drop_latitude?: number | null
    drop_longitude?: number | null
    drop_location?: string | null
    status?: $Enums.BookingStatusEnum
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutBookingsInput
    employee: EmployeeCreateNestedOneWithoutBookingsInput
    team?: TeamCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutShiftInput = {
    booking_id?: number
    tenant_id: string
    employee_id: number
    employee_code: string
    team_id?: number | null
    booking_date: Date | string
    pickup_latitude?: number | null
    pickup_longitude?: number | null
    pickup_location?: string | null
    drop_latitude?: number | null
    drop_longitude?: number | null
    drop_location?: string | null
    status?: $Enums.BookingStatusEnum
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingCreateOrConnectWithoutShiftInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutShiftInput, BookingUncheckedCreateWithoutShiftInput>
  }

  export type BookingCreateManyShiftInputEnvelope = {
    data: BookingCreateManyShiftInput | BookingCreateManyShiftInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutShiftsInput = {
    update: XOR<TenantUpdateWithoutShiftsInput, TenantUncheckedUpdateWithoutShiftsInput>
    create: XOR<TenantCreateWithoutShiftsInput, TenantUncheckedCreateWithoutShiftsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutShiftsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutShiftsInput, TenantUncheckedUpdateWithoutShiftsInput>
  }

  export type TenantUpdateWithoutShiftsInput = {
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    bookings?: BookingUpdateManyWithoutTenantNestedInput
    policies?: PolicyUpdateManyWithoutTenantNestedInput
    cutoff?: CutoffUpdateOneWithoutTenantNestedInput
    vendors?: VendorUpdateManyWithoutTenantNestedInput
    roles?: RoleUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutShiftsInput = {
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTenantNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutTenantNestedInput
    cutoff?: CutoffUncheckedUpdateOneWithoutTenantNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutTenantNestedInput
    roles?: RoleUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type BookingUpsertWithWhereUniqueWithoutShiftInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutShiftInput, BookingUncheckedUpdateWithoutShiftInput>
    create: XOR<BookingCreateWithoutShiftInput, BookingUncheckedCreateWithoutShiftInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutShiftInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutShiftInput, BookingUncheckedUpdateWithoutShiftInput>
  }

  export type BookingUpdateManyWithWhereWithoutShiftInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutShiftInput>
  }

  export type TenantCreateWithoutTeamsInput = {
    tenant_id: string
    name: string
    address?: string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    shifts?: ShiftCreateNestedManyWithoutTenantInput
    bookings?: BookingCreateNestedManyWithoutTenantInput
    policies?: PolicyCreateNestedManyWithoutTenantInput
    cutoff?: CutoffCreateNestedOneWithoutTenantInput
    vendors?: VendorCreateNestedManyWithoutTenantInput
    roles?: RoleCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutTeamsInput = {
    tenant_id: string
    name: string
    address?: string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutTenantInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTenantInput
    policies?: PolicyUncheckedCreateNestedManyWithoutTenantInput
    cutoff?: CutoffUncheckedCreateNestedOneWithoutTenantInput
    vendors?: VendorUncheckedCreateNestedManyWithoutTenantInput
    roles?: RoleUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutTeamsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutTeamsInput, TenantUncheckedCreateWithoutTeamsInput>
  }

  export type EmployeeCreateWithoutTeamInput = {
    name: string
    employee_code: string
    email: string
    password: string
    phone: string
    alternate_phone?: string | null
    special_needs?: string | null
    special_needs_start_date?: Date | string | null
    special_needs_end_date?: Date | string | null
    address?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    gender?: $Enums.GenderEnum | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutEmployeesInput
    role: RoleCreateNestedOneWithoutEmployeesInput
    bookings?: BookingCreateNestedManyWithoutEmployeeInput
    weekoff_config?: WeekoffConfigCreateNestedOneWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutTeamInput = {
    employee_id?: number
    tenant_id: string
    role_id: number
    name: string
    employee_code: string
    email: string
    password: string
    phone: string
    alternate_phone?: string | null
    special_needs?: string | null
    special_needs_start_date?: Date | string | null
    special_needs_end_date?: Date | string | null
    address?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    gender?: $Enums.GenderEnum | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutEmployeeInput
    weekoff_config?: WeekoffConfigUncheckedCreateNestedOneWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutTeamInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutTeamInput, EmployeeUncheckedCreateWithoutTeamInput>
  }

  export type EmployeeCreateManyTeamInputEnvelope = {
    data: EmployeeCreateManyTeamInput | EmployeeCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutTeamInput = {
    employee_code: string
    booking_date: Date | string
    pickup_latitude?: number | null
    pickup_longitude?: number | null
    pickup_location?: string | null
    drop_latitude?: number | null
    drop_longitude?: number | null
    drop_location?: string | null
    status?: $Enums.BookingStatusEnum
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutBookingsInput
    employee: EmployeeCreateNestedOneWithoutBookingsInput
    shift?: ShiftCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutTeamInput = {
    booking_id?: number
    tenant_id: string
    employee_id: number
    employee_code: string
    shift_id?: number | null
    booking_date: Date | string
    pickup_latitude?: number | null
    pickup_longitude?: number | null
    pickup_location?: string | null
    drop_latitude?: number | null
    drop_longitude?: number | null
    drop_location?: string | null
    status?: $Enums.BookingStatusEnum
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingCreateOrConnectWithoutTeamInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutTeamInput, BookingUncheckedCreateWithoutTeamInput>
  }

  export type BookingCreateManyTeamInputEnvelope = {
    data: BookingCreateManyTeamInput | BookingCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutTeamsInput = {
    update: XOR<TenantUpdateWithoutTeamsInput, TenantUncheckedUpdateWithoutTeamsInput>
    create: XOR<TenantCreateWithoutTeamsInput, TenantUncheckedCreateWithoutTeamsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutTeamsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutTeamsInput, TenantUncheckedUpdateWithoutTeamsInput>
  }

  export type TenantUpdateWithoutTeamsInput = {
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    shifts?: ShiftUpdateManyWithoutTenantNestedInput
    bookings?: BookingUpdateManyWithoutTenantNestedInput
    policies?: PolicyUpdateManyWithoutTenantNestedInput
    cutoff?: CutoffUpdateOneWithoutTenantNestedInput
    vendors?: VendorUpdateManyWithoutTenantNestedInput
    roles?: RoleUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutTeamsInput = {
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutTenantNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTenantNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutTenantNestedInput
    cutoff?: CutoffUncheckedUpdateOneWithoutTenantNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutTenantNestedInput
    roles?: RoleUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type EmployeeUpsertWithWhereUniqueWithoutTeamInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutTeamInput, EmployeeUncheckedUpdateWithoutTeamInput>
    create: XOR<EmployeeCreateWithoutTeamInput, EmployeeUncheckedCreateWithoutTeamInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutTeamInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutTeamInput, EmployeeUncheckedUpdateWithoutTeamInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutTeamInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutTeamInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    OR?: EmployeeScalarWhereInput[]
    NOT?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    employee_id?: IntFilter<"Employee"> | number
    tenant_id?: StringFilter<"Employee"> | string
    role_id?: IntFilter<"Employee"> | number
    name?: StringFilter<"Employee"> | string
    employee_code?: StringFilter<"Employee"> | string
    email?: StringFilter<"Employee"> | string
    password?: StringFilter<"Employee"> | string
    team_id?: IntNullableFilter<"Employee"> | number | null
    phone?: StringFilter<"Employee"> | string
    alternate_phone?: StringNullableFilter<"Employee"> | string | null
    special_needs?: StringNullableFilter<"Employee"> | string | null
    special_needs_start_date?: DateTimeNullableFilter<"Employee"> | Date | string | null
    special_needs_end_date?: DateTimeNullableFilter<"Employee"> | Date | string | null
    address?: StringNullableFilter<"Employee"> | string | null
    latitude?: DecimalNullableFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    gender?: EnumGenderEnumNullableFilter<"Employee"> | $Enums.GenderEnum | null
    is_active?: BoolFilter<"Employee"> | boolean
    created_at?: DateTimeFilter<"Employee"> | Date | string
    updated_at?: DateTimeFilter<"Employee"> | Date | string
  }

  export type BookingUpsertWithWhereUniqueWithoutTeamInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutTeamInput, BookingUncheckedUpdateWithoutTeamInput>
    create: XOR<BookingCreateWithoutTeamInput, BookingUncheckedCreateWithoutTeamInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutTeamInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutTeamInput, BookingUncheckedUpdateWithoutTeamInput>
  }

  export type BookingUpdateManyWithWhereWithoutTeamInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutTeamInput>
  }

  export type TeamCreateWithoutTenantInput = {
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    employees?: EmployeeCreateNestedManyWithoutTeamInput
    bookings?: BookingCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutTenantInput = {
    team_id?: number
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutTeamInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutTenantInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutTenantInput, TeamUncheckedCreateWithoutTenantInput>
  }

  export type TeamCreateManyTenantInputEnvelope = {
    data: TeamCreateManyTenantInput | TeamCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeCreateWithoutTenantInput = {
    name: string
    employee_code: string
    email: string
    password: string
    phone: string
    alternate_phone?: string | null
    special_needs?: string | null
    special_needs_start_date?: Date | string | null
    special_needs_end_date?: Date | string | null
    address?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    gender?: $Enums.GenderEnum | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    team?: TeamCreateNestedOneWithoutEmployeesInput
    role: RoleCreateNestedOneWithoutEmployeesInput
    bookings?: BookingCreateNestedManyWithoutEmployeeInput
    weekoff_config?: WeekoffConfigCreateNestedOneWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutTenantInput = {
    employee_id?: number
    role_id: number
    name: string
    employee_code: string
    email: string
    password: string
    team_id?: number | null
    phone: string
    alternate_phone?: string | null
    special_needs?: string | null
    special_needs_start_date?: Date | string | null
    special_needs_end_date?: Date | string | null
    address?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    gender?: $Enums.GenderEnum | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutEmployeeInput
    weekoff_config?: WeekoffConfigUncheckedCreateNestedOneWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutTenantInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutTenantInput, EmployeeUncheckedCreateWithoutTenantInput>
  }

  export type EmployeeCreateManyTenantInputEnvelope = {
    data: EmployeeCreateManyTenantInput | EmployeeCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ShiftCreateWithoutTenantInput = {
    shift_code: string
    log_type: $Enums.ShiftLogTypeEnum
    shift_time: Date | string
    pickup_type?: $Enums.PickupTypeEnum | null
    gender?: $Enums.GenderEnum | null
    waiting_time_minutes?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    bookings?: BookingCreateNestedManyWithoutShiftInput
  }

  export type ShiftUncheckedCreateWithoutTenantInput = {
    shift_id?: number
    shift_code: string
    log_type: $Enums.ShiftLogTypeEnum
    shift_time: Date | string
    pickup_type?: $Enums.PickupTypeEnum | null
    gender?: $Enums.GenderEnum | null
    waiting_time_minutes?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutShiftInput
  }

  export type ShiftCreateOrConnectWithoutTenantInput = {
    where: ShiftWhereUniqueInput
    create: XOR<ShiftCreateWithoutTenantInput, ShiftUncheckedCreateWithoutTenantInput>
  }

  export type ShiftCreateManyTenantInputEnvelope = {
    data: ShiftCreateManyTenantInput | ShiftCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutTenantInput = {
    employee_code: string
    booking_date: Date | string
    pickup_latitude?: number | null
    pickup_longitude?: number | null
    pickup_location?: string | null
    drop_latitude?: number | null
    drop_longitude?: number | null
    drop_location?: string | null
    status?: $Enums.BookingStatusEnum
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    employee: EmployeeCreateNestedOneWithoutBookingsInput
    shift?: ShiftCreateNestedOneWithoutBookingsInput
    team?: TeamCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutTenantInput = {
    booking_id?: number
    employee_id: number
    employee_code: string
    shift_id?: number | null
    team_id?: number | null
    booking_date: Date | string
    pickup_latitude?: number | null
    pickup_longitude?: number | null
    pickup_location?: string | null
    drop_latitude?: number | null
    drop_longitude?: number | null
    drop_location?: string | null
    status?: $Enums.BookingStatusEnum
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingCreateOrConnectWithoutTenantInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutTenantInput, BookingUncheckedCreateWithoutTenantInput>
  }

  export type BookingCreateManyTenantInputEnvelope = {
    data: BookingCreateManyTenantInput | BookingCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type PolicyCreateWithoutTenantInput = {
    name: string
    description?: string | null
    is_active?: boolean
    is_system_policy?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    policy_permissions?: PolicyPermissionCreateNestedManyWithoutPolicyInput
    role_policies?: RolePolicyCreateNestedManyWithoutPolicyInput
  }

  export type PolicyUncheckedCreateWithoutTenantInput = {
    policy_id?: number
    name: string
    description?: string | null
    is_active?: boolean
    is_system_policy?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    policy_permissions?: PolicyPermissionUncheckedCreateNestedManyWithoutPolicyInput
    role_policies?: RolePolicyUncheckedCreateNestedManyWithoutPolicyInput
  }

  export type PolicyCreateOrConnectWithoutTenantInput = {
    where: PolicyWhereUniqueInput
    create: XOR<PolicyCreateWithoutTenantInput, PolicyUncheckedCreateWithoutTenantInput>
  }

  export type PolicyCreateManyTenantInputEnvelope = {
    data: PolicyCreateManyTenantInput | PolicyCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CutoffCreateWithoutTenantInput = {
    booking_cutoff?: number
    cancel_cutoff?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CutoffUncheckedCreateWithoutTenantInput = {
    booking_cutoff?: number
    cancel_cutoff?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CutoffCreateOrConnectWithoutTenantInput = {
    where: CutoffWhereUniqueInput
    create: XOR<CutoffCreateWithoutTenantInput, CutoffUncheckedCreateWithoutTenantInput>
  }

  export type VendorCreateWithoutTenantInput = {
    name: string
    vendor_code: string
    email?: string | null
    phone?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    drivers?: DriverCreateNestedManyWithoutVendorInput
    vehicle_types?: VehicleTypeCreateNestedManyWithoutVendorInput
    vehicles?: VehicleCreateNestedManyWithoutVendorInput
    vendor_users?: VendorUserCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutTenantInput = {
    vendor_id?: number
    name: string
    vendor_code: string
    email?: string | null
    phone?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    drivers?: DriverUncheckedCreateNestedManyWithoutVendorInput
    vehicle_types?: VehicleTypeUncheckedCreateNestedManyWithoutVendorInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutVendorInput
    vendor_users?: VendorUserUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutTenantInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutTenantInput, VendorUncheckedCreateWithoutTenantInput>
  }

  export type VendorCreateManyTenantInputEnvelope = {
    data: VendorCreateManyTenantInput | VendorCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type RoleCreateWithoutTenantInput = {
    name: string
    description?: string | null
    is_active?: boolean
    is_system_role?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    role_policies?: RolePolicyCreateNestedManyWithoutRoleInput
    admins?: AdminCreateNestedManyWithoutRoleInput
    vendor_users?: VendorUserCreateNestedManyWithoutRoleInput
    employees?: EmployeeCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutTenantInput = {
    role_id?: number
    name: string
    description?: string | null
    is_active?: boolean
    is_system_role?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    role_policies?: RolePolicyUncheckedCreateNestedManyWithoutRoleInput
    admins?: AdminUncheckedCreateNestedManyWithoutRoleInput
    vendor_users?: VendorUserUncheckedCreateNestedManyWithoutRoleInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutTenantInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutTenantInput, RoleUncheckedCreateWithoutTenantInput>
  }

  export type RoleCreateManyTenantInputEnvelope = {
    data: RoleCreateManyTenantInput | RoleCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type TeamUpsertWithWhereUniqueWithoutTenantInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutTenantInput, TeamUncheckedUpdateWithoutTenantInput>
    create: XOR<TeamCreateWithoutTenantInput, TeamUncheckedCreateWithoutTenantInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutTenantInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutTenantInput, TeamUncheckedUpdateWithoutTenantInput>
  }

  export type TeamUpdateManyWithWhereWithoutTenantInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutTenantInput>
  }

  export type TeamScalarWhereInput = {
    AND?: TeamScalarWhereInput | TeamScalarWhereInput[]
    OR?: TeamScalarWhereInput[]
    NOT?: TeamScalarWhereInput | TeamScalarWhereInput[]
    team_id?: IntFilter<"Team"> | number
    tenant_id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    is_active?: BoolFilter<"Team"> | boolean
    created_at?: DateTimeFilter<"Team"> | Date | string
    updated_at?: DateTimeFilter<"Team"> | Date | string
  }

  export type EmployeeUpsertWithWhereUniqueWithoutTenantInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutTenantInput, EmployeeUncheckedUpdateWithoutTenantInput>
    create: XOR<EmployeeCreateWithoutTenantInput, EmployeeUncheckedCreateWithoutTenantInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutTenantInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutTenantInput, EmployeeUncheckedUpdateWithoutTenantInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutTenantInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutTenantInput>
  }

  export type ShiftUpsertWithWhereUniqueWithoutTenantInput = {
    where: ShiftWhereUniqueInput
    update: XOR<ShiftUpdateWithoutTenantInput, ShiftUncheckedUpdateWithoutTenantInput>
    create: XOR<ShiftCreateWithoutTenantInput, ShiftUncheckedCreateWithoutTenantInput>
  }

  export type ShiftUpdateWithWhereUniqueWithoutTenantInput = {
    where: ShiftWhereUniqueInput
    data: XOR<ShiftUpdateWithoutTenantInput, ShiftUncheckedUpdateWithoutTenantInput>
  }

  export type ShiftUpdateManyWithWhereWithoutTenantInput = {
    where: ShiftScalarWhereInput
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyWithoutTenantInput>
  }

  export type ShiftScalarWhereInput = {
    AND?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
    OR?: ShiftScalarWhereInput[]
    NOT?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
    shift_id?: IntFilter<"Shift"> | number
    tenant_id?: StringFilter<"Shift"> | string
    shift_code?: StringFilter<"Shift"> | string
    log_type?: EnumShiftLogTypeEnumFilter<"Shift"> | $Enums.ShiftLogTypeEnum
    shift_time?: DateTimeFilter<"Shift"> | Date | string
    pickup_type?: EnumPickupTypeEnumNullableFilter<"Shift"> | $Enums.PickupTypeEnum | null
    gender?: EnumGenderEnumNullableFilter<"Shift"> | $Enums.GenderEnum | null
    waiting_time_minutes?: IntFilter<"Shift"> | number
    is_active?: BoolFilter<"Shift"> | boolean
    created_at?: DateTimeFilter<"Shift"> | Date | string
    updated_at?: DateTimeFilter<"Shift"> | Date | string
  }

  export type BookingUpsertWithWhereUniqueWithoutTenantInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutTenantInput, BookingUncheckedUpdateWithoutTenantInput>
    create: XOR<BookingCreateWithoutTenantInput, BookingUncheckedCreateWithoutTenantInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutTenantInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutTenantInput, BookingUncheckedUpdateWithoutTenantInput>
  }

  export type BookingUpdateManyWithWhereWithoutTenantInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutTenantInput>
  }

  export type PolicyUpsertWithWhereUniqueWithoutTenantInput = {
    where: PolicyWhereUniqueInput
    update: XOR<PolicyUpdateWithoutTenantInput, PolicyUncheckedUpdateWithoutTenantInput>
    create: XOR<PolicyCreateWithoutTenantInput, PolicyUncheckedCreateWithoutTenantInput>
  }

  export type PolicyUpdateWithWhereUniqueWithoutTenantInput = {
    where: PolicyWhereUniqueInput
    data: XOR<PolicyUpdateWithoutTenantInput, PolicyUncheckedUpdateWithoutTenantInput>
  }

  export type PolicyUpdateManyWithWhereWithoutTenantInput = {
    where: PolicyScalarWhereInput
    data: XOR<PolicyUpdateManyMutationInput, PolicyUncheckedUpdateManyWithoutTenantInput>
  }

  export type PolicyScalarWhereInput = {
    AND?: PolicyScalarWhereInput | PolicyScalarWhereInput[]
    OR?: PolicyScalarWhereInput[]
    NOT?: PolicyScalarWhereInput | PolicyScalarWhereInput[]
    policy_id?: IntFilter<"Policy"> | number
    tenant_id?: StringNullableFilter<"Policy"> | string | null
    name?: StringFilter<"Policy"> | string
    description?: StringNullableFilter<"Policy"> | string | null
    is_active?: BoolFilter<"Policy"> | boolean
    is_system_policy?: BoolFilter<"Policy"> | boolean
    created_at?: DateTimeFilter<"Policy"> | Date | string
    updated_at?: DateTimeFilter<"Policy"> | Date | string
  }

  export type CutoffUpsertWithoutTenantInput = {
    update: XOR<CutoffUpdateWithoutTenantInput, CutoffUncheckedUpdateWithoutTenantInput>
    create: XOR<CutoffCreateWithoutTenantInput, CutoffUncheckedCreateWithoutTenantInput>
    where?: CutoffWhereInput
  }

  export type CutoffUpdateToOneWithWhereWithoutTenantInput = {
    where?: CutoffWhereInput
    data: XOR<CutoffUpdateWithoutTenantInput, CutoffUncheckedUpdateWithoutTenantInput>
  }

  export type CutoffUpdateWithoutTenantInput = {
    booking_cutoff?: IntFieldUpdateOperationsInput | number
    cancel_cutoff?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CutoffUncheckedUpdateWithoutTenantInput = {
    booking_cutoff?: IntFieldUpdateOperationsInput | number
    cancel_cutoff?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUpsertWithWhereUniqueWithoutTenantInput = {
    where: VendorWhereUniqueInput
    update: XOR<VendorUpdateWithoutTenantInput, VendorUncheckedUpdateWithoutTenantInput>
    create: XOR<VendorCreateWithoutTenantInput, VendorUncheckedCreateWithoutTenantInput>
  }

  export type VendorUpdateWithWhereUniqueWithoutTenantInput = {
    where: VendorWhereUniqueInput
    data: XOR<VendorUpdateWithoutTenantInput, VendorUncheckedUpdateWithoutTenantInput>
  }

  export type VendorUpdateManyWithWhereWithoutTenantInput = {
    where: VendorScalarWhereInput
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyWithoutTenantInput>
  }

  export type VendorScalarWhereInput = {
    AND?: VendorScalarWhereInput | VendorScalarWhereInput[]
    OR?: VendorScalarWhereInput[]
    NOT?: VendorScalarWhereInput | VendorScalarWhereInput[]
    vendor_id?: IntFilter<"Vendor"> | number
    tenant_id?: StringFilter<"Vendor"> | string
    name?: StringFilter<"Vendor"> | string
    vendor_code?: StringFilter<"Vendor"> | string
    email?: StringNullableFilter<"Vendor"> | string | null
    phone?: StringNullableFilter<"Vendor"> | string | null
    is_active?: BoolFilter<"Vendor"> | boolean
    created_at?: DateTimeFilter<"Vendor"> | Date | string
    updated_at?: DateTimeFilter<"Vendor"> | Date | string
  }

  export type RoleUpsertWithWhereUniqueWithoutTenantInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutTenantInput, RoleUncheckedUpdateWithoutTenantInput>
    create: XOR<RoleCreateWithoutTenantInput, RoleUncheckedCreateWithoutTenantInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutTenantInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutTenantInput, RoleUncheckedUpdateWithoutTenantInput>
  }

  export type RoleUpdateManyWithWhereWithoutTenantInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutTenantInput>
  }

  export type RoleScalarWhereInput = {
    AND?: RoleScalarWhereInput | RoleScalarWhereInput[]
    OR?: RoleScalarWhereInput[]
    NOT?: RoleScalarWhereInput | RoleScalarWhereInput[]
    role_id?: IntFilter<"Role"> | number
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    is_active?: BoolFilter<"Role"> | boolean
    tenant_id?: StringNullableFilter<"Role"> | string | null
    is_system_role?: BoolFilter<"Role"> | boolean
    created_at?: DateTimeFilter<"Role"> | Date | string
    updated_at?: DateTimeFilter<"Role"> | Date | string
  }

  export type EmployeeCreateWithoutWeekoff_configInput = {
    name: string
    employee_code: string
    email: string
    password: string
    phone: string
    alternate_phone?: string | null
    special_needs?: string | null
    special_needs_start_date?: Date | string | null
    special_needs_end_date?: Date | string | null
    address?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    gender?: $Enums.GenderEnum | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutEmployeesInput
    team?: TeamCreateNestedOneWithoutEmployeesInput
    role: RoleCreateNestedOneWithoutEmployeesInput
    bookings?: BookingCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutWeekoff_configInput = {
    employee_id?: number
    tenant_id: string
    role_id: number
    name: string
    employee_code: string
    email: string
    password: string
    team_id?: number | null
    phone: string
    alternate_phone?: string | null
    special_needs?: string | null
    special_needs_start_date?: Date | string | null
    special_needs_end_date?: Date | string | null
    address?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    gender?: $Enums.GenderEnum | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutWeekoff_configInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutWeekoff_configInput, EmployeeUncheckedCreateWithoutWeekoff_configInput>
  }

  export type EmployeeUpsertWithoutWeekoff_configInput = {
    update: XOR<EmployeeUpdateWithoutWeekoff_configInput, EmployeeUncheckedUpdateWithoutWeekoff_configInput>
    create: XOR<EmployeeCreateWithoutWeekoff_configInput, EmployeeUncheckedCreateWithoutWeekoff_configInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutWeekoff_configInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutWeekoff_configInput, EmployeeUncheckedUpdateWithoutWeekoff_configInput>
  }

  export type EmployeeUpdateWithoutWeekoff_configInput = {
    name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    alternate_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    special_needs_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEmployeesNestedInput
    team?: TeamUpdateOneWithoutEmployeesNestedInput
    role?: RoleUpdateOneRequiredWithoutEmployeesNestedInput
    bookings?: BookingUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutWeekoff_configInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    team_id?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: StringFieldUpdateOperationsInput | string
    alternate_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    special_needs_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type RoleCreateWithoutAdminsInput = {
    name: string
    description?: string | null
    is_active?: boolean
    is_system_role?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    tenant?: TenantCreateNestedOneWithoutRolesInput
    role_policies?: RolePolicyCreateNestedManyWithoutRoleInput
    vendor_users?: VendorUserCreateNestedManyWithoutRoleInput
    employees?: EmployeeCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutAdminsInput = {
    role_id?: number
    name: string
    description?: string | null
    is_active?: boolean
    tenant_id?: string | null
    is_system_role?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    role_policies?: RolePolicyUncheckedCreateNestedManyWithoutRoleInput
    vendor_users?: VendorUserUncheckedCreateNestedManyWithoutRoleInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutAdminsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutAdminsInput, RoleUncheckedCreateWithoutAdminsInput>
  }

  export type RoleUpsertWithoutAdminsInput = {
    update: XOR<RoleUpdateWithoutAdminsInput, RoleUncheckedUpdateWithoutAdminsInput>
    create: XOR<RoleCreateWithoutAdminsInput, RoleUncheckedCreateWithoutAdminsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutAdminsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutAdminsInput, RoleUncheckedUpdateWithoutAdminsInput>
  }

  export type RoleUpdateWithoutAdminsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_system_role?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutRolesNestedInput
    role_policies?: RolePolicyUpdateManyWithoutRoleNestedInput
    vendor_users?: VendorUserUpdateManyWithoutRoleNestedInput
    employees?: EmployeeUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutAdminsInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    tenant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_system_role?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role_policies?: RolePolicyUncheckedUpdateManyWithoutRoleNestedInput
    vendor_users?: VendorUserUncheckedUpdateManyWithoutRoleNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type PolicyPermissionCreateWithoutPermissionInput = {
    policy: PolicyCreateNestedOneWithoutPolicy_permissionsInput
  }

  export type PolicyPermissionUncheckedCreateWithoutPermissionInput = {
    policy_id: number
  }

  export type PolicyPermissionCreateOrConnectWithoutPermissionInput = {
    where: PolicyPermissionWhereUniqueInput
    create: XOR<PolicyPermissionCreateWithoutPermissionInput, PolicyPermissionUncheckedCreateWithoutPermissionInput>
  }

  export type PolicyPermissionCreateManyPermissionInputEnvelope = {
    data: PolicyPermissionCreateManyPermissionInput | PolicyPermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type PolicyPermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: PolicyPermissionWhereUniqueInput
    update: XOR<PolicyPermissionUpdateWithoutPermissionInput, PolicyPermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<PolicyPermissionCreateWithoutPermissionInput, PolicyPermissionUncheckedCreateWithoutPermissionInput>
  }

  export type PolicyPermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: PolicyPermissionWhereUniqueInput
    data: XOR<PolicyPermissionUpdateWithoutPermissionInput, PolicyPermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type PolicyPermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: PolicyPermissionScalarWhereInput
    data: XOR<PolicyPermissionUpdateManyMutationInput, PolicyPermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type PolicyPermissionScalarWhereInput = {
    AND?: PolicyPermissionScalarWhereInput | PolicyPermissionScalarWhereInput[]
    OR?: PolicyPermissionScalarWhereInput[]
    NOT?: PolicyPermissionScalarWhereInput | PolicyPermissionScalarWhereInput[]
    policy_id?: IntFilter<"PolicyPermission"> | number
    permission_id?: IntFilter<"PolicyPermission"> | number
  }

  export type TenantCreateWithoutPoliciesInput = {
    tenant_id: string
    name: string
    address?: string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    teams?: TeamCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    shifts?: ShiftCreateNestedManyWithoutTenantInput
    bookings?: BookingCreateNestedManyWithoutTenantInput
    cutoff?: CutoffCreateNestedOneWithoutTenantInput
    vendors?: VendorCreateNestedManyWithoutTenantInput
    roles?: RoleCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPoliciesInput = {
    tenant_id: string
    name: string
    address?: string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutTenantInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTenantInput
    cutoff?: CutoffUncheckedCreateNestedOneWithoutTenantInput
    vendors?: VendorUncheckedCreateNestedManyWithoutTenantInput
    roles?: RoleUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPoliciesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPoliciesInput, TenantUncheckedCreateWithoutPoliciesInput>
  }

  export type PolicyPermissionCreateWithoutPolicyInput = {
    permission: PermissionCreateNestedOneWithoutPolicy_permissionsInput
  }

  export type PolicyPermissionUncheckedCreateWithoutPolicyInput = {
    permission_id: number
  }

  export type PolicyPermissionCreateOrConnectWithoutPolicyInput = {
    where: PolicyPermissionWhereUniqueInput
    create: XOR<PolicyPermissionCreateWithoutPolicyInput, PolicyPermissionUncheckedCreateWithoutPolicyInput>
  }

  export type PolicyPermissionCreateManyPolicyInputEnvelope = {
    data: PolicyPermissionCreateManyPolicyInput | PolicyPermissionCreateManyPolicyInput[]
    skipDuplicates?: boolean
  }

  export type RolePolicyCreateWithoutPolicyInput = {
    role: RoleCreateNestedOneWithoutRole_policiesInput
  }

  export type RolePolicyUncheckedCreateWithoutPolicyInput = {
    role_id: number
  }

  export type RolePolicyCreateOrConnectWithoutPolicyInput = {
    where: RolePolicyWhereUniqueInput
    create: XOR<RolePolicyCreateWithoutPolicyInput, RolePolicyUncheckedCreateWithoutPolicyInput>
  }

  export type RolePolicyCreateManyPolicyInputEnvelope = {
    data: RolePolicyCreateManyPolicyInput | RolePolicyCreateManyPolicyInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutPoliciesInput = {
    update: XOR<TenantUpdateWithoutPoliciesInput, TenantUncheckedUpdateWithoutPoliciesInput>
    create: XOR<TenantCreateWithoutPoliciesInput, TenantUncheckedCreateWithoutPoliciesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPoliciesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPoliciesInput, TenantUncheckedUpdateWithoutPoliciesInput>
  }

  export type TenantUpdateWithoutPoliciesInput = {
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    shifts?: ShiftUpdateManyWithoutTenantNestedInput
    bookings?: BookingUpdateManyWithoutTenantNestedInput
    cutoff?: CutoffUpdateOneWithoutTenantNestedInput
    vendors?: VendorUpdateManyWithoutTenantNestedInput
    roles?: RoleUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPoliciesInput = {
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutTenantNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTenantNestedInput
    cutoff?: CutoffUncheckedUpdateOneWithoutTenantNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutTenantNestedInput
    roles?: RoleUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type PolicyPermissionUpsertWithWhereUniqueWithoutPolicyInput = {
    where: PolicyPermissionWhereUniqueInput
    update: XOR<PolicyPermissionUpdateWithoutPolicyInput, PolicyPermissionUncheckedUpdateWithoutPolicyInput>
    create: XOR<PolicyPermissionCreateWithoutPolicyInput, PolicyPermissionUncheckedCreateWithoutPolicyInput>
  }

  export type PolicyPermissionUpdateWithWhereUniqueWithoutPolicyInput = {
    where: PolicyPermissionWhereUniqueInput
    data: XOR<PolicyPermissionUpdateWithoutPolicyInput, PolicyPermissionUncheckedUpdateWithoutPolicyInput>
  }

  export type PolicyPermissionUpdateManyWithWhereWithoutPolicyInput = {
    where: PolicyPermissionScalarWhereInput
    data: XOR<PolicyPermissionUpdateManyMutationInput, PolicyPermissionUncheckedUpdateManyWithoutPolicyInput>
  }

  export type RolePolicyUpsertWithWhereUniqueWithoutPolicyInput = {
    where: RolePolicyWhereUniqueInput
    update: XOR<RolePolicyUpdateWithoutPolicyInput, RolePolicyUncheckedUpdateWithoutPolicyInput>
    create: XOR<RolePolicyCreateWithoutPolicyInput, RolePolicyUncheckedCreateWithoutPolicyInput>
  }

  export type RolePolicyUpdateWithWhereUniqueWithoutPolicyInput = {
    where: RolePolicyWhereUniqueInput
    data: XOR<RolePolicyUpdateWithoutPolicyInput, RolePolicyUncheckedUpdateWithoutPolicyInput>
  }

  export type RolePolicyUpdateManyWithWhereWithoutPolicyInput = {
    where: RolePolicyScalarWhereInput
    data: XOR<RolePolicyUpdateManyMutationInput, RolePolicyUncheckedUpdateManyWithoutPolicyInput>
  }

  export type RolePolicyScalarWhereInput = {
    AND?: RolePolicyScalarWhereInput | RolePolicyScalarWhereInput[]
    OR?: RolePolicyScalarWhereInput[]
    NOT?: RolePolicyScalarWhereInput | RolePolicyScalarWhereInput[]
    role_id?: IntFilter<"RolePolicy"> | number
    policy_id?: IntFilter<"RolePolicy"> | number
  }

  export type PolicyCreateWithoutPolicy_permissionsInput = {
    name: string
    description?: string | null
    is_active?: boolean
    is_system_policy?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    tenant?: TenantCreateNestedOneWithoutPoliciesInput
    role_policies?: RolePolicyCreateNestedManyWithoutPolicyInput
  }

  export type PolicyUncheckedCreateWithoutPolicy_permissionsInput = {
    policy_id?: number
    tenant_id?: string | null
    name: string
    description?: string | null
    is_active?: boolean
    is_system_policy?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    role_policies?: RolePolicyUncheckedCreateNestedManyWithoutPolicyInput
  }

  export type PolicyCreateOrConnectWithoutPolicy_permissionsInput = {
    where: PolicyWhereUniqueInput
    create: XOR<PolicyCreateWithoutPolicy_permissionsInput, PolicyUncheckedCreateWithoutPolicy_permissionsInput>
  }

  export type PermissionCreateWithoutPolicy_permissionsInput = {
    module: string
    action: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PermissionUncheckedCreateWithoutPolicy_permissionsInput = {
    permission_id?: number
    module: string
    action: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PermissionCreateOrConnectWithoutPolicy_permissionsInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutPolicy_permissionsInput, PermissionUncheckedCreateWithoutPolicy_permissionsInput>
  }

  export type PolicyUpsertWithoutPolicy_permissionsInput = {
    update: XOR<PolicyUpdateWithoutPolicy_permissionsInput, PolicyUncheckedUpdateWithoutPolicy_permissionsInput>
    create: XOR<PolicyCreateWithoutPolicy_permissionsInput, PolicyUncheckedCreateWithoutPolicy_permissionsInput>
    where?: PolicyWhereInput
  }

  export type PolicyUpdateToOneWithWhereWithoutPolicy_permissionsInput = {
    where?: PolicyWhereInput
    data: XOR<PolicyUpdateWithoutPolicy_permissionsInput, PolicyUncheckedUpdateWithoutPolicy_permissionsInput>
  }

  export type PolicyUpdateWithoutPolicy_permissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_system_policy?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutPoliciesNestedInput
    role_policies?: RolePolicyUpdateManyWithoutPolicyNestedInput
  }

  export type PolicyUncheckedUpdateWithoutPolicy_permissionsInput = {
    policy_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_system_policy?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role_policies?: RolePolicyUncheckedUpdateManyWithoutPolicyNestedInput
  }

  export type PermissionUpsertWithoutPolicy_permissionsInput = {
    update: XOR<PermissionUpdateWithoutPolicy_permissionsInput, PermissionUncheckedUpdateWithoutPolicy_permissionsInput>
    create: XOR<PermissionCreateWithoutPolicy_permissionsInput, PermissionUncheckedCreateWithoutPolicy_permissionsInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutPolicy_permissionsInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutPolicy_permissionsInput, PermissionUncheckedUpdateWithoutPolicy_permissionsInput>
  }

  export type PermissionUpdateWithoutPolicy_permissionsInput = {
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateWithoutPolicy_permissionsInput = {
    permission_id?: IntFieldUpdateOperationsInput | number
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutRolesInput = {
    tenant_id: string
    name: string
    address?: string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    teams?: TeamCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    shifts?: ShiftCreateNestedManyWithoutTenantInput
    bookings?: BookingCreateNestedManyWithoutTenantInput
    policies?: PolicyCreateNestedManyWithoutTenantInput
    cutoff?: CutoffCreateNestedOneWithoutTenantInput
    vendors?: VendorCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutRolesInput = {
    tenant_id: string
    name: string
    address?: string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutTenantInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTenantInput
    policies?: PolicyUncheckedCreateNestedManyWithoutTenantInput
    cutoff?: CutoffUncheckedCreateNestedOneWithoutTenantInput
    vendors?: VendorUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutRolesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutRolesInput, TenantUncheckedCreateWithoutRolesInput>
  }

  export type RolePolicyCreateWithoutRoleInput = {
    policy: PolicyCreateNestedOneWithoutRole_policiesInput
  }

  export type RolePolicyUncheckedCreateWithoutRoleInput = {
    policy_id: number
  }

  export type RolePolicyCreateOrConnectWithoutRoleInput = {
    where: RolePolicyWhereUniqueInput
    create: XOR<RolePolicyCreateWithoutRoleInput, RolePolicyUncheckedCreateWithoutRoleInput>
  }

  export type RolePolicyCreateManyRoleInputEnvelope = {
    data: RolePolicyCreateManyRoleInput | RolePolicyCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type AdminCreateWithoutRoleInput = {
    name: string
    email: string
    phone: string
    password: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AdminUncheckedCreateWithoutRoleInput = {
    admin_id?: number
    name: string
    email: string
    phone: string
    password: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AdminCreateOrConnectWithoutRoleInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutRoleInput, AdminUncheckedCreateWithoutRoleInput>
  }

  export type AdminCreateManyRoleInputEnvelope = {
    data: AdminCreateManyRoleInput | AdminCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type VendorUserCreateWithoutRoleInput = {
    tenant_id: string
    name: string
    email: string
    phone: string
    password: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    vendor: VendorCreateNestedOneWithoutVendor_usersInput
  }

  export type VendorUserUncheckedCreateWithoutRoleInput = {
    vendor_user_id?: number
    tenant_id: string
    vendor_id: number
    name: string
    email: string
    phone: string
    password: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorUserCreateOrConnectWithoutRoleInput = {
    where: VendorUserWhereUniqueInput
    create: XOR<VendorUserCreateWithoutRoleInput, VendorUserUncheckedCreateWithoutRoleInput>
  }

  export type VendorUserCreateManyRoleInputEnvelope = {
    data: VendorUserCreateManyRoleInput | VendorUserCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeCreateWithoutRoleInput = {
    name: string
    employee_code: string
    email: string
    password: string
    phone: string
    alternate_phone?: string | null
    special_needs?: string | null
    special_needs_start_date?: Date | string | null
    special_needs_end_date?: Date | string | null
    address?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    gender?: $Enums.GenderEnum | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutEmployeesInput
    team?: TeamCreateNestedOneWithoutEmployeesInput
    bookings?: BookingCreateNestedManyWithoutEmployeeInput
    weekoff_config?: WeekoffConfigCreateNestedOneWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutRoleInput = {
    employee_id?: number
    tenant_id: string
    name: string
    employee_code: string
    email: string
    password: string
    team_id?: number | null
    phone: string
    alternate_phone?: string | null
    special_needs?: string | null
    special_needs_start_date?: Date | string | null
    special_needs_end_date?: Date | string | null
    address?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    gender?: $Enums.GenderEnum | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutEmployeeInput
    weekoff_config?: WeekoffConfigUncheckedCreateNestedOneWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutRoleInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutRoleInput, EmployeeUncheckedCreateWithoutRoleInput>
  }

  export type EmployeeCreateManyRoleInputEnvelope = {
    data: EmployeeCreateManyRoleInput | EmployeeCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutRolesInput = {
    update: XOR<TenantUpdateWithoutRolesInput, TenantUncheckedUpdateWithoutRolesInput>
    create: XOR<TenantCreateWithoutRolesInput, TenantUncheckedCreateWithoutRolesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutRolesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutRolesInput, TenantUncheckedUpdateWithoutRolesInput>
  }

  export type TenantUpdateWithoutRolesInput = {
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    shifts?: ShiftUpdateManyWithoutTenantNestedInput
    bookings?: BookingUpdateManyWithoutTenantNestedInput
    policies?: PolicyUpdateManyWithoutTenantNestedInput
    cutoff?: CutoffUpdateOneWithoutTenantNestedInput
    vendors?: VendorUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutRolesInput = {
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutTenantNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTenantNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutTenantNestedInput
    cutoff?: CutoffUncheckedUpdateOneWithoutTenantNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type RolePolicyUpsertWithWhereUniqueWithoutRoleInput = {
    where: RolePolicyWhereUniqueInput
    update: XOR<RolePolicyUpdateWithoutRoleInput, RolePolicyUncheckedUpdateWithoutRoleInput>
    create: XOR<RolePolicyCreateWithoutRoleInput, RolePolicyUncheckedCreateWithoutRoleInput>
  }

  export type RolePolicyUpdateWithWhereUniqueWithoutRoleInput = {
    where: RolePolicyWhereUniqueInput
    data: XOR<RolePolicyUpdateWithoutRoleInput, RolePolicyUncheckedUpdateWithoutRoleInput>
  }

  export type RolePolicyUpdateManyWithWhereWithoutRoleInput = {
    where: RolePolicyScalarWhereInput
    data: XOR<RolePolicyUpdateManyMutationInput, RolePolicyUncheckedUpdateManyWithoutRoleInput>
  }

  export type AdminUpsertWithWhereUniqueWithoutRoleInput = {
    where: AdminWhereUniqueInput
    update: XOR<AdminUpdateWithoutRoleInput, AdminUncheckedUpdateWithoutRoleInput>
    create: XOR<AdminCreateWithoutRoleInput, AdminUncheckedCreateWithoutRoleInput>
  }

  export type AdminUpdateWithWhereUniqueWithoutRoleInput = {
    where: AdminWhereUniqueInput
    data: XOR<AdminUpdateWithoutRoleInput, AdminUncheckedUpdateWithoutRoleInput>
  }

  export type AdminUpdateManyWithWhereWithoutRoleInput = {
    where: AdminScalarWhereInput
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyWithoutRoleInput>
  }

  export type AdminScalarWhereInput = {
    AND?: AdminScalarWhereInput | AdminScalarWhereInput[]
    OR?: AdminScalarWhereInput[]
    NOT?: AdminScalarWhereInput | AdminScalarWhereInput[]
    admin_id?: IntFilter<"Admin"> | number
    name?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    phone?: StringFilter<"Admin"> | string
    password?: StringFilter<"Admin"> | string
    role_id?: IntFilter<"Admin"> | number
    is_active?: BoolFilter<"Admin"> | boolean
    created_at?: DateTimeFilter<"Admin"> | Date | string
    updated_at?: DateTimeFilter<"Admin"> | Date | string
  }

  export type VendorUserUpsertWithWhereUniqueWithoutRoleInput = {
    where: VendorUserWhereUniqueInput
    update: XOR<VendorUserUpdateWithoutRoleInput, VendorUserUncheckedUpdateWithoutRoleInput>
    create: XOR<VendorUserCreateWithoutRoleInput, VendorUserUncheckedCreateWithoutRoleInput>
  }

  export type VendorUserUpdateWithWhereUniqueWithoutRoleInput = {
    where: VendorUserWhereUniqueInput
    data: XOR<VendorUserUpdateWithoutRoleInput, VendorUserUncheckedUpdateWithoutRoleInput>
  }

  export type VendorUserUpdateManyWithWhereWithoutRoleInput = {
    where: VendorUserScalarWhereInput
    data: XOR<VendorUserUpdateManyMutationInput, VendorUserUncheckedUpdateManyWithoutRoleInput>
  }

  export type EmployeeUpsertWithWhereUniqueWithoutRoleInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutRoleInput, EmployeeUncheckedUpdateWithoutRoleInput>
    create: XOR<EmployeeCreateWithoutRoleInput, EmployeeUncheckedCreateWithoutRoleInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutRoleInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutRoleInput, EmployeeUncheckedUpdateWithoutRoleInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutRoleInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutRoleInput>
  }

  export type RoleCreateWithoutRole_policiesInput = {
    name: string
    description?: string | null
    is_active?: boolean
    is_system_role?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    tenant?: TenantCreateNestedOneWithoutRolesInput
    admins?: AdminCreateNestedManyWithoutRoleInput
    vendor_users?: VendorUserCreateNestedManyWithoutRoleInput
    employees?: EmployeeCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutRole_policiesInput = {
    role_id?: number
    name: string
    description?: string | null
    is_active?: boolean
    tenant_id?: string | null
    is_system_role?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    admins?: AdminUncheckedCreateNestedManyWithoutRoleInput
    vendor_users?: VendorUserUncheckedCreateNestedManyWithoutRoleInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutRole_policiesInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutRole_policiesInput, RoleUncheckedCreateWithoutRole_policiesInput>
  }

  export type PolicyCreateWithoutRole_policiesInput = {
    name: string
    description?: string | null
    is_active?: boolean
    is_system_policy?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    tenant?: TenantCreateNestedOneWithoutPoliciesInput
    policy_permissions?: PolicyPermissionCreateNestedManyWithoutPolicyInput
  }

  export type PolicyUncheckedCreateWithoutRole_policiesInput = {
    policy_id?: number
    tenant_id?: string | null
    name: string
    description?: string | null
    is_active?: boolean
    is_system_policy?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    policy_permissions?: PolicyPermissionUncheckedCreateNestedManyWithoutPolicyInput
  }

  export type PolicyCreateOrConnectWithoutRole_policiesInput = {
    where: PolicyWhereUniqueInput
    create: XOR<PolicyCreateWithoutRole_policiesInput, PolicyUncheckedCreateWithoutRole_policiesInput>
  }

  export type RoleUpsertWithoutRole_policiesInput = {
    update: XOR<RoleUpdateWithoutRole_policiesInput, RoleUncheckedUpdateWithoutRole_policiesInput>
    create: XOR<RoleCreateWithoutRole_policiesInput, RoleUncheckedCreateWithoutRole_policiesInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutRole_policiesInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutRole_policiesInput, RoleUncheckedUpdateWithoutRole_policiesInput>
  }

  export type RoleUpdateWithoutRole_policiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_system_role?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutRolesNestedInput
    admins?: AdminUpdateManyWithoutRoleNestedInput
    vendor_users?: VendorUserUpdateManyWithoutRoleNestedInput
    employees?: EmployeeUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutRole_policiesInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    tenant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_system_role?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    admins?: AdminUncheckedUpdateManyWithoutRoleNestedInput
    vendor_users?: VendorUserUncheckedUpdateManyWithoutRoleNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type PolicyUpsertWithoutRole_policiesInput = {
    update: XOR<PolicyUpdateWithoutRole_policiesInput, PolicyUncheckedUpdateWithoutRole_policiesInput>
    create: XOR<PolicyCreateWithoutRole_policiesInput, PolicyUncheckedCreateWithoutRole_policiesInput>
    where?: PolicyWhereInput
  }

  export type PolicyUpdateToOneWithWhereWithoutRole_policiesInput = {
    where?: PolicyWhereInput
    data: XOR<PolicyUpdateWithoutRole_policiesInput, PolicyUncheckedUpdateWithoutRole_policiesInput>
  }

  export type PolicyUpdateWithoutRole_policiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_system_policy?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutPoliciesNestedInput
    policy_permissions?: PolicyPermissionUpdateManyWithoutPolicyNestedInput
  }

  export type PolicyUncheckedUpdateWithoutRole_policiesInput = {
    policy_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_system_policy?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    policy_permissions?: PolicyPermissionUncheckedUpdateManyWithoutPolicyNestedInput
  }

  export type RouteManagementBookingCreateManyRoute_managementInput = {
    id?: number
    booking_id: number
    stop_order: number
    estimated_pickup_time?: string | null
    estimated_drop_time?: string | null
    distance_from_previous?: number | null
    cumulative_distance?: number | null
    created_at?: Date | string
  }

  export type RouteManagementBookingUpdateWithoutRoute_managementInput = {
    booking_id?: IntFieldUpdateOperationsInput | number
    stop_order?: IntFieldUpdateOperationsInput | number
    estimated_pickup_time?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_drop_time?: NullableStringFieldUpdateOperationsInput | string | null
    distance_from_previous?: NullableFloatFieldUpdateOperationsInput | number | null
    cumulative_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteManagementBookingUncheckedUpdateWithoutRoute_managementInput = {
    id?: IntFieldUpdateOperationsInput | number
    booking_id?: IntFieldUpdateOperationsInput | number
    stop_order?: IntFieldUpdateOperationsInput | number
    estimated_pickup_time?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_drop_time?: NullableStringFieldUpdateOperationsInput | string | null
    distance_from_previous?: NullableFloatFieldUpdateOperationsInput | number | null
    cumulative_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteManagementBookingUncheckedUpdateManyWithoutRoute_managementInput = {
    id?: IntFieldUpdateOperationsInput | number
    booking_id?: IntFieldUpdateOperationsInput | number
    stop_order?: IntFieldUpdateOperationsInput | number
    estimated_pickup_time?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_drop_time?: NullableStringFieldUpdateOperationsInput | string | null
    distance_from_previous?: NullableFloatFieldUpdateOperationsInput | number | null
    cumulative_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleCreateManyDriverInput = {
    vehicle_id?: number
    vehicle_type_id: number
    vendor_id: number
    rc_number: string
    rc_expiry_date?: Date | string | null
    description?: string | null
    puc_number?: string | null
    puc_expiry_date?: Date | string | null
    puc_url?: string | null
    fitness_number?: string | null
    fitness_expiry_date?: Date | string | null
    fitness_url?: string | null
    tax_receipt_number?: string | null
    tax_receipt_date?: Date | string | null
    tax_receipt_url?: string | null
    insurance_number?: string | null
    insurance_expiry_date?: Date | string | null
    insurance_url?: string | null
    permit_number?: string | null
    permit_expiry_date?: Date | string | null
    permit_url?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VehicleUpdateWithoutDriverInput = {
    rc_number?: StringFieldUpdateOperationsInput | string
    rc_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    puc_number?: NullableStringFieldUpdateOperationsInput | string | null
    puc_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    puc_url?: NullableStringFieldUpdateOperationsInput | string | null
    fitness_number?: NullableStringFieldUpdateOperationsInput | string | null
    fitness_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fitness_url?: NullableStringFieldUpdateOperationsInput | string | null
    tax_receipt_number?: NullableStringFieldUpdateOperationsInput | string | null
    tax_receipt_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tax_receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_number?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurance_url?: NullableStringFieldUpdateOperationsInput | string | null
    permit_number?: NullableStringFieldUpdateOperationsInput | string | null
    permit_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permit_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle_type?: VehicleTypeUpdateOneRequiredWithoutVehiclesNestedInput
    vendor?: VendorUpdateOneRequiredWithoutVehiclesNestedInput
  }

  export type VehicleUncheckedUpdateWithoutDriverInput = {
    vehicle_id?: IntFieldUpdateOperationsInput | number
    vehicle_type_id?: IntFieldUpdateOperationsInput | number
    vendor_id?: IntFieldUpdateOperationsInput | number
    rc_number?: StringFieldUpdateOperationsInput | string
    rc_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    puc_number?: NullableStringFieldUpdateOperationsInput | string | null
    puc_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    puc_url?: NullableStringFieldUpdateOperationsInput | string | null
    fitness_number?: NullableStringFieldUpdateOperationsInput | string | null
    fitness_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fitness_url?: NullableStringFieldUpdateOperationsInput | string | null
    tax_receipt_number?: NullableStringFieldUpdateOperationsInput | string | null
    tax_receipt_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tax_receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_number?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurance_url?: NullableStringFieldUpdateOperationsInput | string | null
    permit_number?: NullableStringFieldUpdateOperationsInput | string | null
    permit_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permit_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleUncheckedUpdateManyWithoutDriverInput = {
    vehicle_id?: IntFieldUpdateOperationsInput | number
    vehicle_type_id?: IntFieldUpdateOperationsInput | number
    vendor_id?: IntFieldUpdateOperationsInput | number
    rc_number?: StringFieldUpdateOperationsInput | string
    rc_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    puc_number?: NullableStringFieldUpdateOperationsInput | string | null
    puc_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    puc_url?: NullableStringFieldUpdateOperationsInput | string | null
    fitness_number?: NullableStringFieldUpdateOperationsInput | string | null
    fitness_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fitness_url?: NullableStringFieldUpdateOperationsInput | string | null
    tax_receipt_number?: NullableStringFieldUpdateOperationsInput | string | null
    tax_receipt_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tax_receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_number?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurance_url?: NullableStringFieldUpdateOperationsInput | string | null
    permit_number?: NullableStringFieldUpdateOperationsInput | string | null
    permit_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permit_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleCreateManyVehicle_typeInput = {
    vehicle_id?: number
    vendor_id: number
    driver_id?: number | null
    rc_number: string
    rc_expiry_date?: Date | string | null
    description?: string | null
    puc_number?: string | null
    puc_expiry_date?: Date | string | null
    puc_url?: string | null
    fitness_number?: string | null
    fitness_expiry_date?: Date | string | null
    fitness_url?: string | null
    tax_receipt_number?: string | null
    tax_receipt_date?: Date | string | null
    tax_receipt_url?: string | null
    insurance_number?: string | null
    insurance_expiry_date?: Date | string | null
    insurance_url?: string | null
    permit_number?: string | null
    permit_expiry_date?: Date | string | null
    permit_url?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VehicleUpdateWithoutVehicle_typeInput = {
    rc_number?: StringFieldUpdateOperationsInput | string
    rc_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    puc_number?: NullableStringFieldUpdateOperationsInput | string | null
    puc_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    puc_url?: NullableStringFieldUpdateOperationsInput | string | null
    fitness_number?: NullableStringFieldUpdateOperationsInput | string | null
    fitness_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fitness_url?: NullableStringFieldUpdateOperationsInput | string | null
    tax_receipt_number?: NullableStringFieldUpdateOperationsInput | string | null
    tax_receipt_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tax_receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_number?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurance_url?: NullableStringFieldUpdateOperationsInput | string | null
    permit_number?: NullableStringFieldUpdateOperationsInput | string | null
    permit_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permit_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutVehiclesNestedInput
    driver?: DriverUpdateOneWithoutVehiclesNestedInput
  }

  export type VehicleUncheckedUpdateWithoutVehicle_typeInput = {
    vehicle_id?: IntFieldUpdateOperationsInput | number
    vendor_id?: IntFieldUpdateOperationsInput | number
    driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    rc_number?: StringFieldUpdateOperationsInput | string
    rc_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    puc_number?: NullableStringFieldUpdateOperationsInput | string | null
    puc_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    puc_url?: NullableStringFieldUpdateOperationsInput | string | null
    fitness_number?: NullableStringFieldUpdateOperationsInput | string | null
    fitness_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fitness_url?: NullableStringFieldUpdateOperationsInput | string | null
    tax_receipt_number?: NullableStringFieldUpdateOperationsInput | string | null
    tax_receipt_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tax_receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_number?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurance_url?: NullableStringFieldUpdateOperationsInput | string | null
    permit_number?: NullableStringFieldUpdateOperationsInput | string | null
    permit_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permit_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleUncheckedUpdateManyWithoutVehicle_typeInput = {
    vehicle_id?: IntFieldUpdateOperationsInput | number
    vendor_id?: IntFieldUpdateOperationsInput | number
    driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    rc_number?: StringFieldUpdateOperationsInput | string
    rc_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    puc_number?: NullableStringFieldUpdateOperationsInput | string | null
    puc_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    puc_url?: NullableStringFieldUpdateOperationsInput | string | null
    fitness_number?: NullableStringFieldUpdateOperationsInput | string | null
    fitness_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fitness_url?: NullableStringFieldUpdateOperationsInput | string | null
    tax_receipt_number?: NullableStringFieldUpdateOperationsInput | string | null
    tax_receipt_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tax_receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_number?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurance_url?: NullableStringFieldUpdateOperationsInput | string | null
    permit_number?: NullableStringFieldUpdateOperationsInput | string | null
    permit_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permit_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverCreateManyVendorInput = {
    driver_id?: number
    name: string
    code: string
    email: string
    phone: string
    gender?: $Enums.GenderEnum | null
    password: string
    date_of_birth?: Date | string | null
    date_of_joining?: Date | string | null
    permanent_address?: string | null
    current_address?: string | null
    photo_url?: string | null
    bg_verify_status?: $Enums.VerificationStatusEnum | null
    bg_expiry_date?: Date | string | null
    bg_verify_url?: string | null
    police_verify_status?: $Enums.VerificationStatusEnum | null
    police_expiry_date?: Date | string | null
    police_verify_url?: string | null
    medical_verify_status?: $Enums.VerificationStatusEnum | null
    medical_expiry_date?: Date | string | null
    medical_verify_url?: string | null
    training_verify_status?: $Enums.VerificationStatusEnum | null
    training_expiry_date?: Date | string | null
    training_verify_url?: string | null
    eye_verify_status?: $Enums.VerificationStatusEnum | null
    eye_expiry_date?: Date | string | null
    eye_verify_url?: string | null
    license_number?: string | null
    license_expiry_date?: Date | string | null
    license_url?: string | null
    badge_number?: string | null
    badge_expiry_date?: Date | string | null
    badge_url?: string | null
    alt_govt_id_number?: string | null
    alt_govt_id_type?: string | null
    alt_govt_id_url?: string | null
    induction_date?: Date | string | null
    induction_url?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VehicleTypeCreateManyVendorInput = {
    vehicle_type_id?: number
    name: string
    description?: string | null
    seats: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VehicleCreateManyVendorInput = {
    vehicle_id?: number
    vehicle_type_id: number
    driver_id?: number | null
    rc_number: string
    rc_expiry_date?: Date | string | null
    description?: string | null
    puc_number?: string | null
    puc_expiry_date?: Date | string | null
    puc_url?: string | null
    fitness_number?: string | null
    fitness_expiry_date?: Date | string | null
    fitness_url?: string | null
    tax_receipt_number?: string | null
    tax_receipt_date?: Date | string | null
    tax_receipt_url?: string | null
    insurance_number?: string | null
    insurance_expiry_date?: Date | string | null
    insurance_url?: string | null
    permit_number?: string | null
    permit_expiry_date?: Date | string | null
    permit_url?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorUserCreateManyVendorInput = {
    vendor_user_id?: number
    tenant_id: string
    name: string
    email: string
    phone: string
    password: string
    role_id: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DriverUpdateWithoutVendorInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    password?: StringFieldUpdateOperationsInput | string
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_of_joining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permanent_address?: NullableStringFieldUpdateOperationsInput | string | null
    current_address?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    bg_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    bg_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bg_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    police_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    police_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    police_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    medical_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    medical_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medical_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    training_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    training_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    training_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    eye_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    eye_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eye_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    license_number?: NullableStringFieldUpdateOperationsInput | string | null
    license_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    license_url?: NullableStringFieldUpdateOperationsInput | string | null
    badge_number?: NullableStringFieldUpdateOperationsInput | string | null
    badge_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge_url?: NullableStringFieldUpdateOperationsInput | string | null
    alt_govt_id_number?: NullableStringFieldUpdateOperationsInput | string | null
    alt_govt_id_type?: NullableStringFieldUpdateOperationsInput | string | null
    alt_govt_id_url?: NullableStringFieldUpdateOperationsInput | string | null
    induction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    induction_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicles?: VehicleUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateWithoutVendorInput = {
    driver_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    password?: StringFieldUpdateOperationsInput | string
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_of_joining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permanent_address?: NullableStringFieldUpdateOperationsInput | string | null
    current_address?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    bg_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    bg_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bg_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    police_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    police_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    police_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    medical_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    medical_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medical_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    training_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    training_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    training_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    eye_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    eye_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eye_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    license_number?: NullableStringFieldUpdateOperationsInput | string | null
    license_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    license_url?: NullableStringFieldUpdateOperationsInput | string | null
    badge_number?: NullableStringFieldUpdateOperationsInput | string | null
    badge_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge_url?: NullableStringFieldUpdateOperationsInput | string | null
    alt_govt_id_number?: NullableStringFieldUpdateOperationsInput | string | null
    alt_govt_id_type?: NullableStringFieldUpdateOperationsInput | string | null
    alt_govt_id_url?: NullableStringFieldUpdateOperationsInput | string | null
    induction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    induction_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicles?: VehicleUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateManyWithoutVendorInput = {
    driver_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    password?: StringFieldUpdateOperationsInput | string
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_of_joining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permanent_address?: NullableStringFieldUpdateOperationsInput | string | null
    current_address?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    bg_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    bg_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bg_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    police_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    police_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    police_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    medical_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    medical_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medical_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    training_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    training_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    training_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    eye_verify_status?: NullableEnumVerificationStatusEnumFieldUpdateOperationsInput | $Enums.VerificationStatusEnum | null
    eye_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eye_verify_url?: NullableStringFieldUpdateOperationsInput | string | null
    license_number?: NullableStringFieldUpdateOperationsInput | string | null
    license_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    license_url?: NullableStringFieldUpdateOperationsInput | string | null
    badge_number?: NullableStringFieldUpdateOperationsInput | string | null
    badge_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge_url?: NullableStringFieldUpdateOperationsInput | string | null
    alt_govt_id_number?: NullableStringFieldUpdateOperationsInput | string | null
    alt_govt_id_type?: NullableStringFieldUpdateOperationsInput | string | null
    alt_govt_id_url?: NullableStringFieldUpdateOperationsInput | string | null
    induction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    induction_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleTypeUpdateWithoutVendorInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicles?: VehicleUpdateManyWithoutVehicle_typeNestedInput
  }

  export type VehicleTypeUncheckedUpdateWithoutVendorInput = {
    vehicle_type_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicles?: VehicleUncheckedUpdateManyWithoutVehicle_typeNestedInput
  }

  export type VehicleTypeUncheckedUpdateManyWithoutVendorInput = {
    vehicle_type_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleUpdateWithoutVendorInput = {
    rc_number?: StringFieldUpdateOperationsInput | string
    rc_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    puc_number?: NullableStringFieldUpdateOperationsInput | string | null
    puc_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    puc_url?: NullableStringFieldUpdateOperationsInput | string | null
    fitness_number?: NullableStringFieldUpdateOperationsInput | string | null
    fitness_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fitness_url?: NullableStringFieldUpdateOperationsInput | string | null
    tax_receipt_number?: NullableStringFieldUpdateOperationsInput | string | null
    tax_receipt_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tax_receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_number?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurance_url?: NullableStringFieldUpdateOperationsInput | string | null
    permit_number?: NullableStringFieldUpdateOperationsInput | string | null
    permit_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permit_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle_type?: VehicleTypeUpdateOneRequiredWithoutVehiclesNestedInput
    driver?: DriverUpdateOneWithoutVehiclesNestedInput
  }

  export type VehicleUncheckedUpdateWithoutVendorInput = {
    vehicle_id?: IntFieldUpdateOperationsInput | number
    vehicle_type_id?: IntFieldUpdateOperationsInput | number
    driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    rc_number?: StringFieldUpdateOperationsInput | string
    rc_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    puc_number?: NullableStringFieldUpdateOperationsInput | string | null
    puc_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    puc_url?: NullableStringFieldUpdateOperationsInput | string | null
    fitness_number?: NullableStringFieldUpdateOperationsInput | string | null
    fitness_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fitness_url?: NullableStringFieldUpdateOperationsInput | string | null
    tax_receipt_number?: NullableStringFieldUpdateOperationsInput | string | null
    tax_receipt_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tax_receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_number?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurance_url?: NullableStringFieldUpdateOperationsInput | string | null
    permit_number?: NullableStringFieldUpdateOperationsInput | string | null
    permit_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permit_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleUncheckedUpdateManyWithoutVendorInput = {
    vehicle_id?: IntFieldUpdateOperationsInput | number
    vehicle_type_id?: IntFieldUpdateOperationsInput | number
    driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    rc_number?: StringFieldUpdateOperationsInput | string
    rc_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    puc_number?: NullableStringFieldUpdateOperationsInput | string | null
    puc_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    puc_url?: NullableStringFieldUpdateOperationsInput | string | null
    fitness_number?: NullableStringFieldUpdateOperationsInput | string | null
    fitness_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fitness_url?: NullableStringFieldUpdateOperationsInput | string | null
    tax_receipt_number?: NullableStringFieldUpdateOperationsInput | string | null
    tax_receipt_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tax_receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_number?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurance_url?: NullableStringFieldUpdateOperationsInput | string | null
    permit_number?: NullableStringFieldUpdateOperationsInput | string | null
    permit_expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permit_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUserUpdateWithoutVendorInput = {
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutVendor_usersNestedInput
  }

  export type VendorUserUncheckedUpdateWithoutVendorInput = {
    vendor_user_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUserUncheckedUpdateManyWithoutVendorInput = {
    vendor_user_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyEmployeeInput = {
    booking_id?: number
    tenant_id: string
    employee_code: string
    shift_id?: number | null
    team_id?: number | null
    booking_date: Date | string
    pickup_latitude?: number | null
    pickup_longitude?: number | null
    pickup_location?: string | null
    drop_latitude?: number | null
    drop_longitude?: number | null
    drop_location?: string | null
    status?: $Enums.BookingStatusEnum
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingUpdateWithoutEmployeeInput = {
    employee_code?: StringFieldUpdateOperationsInput | string
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pickup_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    drop_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusEnumFieldUpdateOperationsInput | $Enums.BookingStatusEnum
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBookingsNestedInput
    shift?: ShiftUpdateOneWithoutBookingsNestedInput
    team?: TeamUpdateOneWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutEmployeeInput = {
    booking_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    shift_id?: NullableIntFieldUpdateOperationsInput | number | null
    team_id?: NullableIntFieldUpdateOperationsInput | number | null
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pickup_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    drop_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusEnumFieldUpdateOperationsInput | $Enums.BookingStatusEnum
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyWithoutEmployeeInput = {
    booking_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    shift_id?: NullableIntFieldUpdateOperationsInput | number | null
    team_id?: NullableIntFieldUpdateOperationsInput | number | null
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pickup_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    drop_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusEnumFieldUpdateOperationsInput | $Enums.BookingStatusEnum
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyShiftInput = {
    booking_id?: number
    tenant_id: string
    employee_id: number
    employee_code: string
    team_id?: number | null
    booking_date: Date | string
    pickup_latitude?: number | null
    pickup_longitude?: number | null
    pickup_location?: string | null
    drop_latitude?: number | null
    drop_longitude?: number | null
    drop_location?: string | null
    status?: $Enums.BookingStatusEnum
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingUpdateWithoutShiftInput = {
    employee_code?: StringFieldUpdateOperationsInput | string
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pickup_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    drop_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusEnumFieldUpdateOperationsInput | $Enums.BookingStatusEnum
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBookingsNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutBookingsNestedInput
    team?: TeamUpdateOneWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutShiftInput = {
    booking_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    employee_id?: IntFieldUpdateOperationsInput | number
    employee_code?: StringFieldUpdateOperationsInput | string
    team_id?: NullableIntFieldUpdateOperationsInput | number | null
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pickup_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    drop_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusEnumFieldUpdateOperationsInput | $Enums.BookingStatusEnum
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyWithoutShiftInput = {
    booking_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    employee_id?: IntFieldUpdateOperationsInput | number
    employee_code?: StringFieldUpdateOperationsInput | string
    team_id?: NullableIntFieldUpdateOperationsInput | number | null
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pickup_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    drop_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusEnumFieldUpdateOperationsInput | $Enums.BookingStatusEnum
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateManyTeamInput = {
    employee_id?: number
    tenant_id: string
    role_id: number
    name: string
    employee_code: string
    email: string
    password: string
    phone: string
    alternate_phone?: string | null
    special_needs?: string | null
    special_needs_start_date?: Date | string | null
    special_needs_end_date?: Date | string | null
    address?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    gender?: $Enums.GenderEnum | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingCreateManyTeamInput = {
    booking_id?: number
    tenant_id: string
    employee_id: number
    employee_code: string
    shift_id?: number | null
    booking_date: Date | string
    pickup_latitude?: number | null
    pickup_longitude?: number | null
    pickup_location?: string | null
    drop_latitude?: number | null
    drop_longitude?: number | null
    drop_location?: string | null
    status?: $Enums.BookingStatusEnum
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type EmployeeUpdateWithoutTeamInput = {
    name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    alternate_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    special_needs_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEmployeesNestedInput
    role?: RoleUpdateOneRequiredWithoutEmployeesNestedInput
    bookings?: BookingUpdateManyWithoutEmployeeNestedInput
    weekoff_config?: WeekoffConfigUpdateOneWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutTeamInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    alternate_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    special_needs_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutEmployeeNestedInput
    weekoff_config?: WeekoffConfigUncheckedUpdateOneWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutTeamInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    role_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    alternate_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    special_needs_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutTeamInput = {
    employee_code?: StringFieldUpdateOperationsInput | string
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pickup_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    drop_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusEnumFieldUpdateOperationsInput | $Enums.BookingStatusEnum
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBookingsNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutBookingsNestedInput
    shift?: ShiftUpdateOneWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutTeamInput = {
    booking_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    employee_id?: IntFieldUpdateOperationsInput | number
    employee_code?: StringFieldUpdateOperationsInput | string
    shift_id?: NullableIntFieldUpdateOperationsInput | number | null
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pickup_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    drop_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusEnumFieldUpdateOperationsInput | $Enums.BookingStatusEnum
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyWithoutTeamInput = {
    booking_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    employee_id?: IntFieldUpdateOperationsInput | number
    employee_code?: StringFieldUpdateOperationsInput | string
    shift_id?: NullableIntFieldUpdateOperationsInput | number | null
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pickup_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    drop_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusEnumFieldUpdateOperationsInput | $Enums.BookingStatusEnum
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateManyTenantInput = {
    team_id?: number
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type EmployeeCreateManyTenantInput = {
    employee_id?: number
    role_id: number
    name: string
    employee_code: string
    email: string
    password: string
    team_id?: number | null
    phone: string
    alternate_phone?: string | null
    special_needs?: string | null
    special_needs_start_date?: Date | string | null
    special_needs_end_date?: Date | string | null
    address?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    gender?: $Enums.GenderEnum | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ShiftCreateManyTenantInput = {
    shift_id?: number
    shift_code: string
    log_type: $Enums.ShiftLogTypeEnum
    shift_time: Date | string
    pickup_type?: $Enums.PickupTypeEnum | null
    gender?: $Enums.GenderEnum | null
    waiting_time_minutes?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingCreateManyTenantInput = {
    booking_id?: number
    employee_id: number
    employee_code: string
    shift_id?: number | null
    team_id?: number | null
    booking_date: Date | string
    pickup_latitude?: number | null
    pickup_longitude?: number | null
    pickup_location?: string | null
    drop_latitude?: number | null
    drop_longitude?: number | null
    drop_location?: string | null
    status?: $Enums.BookingStatusEnum
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PolicyCreateManyTenantInput = {
    policy_id?: number
    name: string
    description?: string | null
    is_active?: boolean
    is_system_policy?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorCreateManyTenantInput = {
    vendor_id?: number
    name: string
    vendor_code: string
    email?: string | null
    phone?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RoleCreateManyTenantInput = {
    role_id?: number
    name: string
    description?: string | null
    is_active?: boolean
    is_system_role?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TeamUpdateWithoutTenantInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUpdateManyWithoutTeamNestedInput
    bookings?: BookingUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutTenantInput = {
    team_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutTeamNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutTenantInput = {
    team_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUpdateWithoutTenantInput = {
    name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    alternate_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    special_needs_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutEmployeesNestedInput
    role?: RoleUpdateOneRequiredWithoutEmployeesNestedInput
    bookings?: BookingUpdateManyWithoutEmployeeNestedInput
    weekoff_config?: WeekoffConfigUpdateOneWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutTenantInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    team_id?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: StringFieldUpdateOperationsInput | string
    alternate_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    special_needs_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutEmployeeNestedInput
    weekoff_config?: WeekoffConfigUncheckedUpdateOneWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutTenantInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    team_id?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: StringFieldUpdateOperationsInput | string
    alternate_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    special_needs_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftUpdateWithoutTenantInput = {
    shift_code?: StringFieldUpdateOperationsInput | string
    log_type?: EnumShiftLogTypeEnumFieldUpdateOperationsInput | $Enums.ShiftLogTypeEnum
    shift_time?: DateTimeFieldUpdateOperationsInput | Date | string
    pickup_type?: NullableEnumPickupTypeEnumFieldUpdateOperationsInput | $Enums.PickupTypeEnum | null
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    waiting_time_minutes?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateWithoutTenantInput = {
    shift_id?: IntFieldUpdateOperationsInput | number
    shift_code?: StringFieldUpdateOperationsInput | string
    log_type?: EnumShiftLogTypeEnumFieldUpdateOperationsInput | $Enums.ShiftLogTypeEnum
    shift_time?: DateTimeFieldUpdateOperationsInput | Date | string
    pickup_type?: NullableEnumPickupTypeEnumFieldUpdateOperationsInput | $Enums.PickupTypeEnum | null
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    waiting_time_minutes?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateManyWithoutTenantInput = {
    shift_id?: IntFieldUpdateOperationsInput | number
    shift_code?: StringFieldUpdateOperationsInput | string
    log_type?: EnumShiftLogTypeEnumFieldUpdateOperationsInput | $Enums.ShiftLogTypeEnum
    shift_time?: DateTimeFieldUpdateOperationsInput | Date | string
    pickup_type?: NullableEnumPickupTypeEnumFieldUpdateOperationsInput | $Enums.PickupTypeEnum | null
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    waiting_time_minutes?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutTenantInput = {
    employee_code?: StringFieldUpdateOperationsInput | string
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pickup_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    drop_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusEnumFieldUpdateOperationsInput | $Enums.BookingStatusEnum
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutBookingsNestedInput
    shift?: ShiftUpdateOneWithoutBookingsNestedInput
    team?: TeamUpdateOneWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutTenantInput = {
    booking_id?: IntFieldUpdateOperationsInput | number
    employee_id?: IntFieldUpdateOperationsInput | number
    employee_code?: StringFieldUpdateOperationsInput | string
    shift_id?: NullableIntFieldUpdateOperationsInput | number | null
    team_id?: NullableIntFieldUpdateOperationsInput | number | null
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pickup_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    drop_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusEnumFieldUpdateOperationsInput | $Enums.BookingStatusEnum
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyWithoutTenantInput = {
    booking_id?: IntFieldUpdateOperationsInput | number
    employee_id?: IntFieldUpdateOperationsInput | number
    employee_code?: StringFieldUpdateOperationsInput | string
    shift_id?: NullableIntFieldUpdateOperationsInput | number | null
    team_id?: NullableIntFieldUpdateOperationsInput | number | null
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pickup_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    drop_latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusEnumFieldUpdateOperationsInput | $Enums.BookingStatusEnum
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyUpdateWithoutTenantInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_system_policy?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    policy_permissions?: PolicyPermissionUpdateManyWithoutPolicyNestedInput
    role_policies?: RolePolicyUpdateManyWithoutPolicyNestedInput
  }

  export type PolicyUncheckedUpdateWithoutTenantInput = {
    policy_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_system_policy?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    policy_permissions?: PolicyPermissionUncheckedUpdateManyWithoutPolicyNestedInput
    role_policies?: RolePolicyUncheckedUpdateManyWithoutPolicyNestedInput
  }

  export type PolicyUncheckedUpdateManyWithoutTenantInput = {
    policy_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_system_policy?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUpdateWithoutTenantInput = {
    name?: StringFieldUpdateOperationsInput | string
    vendor_code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    drivers?: DriverUpdateManyWithoutVendorNestedInput
    vehicle_types?: VehicleTypeUpdateManyWithoutVendorNestedInput
    vehicles?: VehicleUpdateManyWithoutVendorNestedInput
    vendor_users?: VendorUserUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutTenantInput = {
    vendor_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    vendor_code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    drivers?: DriverUncheckedUpdateManyWithoutVendorNestedInput
    vehicle_types?: VehicleTypeUncheckedUpdateManyWithoutVendorNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutVendorNestedInput
    vendor_users?: VendorUserUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateManyWithoutTenantInput = {
    vendor_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    vendor_code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUpdateWithoutTenantInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_system_role?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role_policies?: RolePolicyUpdateManyWithoutRoleNestedInput
    admins?: AdminUpdateManyWithoutRoleNestedInput
    vendor_users?: VendorUserUpdateManyWithoutRoleNestedInput
    employees?: EmployeeUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutTenantInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_system_role?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role_policies?: RolePolicyUncheckedUpdateManyWithoutRoleNestedInput
    admins?: AdminUncheckedUpdateManyWithoutRoleNestedInput
    vendor_users?: VendorUserUncheckedUpdateManyWithoutRoleNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateManyWithoutTenantInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_system_role?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyPermissionCreateManyPermissionInput = {
    policy_id: number
  }

  export type PolicyPermissionUpdateWithoutPermissionInput = {
    policy?: PolicyUpdateOneRequiredWithoutPolicy_permissionsNestedInput
  }

  export type PolicyPermissionUncheckedUpdateWithoutPermissionInput = {
    policy_id?: IntFieldUpdateOperationsInput | number
  }

  export type PolicyPermissionUncheckedUpdateManyWithoutPermissionInput = {
    policy_id?: IntFieldUpdateOperationsInput | number
  }

  export type PolicyPermissionCreateManyPolicyInput = {
    permission_id: number
  }

  export type RolePolicyCreateManyPolicyInput = {
    role_id: number
  }

  export type PolicyPermissionUpdateWithoutPolicyInput = {
    permission?: PermissionUpdateOneRequiredWithoutPolicy_permissionsNestedInput
  }

  export type PolicyPermissionUncheckedUpdateWithoutPolicyInput = {
    permission_id?: IntFieldUpdateOperationsInput | number
  }

  export type PolicyPermissionUncheckedUpdateManyWithoutPolicyInput = {
    permission_id?: IntFieldUpdateOperationsInput | number
  }

  export type RolePolicyUpdateWithoutPolicyInput = {
    role?: RoleUpdateOneRequiredWithoutRole_policiesNestedInput
  }

  export type RolePolicyUncheckedUpdateWithoutPolicyInput = {
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type RolePolicyUncheckedUpdateManyWithoutPolicyInput = {
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type RolePolicyCreateManyRoleInput = {
    policy_id: number
  }

  export type AdminCreateManyRoleInput = {
    admin_id?: number
    name: string
    email: string
    phone: string
    password: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorUserCreateManyRoleInput = {
    vendor_user_id?: number
    tenant_id: string
    vendor_id: number
    name: string
    email: string
    phone: string
    password: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type EmployeeCreateManyRoleInput = {
    employee_id?: number
    tenant_id: string
    name: string
    employee_code: string
    email: string
    password: string
    team_id?: number | null
    phone: string
    alternate_phone?: string | null
    special_needs?: string | null
    special_needs_start_date?: Date | string | null
    special_needs_end_date?: Date | string | null
    address?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    gender?: $Enums.GenderEnum | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RolePolicyUpdateWithoutRoleInput = {
    policy?: PolicyUpdateOneRequiredWithoutRole_policiesNestedInput
  }

  export type RolePolicyUncheckedUpdateWithoutRoleInput = {
    policy_id?: IntFieldUpdateOperationsInput | number
  }

  export type RolePolicyUncheckedUpdateManyWithoutRoleInput = {
    policy_id?: IntFieldUpdateOperationsInput | number
  }

  export type AdminUpdateWithoutRoleInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateWithoutRoleInput = {
    admin_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateManyWithoutRoleInput = {
    admin_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUserUpdateWithoutRoleInput = {
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutVendor_usersNestedInput
  }

  export type VendorUserUncheckedUpdateWithoutRoleInput = {
    vendor_user_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    vendor_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUserUncheckedUpdateManyWithoutRoleInput = {
    vendor_user_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    vendor_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUpdateWithoutRoleInput = {
    name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    alternate_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    special_needs_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEmployeesNestedInput
    team?: TeamUpdateOneWithoutEmployeesNestedInput
    bookings?: BookingUpdateManyWithoutEmployeeNestedInput
    weekoff_config?: WeekoffConfigUpdateOneWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutRoleInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    team_id?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: StringFieldUpdateOperationsInput | string
    alternate_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    special_needs_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutEmployeeNestedInput
    weekoff_config?: WeekoffConfigUncheckedUpdateOneWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutRoleInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    team_id?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: StringFieldUpdateOperationsInput | string
    alternate_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    special_needs_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gender?: NullableEnumGenderEnumFieldUpdateOperationsInput | $Enums.GenderEnum | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}